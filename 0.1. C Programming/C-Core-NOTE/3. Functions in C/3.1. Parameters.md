
[[C-Core-NOTE]]

- Call by Value (Copy value to a specific location in the stack / Copy value to stack address)
- Call by Address
- Call by Reference

### 1. Call by Value

**Concept**: In Call by Value, the actual parameters (arguments) are copied into the formal parameters of the function. This means any changes made inside the function are local to the function and do not affect the actual parameters.

**Key Points**:

- Ensures the original value is not modified.
- Uses more memory because it creates copies of arguments.
- Typically used when the function does not intend to modify the arguments.

**Example Code**:

```c
#include <stdio.h>

void addTen(int a) {
    a = a + 10; // changes are local to this function
    printf("Inside function: %d\n", a);
}

int main() {
    int num = 5;
    addTen(num); // num is passed by value
    printf("In main: %d\n", num); // num remains unchanged
    return 0;
}
```

### 2. Call by Address

**Concept**: Call by Address (also known as Call by Pointer) involves passing the address of the argument variables. The function's formal parameters are pointers that hold addresses of actual parameters, allowing the function to modify the actual parameters.

**Key Points**:

- Can modify the actual parameters.
- More efficient in terms of memory usage as it doesnâ€™t create copies.
- Care must be taken to avoid unintended side effects.

**Example Code**:

```c
#include <stdio.h>

void addTen(int *ptr) {
    *ptr = *ptr + 10; // modifies the actual parameter
    printf("Inside function: %d\n", *ptr);
}

int main() {
    int num = 5;
    addTen(&num); // address of num is passed
    printf("In main: %d\n", num); // num is modified
    return 0;
}
```

### 3. Call by Reference

**Concept**: Call by Reference method passes the reference of the argument rather than the actual value. In C, this is simulated using pointers (as C doesn't have native reference types like C++). The function can modify the argument's value.

**Key Points**:

- It can modify the original data.
- Efficient in terms of memory and performance as no copies are made.
- Used when a function needs to modify the passed argument.

**Example Code**:

```c
#include <stdio.h>

void swap(int* pA, int* pB) {
    int nTmp = *pA;
    *pA = *pB;
    *pB = nTmp;
    printf("Inside function: a = %d, b = %d\n", *a, *b);
}

int main() {
    int x = 10, y = 20;
    swap(&x, &y); // passing addresses to simulate reference
    printf("In main: x = %d, y = %d\n", x, y); // x and y values are swapped
    return 0;
}
```

```c
int main(void) {
	char szBuffer[1024]; // 1024-byte = 1 KB
	// char szBuffer[1024 * 1024]; // 1 MB -> Stack overflow
	strcpy_s(szBuffer, sizeof(szBuffer), "Hellow world");
	printf("%s\n", szBuffer);
}
```