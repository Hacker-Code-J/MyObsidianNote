/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name41 in all)
    __defProp(target, name41, { get: all[name41], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// manifest.json
var require_manifest = __commonJS({
  "manifest.json"(exports, module2) {
    module2.exports = {
      id: "share-note",
      name: "Share Note",
      version: "0.8.17",
      minAppVersion: "0.15.0",
      description: "Instantly share a note, with the full theme and content exactly like you see in Reading View. Data is shared encrypted by default, and only you and the person you send it to have the key.",
      author: "Alan Grainger",
      authorUrl: "https://github.com/alangrainger",
      fundingUrl: "https://ko-fi.com/alan_",
      isDesktopOnly: false
    };
  }
});

// node_modules/data-uri-to-buffer/dist/index.js
var require_dist = __commonJS({
  "node_modules/data-uri-to-buffer/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dataUriToBuffer = void 0;
    function base64ToArrayBuffer2(base64) {
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const bytes = [];
      for (let i2 = 0; i2 < base64.length; i2 += 4) {
        const idx0 = chars.indexOf(base64.charAt(i2));
        const idx1 = chars.indexOf(base64.charAt(i2 + 1));
        const idx2 = base64.charAt(i2 + 2) === "=" ? 0 : chars.indexOf(base64.charAt(i2 + 2));
        const idx3 = base64.charAt(i2 + 3) === "=" ? 0 : chars.indexOf(base64.charAt(i2 + 3));
        const bin0 = idx0 << 2 | idx1 >> 4;
        const bin1 = (idx1 & 15) << 4 | idx2 >> 2;
        const bin2 = (idx2 & 3) << 6 | idx3;
        bytes.push(bin0);
        if (base64.charAt(i2 + 2) !== "=")
          bytes.push(bin1);
        if (base64.charAt(i2 + 3) !== "=")
          bytes.push(bin2);
      }
      const buffer = new ArrayBuffer(bytes.length);
      const view = new Uint8Array(buffer);
      view.set(bytes);
      return buffer;
    }
    function stringToBuffer(str) {
      const buffer = new ArrayBuffer(str.length);
      const view = new Uint8Array(buffer);
      for (let i2 = 0; i2 < str.length; i2++) {
        view[i2] = str.charCodeAt(i2);
      }
      return buffer;
    }
    function dataUriToBuffer2(uri) {
      uri = String(uri);
      if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      const firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      const meta = uri.substring(5, firstComma).split(";");
      let charset = "";
      let base64 = false;
      const type = meta[0] || "text/plain";
      let typeFull = type;
      for (let i2 = 1; i2 < meta.length; i2++) {
        if (meta[i2] === "base64") {
          base64 = true;
        } else if (meta[i2]) {
          typeFull += `;${meta[i2]}`;
          if (meta[i2].indexOf("charset=") === 0) {
            charset = meta[i2].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      const data = unescape(uri.substring(firstComma + 1));
      const buffer = base64 ? base64ToArrayBuffer2(data) : stringToBuffer(data);
      return {
        type,
        typeFull,
        charset,
        buffer
      };
    }
    exports.dataUriToBuffer = dataUriToBuffer2;
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number2) {
      if (0 <= number2 && number2 < intToCharMap.length) {
        return intToCharMap[number2];
      }
      throw new TypeError("Must be between 0 and 63: " + number2);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero2 = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero2 <= charCode && charCode <= nine) {
        return charCode - zero2 + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f2) {
      var cache = [];
      return function(input) {
        for (var i2 = 0; i2 < cache.length; i2++) {
          if (cache[i2].input === input) {
            var temp = cache[0];
            cache[0] = cache[i2];
            cache[i2] = temp;
            return cache[0].result;
          }
        }
        var result = f2(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = [];
      var start = 0;
      var i2 = 0;
      while (true) {
        start = i2;
        i2 = path.indexOf("/", start);
        if (i2 === -1) {
          parts.push(path.slice(start));
          break;
        } else {
          parts.push(path.slice(start, i2));
          while (i2 < path.length && path[i2] === "/") {
            i2++;
          }
        }
      }
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    });
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i2 = length - 10; i2 >= 0; i2--) {
        if (s2.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
        set.add(aArray[i2], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator2(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator2.prototype._version = 3;
    SourceMapGenerator2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator2({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name41 = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name41);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name41 != null) {
        name41 = String(name41);
        if (!this._names.has(name41)) {
          this._names.add(name41);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name: name41
      });
    };
    SourceMapGenerator2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name41 = mapping.name;
        if (name41 != null && !newNames.has(name41)) {
          newNames.add(name41);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
        mapping = mappings[i2];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i2 > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator2.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator2.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator2;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SharePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var ThemeMode = /* @__PURE__ */ ((ThemeMode2) => {
  ThemeMode2[ThemeMode2["Same as theme"] = 0] = "Same as theme";
  ThemeMode2[ThemeMode2["Dark"] = 1] = "Dark";
  ThemeMode2[ThemeMode2["Light"] = 2] = "Light";
  return ThemeMode2;
})(ThemeMode || {});
var TitleSource = /* @__PURE__ */ ((TitleSource2) => {
  TitleSource2[TitleSource2["Note title"] = 0] = "Note title";
  TitleSource2[TitleSource2["First H1"] = 1] = "First H1";
  TitleSource2[TitleSource2["Frontmatter property"] = 2] = "Frontmatter property";
  return TitleSource2;
})(TitleSource || {});
var YamlField = /* @__PURE__ */ ((YamlField2) => {
  YamlField2[YamlField2["link"] = 0] = "link";
  YamlField2[YamlField2["updated"] = 1] = "updated";
  YamlField2[YamlField2["encrypted"] = 2] = "encrypted";
  YamlField2[YamlField2["unencrypted"] = 3] = "unencrypted";
  YamlField2[YamlField2["title"] = 4] = "title";
  YamlField2[YamlField2["expires"] = 5] = "expires";
  return YamlField2;
})(YamlField || {});
var DEFAULT_SETTINGS = {
  server: "https://api.note.sx",
  uid: "",
  apiKey: "",
  yamlField: "share",
  noteWidth: "",
  theme: "",
  themeMode: 0 /* Same as theme */,
  titleSource: 0 /* Note title */,
  removeYaml: true,
  removeBacklinksFooter: true,
  expiry: "",
  clipboard: true,
  shareUnencrypted: false,
  authRedirect: null,
  debug: 0
};
var ShareSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("API key").setDesc("Click the button to request a new API key").addButton((btn) => btn.setButtonText("Connect plugin").setCta().onClick(() => {
      window.open(this.plugin.settings.server + "/v1/account/get-key?id=" + this.plugin.settings.uid);
    })).addText((inputEl) => {
      this.apikeyEl = inputEl;
      inputEl.setPlaceholder("API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Frontmatter property prefix").setDesc("The frontmatter property for storing the shared link and updated time. A value of `share` will create frontmatter fields of `share_link` and `share_updated`.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.yamlField).setValue(this.plugin.settings.yamlField).onChange(async (value) => {
      this.plugin.settings.yamlField = value || DEFAULT_SETTINGS.yamlField;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Upload options").setHeading();
    new import_obsidian.Setting(containerEl).setName(`\u2B50 Your shared note theme is "${this.plugin.settings.theme || "Obsidian default theme"}"`).setDesc("To set a new theme, change the theme in Obsidian to your desired theme and then use the `Force re-upload all data` command. You can change your Obsidian theme after that without affecting the theme for your shared notes.").then((setting) => addDocs(setting, "https://docs.note.sx/notes/theme"));
    new import_obsidian.Setting(containerEl).setName("Light/Dark mode").setDesc("Choose the mode with which your files will be shared").addDropdown((dropdown) => {
      dropdown.addOption("Same as theme", "Same as theme").addOption("Dark", "Dark").addOption("Light", "Light").setValue(ThemeMode[this.plugin.settings.themeMode]).onChange(async (value) => {
        this.plugin.settings.themeMode = ThemeMode[value];
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Copy the link to clipboard after sharing").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.clipboard).onChange(async (value) => {
        this.plugin.settings.clipboard = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Note options").setHeading();
    const defaultTitleDesc = "Select the location to source the published note title. It will default to the note title if nothing is found for the selected option.";
    const titleSetting = new import_obsidian.Setting(containerEl).setName("Note title source").setDesc(defaultTitleDesc).addDropdown((dropdown) => {
      for (const enumKey in TitleSource) {
        if (isNaN(Number(enumKey))) {
          dropdown.addOption(enumKey, enumKey);
        }
      }
      dropdown.setValue(TitleSource[this.plugin.settings.titleSource]).onChange(async (value) => {
        this.plugin.settings.titleSource = TitleSource[value];
        if (this.plugin.settings.titleSource === 2 /* Frontmatter property */) {
          titleSetting.setDesc("Set the title you want to use in a frontmatter property called `" + this.plugin.field(4 /* title */) + "`");
        } else {
          titleSetting.setDesc(defaultTitleDesc);
        }
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Note reading width").setDesc("The max width for the content of your shared note, accepts any CSS unit. Leave this value empty if you want to use the theme's width.").addText((text) => text.setValue(this.plugin.settings.noteWidth).onChange(async (value) => {
      this.plugin.settings.noteWidth = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Remove published frontmatter/YAML").setDesc("Remove frontmatter/YAML/properties from the shared note").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.removeYaml).onChange(async (value) => {
        this.plugin.settings.removeYaml = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Remove backlinks footer").setDesc("Remove backlinks footer from the shared note").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.removeBacklinksFooter).onChange(async (value) => {
        this.plugin.settings.removeBacklinksFooter = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Share as encrypted by default").setDesc("If you turn this off, you can enable encryption for individual notes by adding a `share_encrypted` checkbox into a note and ticking it.").addToggle((toggle) => {
      toggle.setValue(!this.plugin.settings.shareUnencrypted).onChange(async (value) => {
        this.plugin.settings.shareUnencrypted = !value;
        await this.plugin.saveSettings();
        this.display();
      });
    }).then((setting) => addDocs(setting, "https://docs.note.sx/notes/encryption"));
    new import_obsidian.Setting(containerEl).setName("Default note expiry").setDesc("If you want, your notes can auto-delete themselves after a period of time. You can set this as a default for all notes here, or you can set it on a per-note basis.").addText((text) => text.setValue(this.plugin.settings.expiry).onChange(async (value) => {
      this.plugin.settings.expiry = value;
      await this.plugin.saveSettings();
    })).then((setting) => addDocs(setting, "https://docs.note.sx/notes/self-deleting-notes"));
  }
};
function addDocs(setting, url) {
  setting.descEl.createEl("br");
  setting.descEl.createEl("a", {
    text: "View the documentation",
    href: url
  });
}

// src/note.ts
var import_obsidian4 = require("obsidian");

// src/crypto.ts
async function _generateKey(seed) {
  const keyMaterial = await window.crypto.subtle.importKey(
    "raw",
    seed,
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  );
  const masterKey = await window.crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt: new Uint8Array(16),
      iterations: 1e5,
      hash: "SHA-256"
    },
    keyMaterial,
    256
  );
  return new Uint8Array(masterKey);
}
function masterKeyToString(masterKey) {
  return arrayBufferToBase64(masterKey);
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    binary += String.fromCharCode(bytes[i2]);
  }
  return window.btoa(binary);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(window.atob(base64), (c2) => c2.charCodeAt(0));
}
function _getAesGcmKey(secret) {
  return window.crypto.subtle.importKey(
    "raw",
    secret,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}
async function encryptString(plaintext, existingKey) {
  let key;
  if (existingKey) {
    key = base64ToArrayBuffer(existingKey);
  } else {
    key = await _generateKey(window.crypto.getRandomValues(new Uint8Array(64)));
  }
  const iv = new Uint8Array(1);
  const aesKey = await _getAesGcmKey(key);
  const ciphertext = [];
  const length = plaintext.length;
  const chunkSize = 2e3;
  let index = 0;
  while (index * chunkSize < length) {
    const plaintextChunk = plaintext.slice(index * chunkSize, (index + 1) * chunkSize);
    const encodedText = new TextEncoder().encode(plaintextChunk);
    iv[0] = index & 255;
    const bufCiphertext = await window.crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      aesKey,
      encodedText
    );
    ciphertext.push(arrayBufferToBase64(bufCiphertext));
    index++;
  }
  return {
    ciphertext,
    key: masterKeyToString(key).slice(0, 43)
  };
}
async function sha(algorithm, data) {
  let uint8Array;
  if (typeof data === "string") {
    const encoder = new TextEncoder();
    uint8Array = encoder.encode(data);
  } else {
    uint8Array = data;
  }
  const hash = await crypto.subtle.digest(algorithm, uint8Array);
  return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function sha256(data) {
  return sha("SHA-256", data);
}
async function sha1(data) {
  return sha("SHA-1", data);
}
async function shortHash(text) {
  return (await sha256(text)).slice(0, 32);
}

// src/StatusMessage.ts
var import_obsidian2 = require("obsidian");
var pluginName = require_manifest().name;
var statuses = {
  [2 /* Error */]: {
    class: "share-note-status-error",
    icon: "\u274C "
  },
  [1 /* Info */]: {
    class: "share-note-status-info",
    icon: ""
  },
  [3 /* Success */]: {
    class: "share-note-status-success",
    icon: "\u2714 "
  }
};
var StatusMessage = class extends import_obsidian2.Notice {
  constructor(text, type = 0 /* Default */, duration = 5e3) {
    var _a;
    const messageDoc = new DocumentFragment();
    const icon = ((_a = statuses[type]) == null ? void 0 : _a.icon) || "";
    const messageEl = messageDoc.createEl("div", {
      text: `${icon}${pluginName}: ${text}`
    });
    super(messageDoc, duration);
    if (messageEl.parentElement) {
      if (statuses[type]) {
        messageEl.parentElement.classList.add(statuses[type].class);
      }
    }
    this.icon = icon;
    this.messageEl = messageEl;
  }
  setStatus(message) {
    this.messageEl.innerText = `${this.icon}${pluginName}: ${message}`;
  }
};

// src/NoteTemplate.ts
function getElementStyle(key, element) {
  const elementStyle = {
    element: key,
    classes: [],
    style: ""
  };
  try {
    elementStyle.classes = Array.from(element.classList);
    const style = element.style;
    if (element.classList.contains("markdown-preview-pusher")) {
      style.removeProperty("margin-bottom");
    }
    elementStyle.style = style.cssText;
  } catch (e2) {
    console.log(e2);
  }
  return elementStyle;
}
var NoteTemplate = class {
  constructor() {
    this.elements = [];
  }
};

// src/note.ts
var import_data_uri_to_buffer = __toESM(require_dist());

// src/libraries/FileTypes.ts
var FileType = class {
  constructor(fileType) {
    this.extension = fileType.extension;
    this.mimetypes = fileType.mimetypes;
    this.signature = fileType.signature;
  }
  get mimetype() {
    return this.mimetypes[0];
  }
};
var types = [
  {
    extension: "ttf",
    mimetypes: ["font/ttf", "application/x-font-ttf", "application/x-font-truetype", "font/truetype"],
    signature: new Uint8Array([0, 1, 0, 0, 0])
  },
  {
    extension: "otf",
    mimetypes: ["font/otf", "application/x-font-opentype"],
    signature: new Uint8Array([79, 84, 84, 79])
  },
  {
    extension: "woff",
    mimetypes: ["font/woff", "application/font-woff", "application/x-font-woff"],
    signature: new Uint8Array([119, 79, 70, 70])
  },
  {
    extension: "woff2",
    mimetypes: ["font/woff2", "application/font-woff2", "application/x-font-woff2"],
    signature: new Uint8Array([119, 79, 70, 50])
  },
  {
    extension: "svg",
    mimetypes: ["image/svg+xml"]
  }
];
var FileTypes = class {
  getFromMimetype(mimetype) {
    const type = types.find((x) => x.mimetypes.includes(mimetype));
    return type ? new FileType(type) : void 0;
  }
  getFromExtension(extension) {
    const type = types.find((x) => x.extension === extension.toLowerCase());
    return type ? new FileType(type) : void 0;
  }
  getFromSignature(signature) {
    if (signature instanceof ArrayBuffer) {
      signature = new Uint8Array(signature, 0, 10);
    }
    const type = types.find((library) => library.signature && this.bufferIsEqual(library.signature, signature));
    return type ? new FileType(type) : void 0;
  }
  bufferIsEqual(librarySignature, userSignature) {
    for (let i2 = 0; i2 < librarySignature.length; i2++) {
      if (librarySignature[i2] !== (userSignature == null ? void 0 : userSignature[i2])) {
        return false;
      }
    }
    return true;
  }
};
var FileTypes_default = new FileTypes();

// src/api.ts
var import_obsidian3 = require("obsidian");

// node_modules/browser-image-compression/dist/browser-image-compression.mjs
function _mergeNamespaces(e2, t2) {
  return t2.forEach(function(t3) {
    t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach(function(r2) {
      if ("default" !== r2 && !(r2 in e2)) {
        var i2 = Object.getOwnPropertyDescriptor(t3, r2);
        Object.defineProperty(e2, r2, i2.get ? i2 : { enumerable: true, get: function() {
          return t3[r2];
        } });
      }
    });
  }), Object.freeze(e2);
}
function copyExifWithoutOrientation(e2, t2) {
  return new Promise(function(r2, i2) {
    let o2;
    return getApp1Segment(e2).then(function(e3) {
      try {
        return o2 = e3, r2(new Blob([t2.slice(0, 2), o2, t2.slice(2)], { type: "image/jpeg" }));
      } catch (e4) {
        return i2(e4);
      }
    }, i2);
  });
}
var getApp1Segment = (e2) => new Promise((t2, r2) => {
  const i2 = new FileReader();
  i2.addEventListener("load", ({ target: { result: e3 } }) => {
    const i3 = new DataView(e3);
    let o2 = 0;
    if (65496 !== i3.getUint16(o2))
      return r2("not a valid JPEG");
    for (o2 += 2; ; ) {
      const a2 = i3.getUint16(o2);
      if (65498 === a2)
        break;
      const s2 = i3.getUint16(o2 + 2);
      if (65505 === a2 && 1165519206 === i3.getUint32(o2 + 4)) {
        const a3 = o2 + 10;
        let f2;
        switch (i3.getUint16(a3)) {
          case 18761:
            f2 = true;
            break;
          case 19789:
            f2 = false;
            break;
          default:
            return r2("TIFF header contains invalid endian");
        }
        if (42 !== i3.getUint16(a3 + 2, f2))
          return r2("TIFF header contains invalid version");
        const l2 = i3.getUint32(a3 + 4, f2), c2 = a3 + l2 + 2 + 12 * i3.getUint16(a3 + l2, f2);
        for (let e4 = a3 + l2 + 2; e4 < c2; e4 += 12) {
          if (274 == i3.getUint16(e4, f2)) {
            if (3 !== i3.getUint16(e4 + 2, f2))
              return r2("Orientation data type is invalid");
            if (1 !== i3.getUint32(e4 + 4, f2))
              return r2("Orientation data count is invalid");
            i3.setUint16(e4 + 8, 1, f2);
            break;
          }
        }
        return t2(e3.slice(o2, o2 + 2 + s2));
      }
      o2 += 2 + s2;
    }
    return t2(new Blob());
  }), i2.readAsArrayBuffer(e2);
});
var e = {};
var t = { get exports() {
  return e;
}, set exports(t2) {
  e = t2;
} };
!function(e2) {
  var r2, i2, UZIP2 = {};
  t.exports = UZIP2, UZIP2.parse = function(e3, t2) {
    for (var r3 = UZIP2.bin.readUshort, i3 = UZIP2.bin.readUint, o2 = 0, a2 = {}, s2 = new Uint8Array(e3), f2 = s2.length - 4; 101010256 != i3(s2, f2); )
      f2--;
    o2 = f2;
    o2 += 4;
    var l2 = r3(s2, o2 += 4);
    r3(s2, o2 += 2);
    var c2 = i3(s2, o2 += 2), u = i3(s2, o2 += 4);
    o2 += 4, o2 = u;
    for (var h = 0; h < l2; h++) {
      i3(s2, o2), o2 += 4, o2 += 4, o2 += 4, i3(s2, o2 += 4);
      c2 = i3(s2, o2 += 4);
      var d = i3(s2, o2 += 4), A = r3(s2, o2 += 4), g = r3(s2, o2 + 2), p = r3(s2, o2 + 4);
      o2 += 6;
      var m = i3(s2, o2 += 8);
      o2 += 4, o2 += A + g + p, UZIP2._readLocal(s2, m, a2, c2, d, t2);
    }
    return a2;
  }, UZIP2._readLocal = function(e3, t2, r3, i3, o2, a2) {
    var s2 = UZIP2.bin.readUshort, f2 = UZIP2.bin.readUint;
    f2(e3, t2), s2(e3, t2 += 4), s2(e3, t2 += 2);
    var l2 = s2(e3, t2 += 2);
    f2(e3, t2 += 2), f2(e3, t2 += 4), t2 += 4;
    var c2 = s2(e3, t2 += 8), u = s2(e3, t2 += 2);
    t2 += 2;
    var h = UZIP2.bin.readUTF8(e3, t2, c2);
    if (t2 += c2, t2 += u, a2)
      r3[h] = { size: o2, csize: i3 };
    else {
      var d = new Uint8Array(e3.buffer, t2);
      if (0 == l2)
        r3[h] = new Uint8Array(d.buffer.slice(t2, t2 + i3));
      else {
        if (8 != l2)
          throw "unknown compression method: " + l2;
        var A = new Uint8Array(o2);
        UZIP2.inflateRaw(d, A), r3[h] = A;
      }
    }
  }, UZIP2.inflateRaw = function(e3, t2) {
    return UZIP2.F.inflate(e3, t2);
  }, UZIP2.inflate = function(e3, t2) {
    return e3[0], e3[1], UZIP2.inflateRaw(new Uint8Array(e3.buffer, e3.byteOffset + 2, e3.length - 6), t2);
  }, UZIP2.deflate = function(e3, t2) {
    null == t2 && (t2 = { level: 6 });
    var r3 = 0, i3 = new Uint8Array(50 + Math.floor(1.1 * e3.length));
    i3[r3] = 120, i3[r3 + 1] = 156, r3 += 2, r3 = UZIP2.F.deflateRaw(e3, i3, r3, t2.level);
    var o2 = UZIP2.adler(e3, 0, e3.length);
    return i3[r3 + 0] = o2 >>> 24 & 255, i3[r3 + 1] = o2 >>> 16 & 255, i3[r3 + 2] = o2 >>> 8 & 255, i3[r3 + 3] = o2 >>> 0 & 255, new Uint8Array(i3.buffer, 0, r3 + 4);
  }, UZIP2.deflateRaw = function(e3, t2) {
    null == t2 && (t2 = { level: 6 });
    var r3 = new Uint8Array(50 + Math.floor(1.1 * e3.length)), i3 = UZIP2.F.deflateRaw(e3, r3, i3, t2.level);
    return new Uint8Array(r3.buffer, 0, i3);
  }, UZIP2.encode = function(e3, t2) {
    null == t2 && (t2 = false);
    var r3 = 0, i3 = UZIP2.bin.writeUint, o2 = UZIP2.bin.writeUshort, a2 = {};
    for (var s2 in e3) {
      var f2 = !UZIP2._noNeed(s2) && !t2, l2 = e3[s2], c2 = UZIP2.crc.crc(l2, 0, l2.length);
      a2[s2] = { cpr: f2, usize: l2.length, crc: c2, file: f2 ? UZIP2.deflateRaw(l2) : l2 };
    }
    for (var s2 in a2)
      r3 += a2[s2].file.length + 30 + 46 + 2 * UZIP2.bin.sizeUTF8(s2);
    r3 += 22;
    var u = new Uint8Array(r3), h = 0, d = [];
    for (var s2 in a2) {
      var A = a2[s2];
      d.push(h), h = UZIP2._writeHeader(u, h, s2, A, 0);
    }
    var g = 0, p = h;
    for (var s2 in a2) {
      A = a2[s2];
      d.push(h), h = UZIP2._writeHeader(u, h, s2, A, 1, d[g++]);
    }
    var m = h - p;
    return i3(u, h, 101010256), h += 4, o2(u, h += 4, g), o2(u, h += 2, g), i3(u, h += 2, m), i3(u, h += 4, p), h += 4, h += 2, u.buffer;
  }, UZIP2._noNeed = function(e3) {
    var t2 = e3.split(".").pop().toLowerCase();
    return -1 != "png,jpg,jpeg,zip".indexOf(t2);
  }, UZIP2._writeHeader = function(e3, t2, r3, i3, o2, a2) {
    var s2 = UZIP2.bin.writeUint, f2 = UZIP2.bin.writeUshort, l2 = i3.file;
    return s2(e3, t2, 0 == o2 ? 67324752 : 33639248), t2 += 4, 1 == o2 && (t2 += 2), f2(e3, t2, 20), f2(e3, t2 += 2, 0), f2(e3, t2 += 2, i3.cpr ? 8 : 0), s2(e3, t2 += 2, 0), s2(e3, t2 += 4, i3.crc), s2(e3, t2 += 4, l2.length), s2(e3, t2 += 4, i3.usize), f2(e3, t2 += 4, UZIP2.bin.sizeUTF8(r3)), f2(e3, t2 += 2, 0), t2 += 2, 1 == o2 && (t2 += 2, t2 += 2, s2(e3, t2 += 6, a2), t2 += 4), t2 += UZIP2.bin.writeUTF8(e3, t2, r3), 0 == o2 && (e3.set(l2, t2), t2 += l2.length), t2;
  }, UZIP2.crc = { table: function() {
    for (var e3 = new Uint32Array(256), t2 = 0; t2 < 256; t2++) {
      for (var r3 = t2, i3 = 0; i3 < 8; i3++)
        1 & r3 ? r3 = 3988292384 ^ r3 >>> 1 : r3 >>>= 1;
      e3[t2] = r3;
    }
    return e3;
  }(), update: function(e3, t2, r3, i3) {
    for (var o2 = 0; o2 < i3; o2++)
      e3 = UZIP2.crc.table[255 & (e3 ^ t2[r3 + o2])] ^ e3 >>> 8;
    return e3;
  }, crc: function(e3, t2, r3) {
    return 4294967295 ^ UZIP2.crc.update(4294967295, e3, t2, r3);
  } }, UZIP2.adler = function(e3, t2, r3) {
    for (var i3 = 1, o2 = 0, a2 = t2, s2 = t2 + r3; a2 < s2; ) {
      for (var f2 = Math.min(a2 + 5552, s2); a2 < f2; )
        o2 += i3 += e3[a2++];
      i3 %= 65521, o2 %= 65521;
    }
    return o2 << 16 | i3;
  }, UZIP2.bin = { readUshort: function(e3, t2) {
    return e3[t2] | e3[t2 + 1] << 8;
  }, writeUshort: function(e3, t2, r3) {
    e3[t2] = 255 & r3, e3[t2 + 1] = r3 >> 8 & 255;
  }, readUint: function(e3, t2) {
    return 16777216 * e3[t2 + 3] + (e3[t2 + 2] << 16 | e3[t2 + 1] << 8 | e3[t2]);
  }, writeUint: function(e3, t2, r3) {
    e3[t2] = 255 & r3, e3[t2 + 1] = r3 >> 8 & 255, e3[t2 + 2] = r3 >> 16 & 255, e3[t2 + 3] = r3 >> 24 & 255;
  }, readASCII: function(e3, t2, r3) {
    for (var i3 = "", o2 = 0; o2 < r3; o2++)
      i3 += String.fromCharCode(e3[t2 + o2]);
    return i3;
  }, writeASCII: function(e3, t2, r3) {
    for (var i3 = 0; i3 < r3.length; i3++)
      e3[t2 + i3] = r3.charCodeAt(i3);
  }, pad: function(e3) {
    return e3.length < 2 ? "0" + e3 : e3;
  }, readUTF8: function(e3, t2, r3) {
    for (var i3, o2 = "", a2 = 0; a2 < r3; a2++)
      o2 += "%" + UZIP2.bin.pad(e3[t2 + a2].toString(16));
    try {
      i3 = decodeURIComponent(o2);
    } catch (i4) {
      return UZIP2.bin.readASCII(e3, t2, r3);
    }
    return i3;
  }, writeUTF8: function(e3, t2, r3) {
    for (var i3 = r3.length, o2 = 0, a2 = 0; a2 < i3; a2++) {
      var s2 = r3.charCodeAt(a2);
      if (0 == (4294967168 & s2))
        e3[t2 + o2] = s2, o2++;
      else if (0 == (4294965248 & s2))
        e3[t2 + o2] = 192 | s2 >> 6, e3[t2 + o2 + 1] = 128 | s2 >> 0 & 63, o2 += 2;
      else if (0 == (4294901760 & s2))
        e3[t2 + o2] = 224 | s2 >> 12, e3[t2 + o2 + 1] = 128 | s2 >> 6 & 63, e3[t2 + o2 + 2] = 128 | s2 >> 0 & 63, o2 += 3;
      else {
        if (0 != (4292870144 & s2))
          throw "e";
        e3[t2 + o2] = 240 | s2 >> 18, e3[t2 + o2 + 1] = 128 | s2 >> 12 & 63, e3[t2 + o2 + 2] = 128 | s2 >> 6 & 63, e3[t2 + o2 + 3] = 128 | s2 >> 0 & 63, o2 += 4;
      }
    }
    return o2;
  }, sizeUTF8: function(e3) {
    for (var t2 = e3.length, r3 = 0, i3 = 0; i3 < t2; i3++) {
      var o2 = e3.charCodeAt(i3);
      if (0 == (4294967168 & o2))
        r3++;
      else if (0 == (4294965248 & o2))
        r3 += 2;
      else if (0 == (4294901760 & o2))
        r3 += 3;
      else {
        if (0 != (4292870144 & o2))
          throw "e";
        r3 += 4;
      }
    }
    return r3;
  } }, UZIP2.F = {}, UZIP2.F.deflateRaw = function(e3, t2, r3, i3) {
    var o2 = [[0, 0, 0, 0, 0], [4, 4, 8, 4, 0], [4, 5, 16, 8, 0], [4, 6, 16, 16, 0], [4, 10, 16, 32, 0], [8, 16, 32, 32, 0], [8, 16, 128, 128, 0], [8, 32, 128, 256, 0], [32, 128, 258, 1024, 1], [32, 258, 258, 4096, 1]][i3], a2 = UZIP2.F.U, s2 = UZIP2.F._goodIndex;
    UZIP2.F._hash;
    var f2 = UZIP2.F._putsE, l2 = 0, c2 = r3 << 3, u = 0, h = e3.length;
    if (0 == i3) {
      for (; l2 < h; ) {
        f2(t2, c2, l2 + (_ = Math.min(65535, h - l2)) == h ? 1 : 0), c2 = UZIP2.F._copyExact(e3, l2, _, t2, c2 + 8), l2 += _;
      }
      return c2 >>> 3;
    }
    var d = a2.lits, A = a2.strt, g = a2.prev, p = 0, m = 0, w = 0, v = 0, b = 0, y = 0;
    for (h > 2 && (A[y = UZIP2.F._hash(e3, 0)] = 0), l2 = 0; l2 < h; l2++) {
      if (b = y, l2 + 1 < h - 2) {
        y = UZIP2.F._hash(e3, l2 + 1);
        var E = l2 + 1 & 32767;
        g[E] = A[y], A[y] = E;
      }
      if (u <= l2) {
        (p > 14e3 || m > 26697) && h - l2 > 100 && (u < l2 && (d[p] = l2 - u, p += 2, u = l2), c2 = UZIP2.F._writeBlock(l2 == h - 1 || u == h ? 1 : 0, d, p, v, e3, w, l2 - w, t2, c2), p = m = v = 0, w = l2);
        var F4 = 0;
        l2 < h - 2 && (F4 = UZIP2.F._bestMatch(e3, l2, g, b, Math.min(o2[2], h - l2), o2[3]));
        var _ = F4 >>> 16, B = 65535 & F4;
        if (0 != F4) {
          B = 65535 & F4;
          var U3 = s2(_ = F4 >>> 16, a2.of0);
          a2.lhst[257 + U3]++;
          var C = s2(B, a2.df0);
          a2.dhst[C]++, v += a2.exb[U3] + a2.dxb[C], d[p] = _ << 23 | l2 - u, d[p + 1] = B << 16 | U3 << 8 | C, p += 2, u = l2 + _;
        } else
          a2.lhst[e3[l2]]++;
        m++;
      }
    }
    for (w == l2 && 0 != e3.length || (u < l2 && (d[p] = l2 - u, p += 2, u = l2), c2 = UZIP2.F._writeBlock(1, d, p, v, e3, w, l2 - w, t2, c2), p = 0, m = 0, p = m = v = 0, w = l2); 0 != (7 & c2); )
      c2++;
    return c2 >>> 3;
  }, UZIP2.F._bestMatch = function(e3, t2, r3, i3, o2, a2) {
    var s2 = 32767 & t2, f2 = r3[s2], l2 = s2 - f2 + 32768 & 32767;
    if (f2 == s2 || i3 != UZIP2.F._hash(e3, t2 - l2))
      return 0;
    for (var c2 = 0, u = 0, h = Math.min(32767, t2); l2 <= h && 0 != --a2 && f2 != s2; ) {
      if (0 == c2 || e3[t2 + c2] == e3[t2 + c2 - l2]) {
        var d = UZIP2.F._howLong(e3, t2, l2);
        if (d > c2) {
          if (u = l2, (c2 = d) >= o2)
            break;
          l2 + 2 < d && (d = l2 + 2);
          for (var A = 0, g = 0; g < d - 2; g++) {
            var p = t2 - l2 + g + 32768 & 32767, m = p - r3[p] + 32768 & 32767;
            m > A && (A = m, f2 = p);
          }
        }
      }
      l2 += (s2 = f2) - (f2 = r3[s2]) + 32768 & 32767;
    }
    return c2 << 16 | u;
  }, UZIP2.F._howLong = function(e3, t2, r3) {
    if (e3[t2] != e3[t2 - r3] || e3[t2 + 1] != e3[t2 + 1 - r3] || e3[t2 + 2] != e3[t2 + 2 - r3])
      return 0;
    var i3 = t2, o2 = Math.min(e3.length, t2 + 258);
    for (t2 += 3; t2 < o2 && e3[t2] == e3[t2 - r3]; )
      t2++;
    return t2 - i3;
  }, UZIP2.F._hash = function(e3, t2) {
    return (e3[t2] << 8 | e3[t2 + 1]) + (e3[t2 + 2] << 4) & 65535;
  }, UZIP2.saved = 0, UZIP2.F._writeBlock = function(e3, t2, r3, i3, o2, a2, s2, f2, l2) {
    var c2, u, h, d, A, g, p, m, w, v = UZIP2.F.U, b = UZIP2.F._putsF, y = UZIP2.F._putsE;
    v.lhst[256]++, u = (c2 = UZIP2.F.getTrees())[0], h = c2[1], d = c2[2], A = c2[3], g = c2[4], p = c2[5], m = c2[6], w = c2[7];
    var E = 32 + (0 == (l2 + 3 & 7) ? 0 : 8 - (l2 + 3 & 7)) + (s2 << 3), F4 = i3 + UZIP2.F.contSize(v.fltree, v.lhst) + UZIP2.F.contSize(v.fdtree, v.dhst), _ = i3 + UZIP2.F.contSize(v.ltree, v.lhst) + UZIP2.F.contSize(v.dtree, v.dhst);
    _ += 14 + 3 * p + UZIP2.F.contSize(v.itree, v.ihst) + (2 * v.ihst[16] + 3 * v.ihst[17] + 7 * v.ihst[18]);
    for (var B = 0; B < 286; B++)
      v.lhst[B] = 0;
    for (B = 0; B < 30; B++)
      v.dhst[B] = 0;
    for (B = 0; B < 19; B++)
      v.ihst[B] = 0;
    var U3 = E < F4 && E < _ ? 0 : F4 < _ ? 1 : 2;
    if (b(f2, l2, e3), b(f2, l2 + 1, U3), l2 += 3, 0 == U3) {
      for (; 0 != (7 & l2); )
        l2++;
      l2 = UZIP2.F._copyExact(o2, a2, s2, f2, l2);
    } else {
      var C, I;
      if (1 == U3 && (C = v.fltree, I = v.fdtree), 2 == U3) {
        UZIP2.F.makeCodes(v.ltree, u), UZIP2.F.revCodes(v.ltree, u), UZIP2.F.makeCodes(v.dtree, h), UZIP2.F.revCodes(v.dtree, h), UZIP2.F.makeCodes(v.itree, d), UZIP2.F.revCodes(v.itree, d), C = v.ltree, I = v.dtree, y(f2, l2, A - 257), y(f2, l2 += 5, g - 1), y(f2, l2 += 5, p - 4), l2 += 4;
        for (var Q = 0; Q < p; Q++)
          y(f2, l2 + 3 * Q, v.itree[1 + (v.ordr[Q] << 1)]);
        l2 += 3 * p, l2 = UZIP2.F._codeTiny(m, v.itree, f2, l2), l2 = UZIP2.F._codeTiny(w, v.itree, f2, l2);
      }
      for (var M = a2, x = 0; x < r3; x += 2) {
        for (var S = t2[x], R4 = S >>> 23, T = M + (8388607 & S); M < T; )
          l2 = UZIP2.F._writeLit(o2[M++], C, f2, l2);
        if (0 != R4) {
          var O = t2[x + 1], P = O >> 16, H = O >> 8 & 255, L = 255 & O;
          y(f2, l2 = UZIP2.F._writeLit(257 + H, C, f2, l2), R4 - v.of0[H]), l2 += v.exb[H], b(f2, l2 = UZIP2.F._writeLit(L, I, f2, l2), P - v.df0[L]), l2 += v.dxb[L], M += R4;
        }
      }
      l2 = UZIP2.F._writeLit(256, C, f2, l2);
    }
    return l2;
  }, UZIP2.F._copyExact = function(e3, t2, r3, i3, o2) {
    var a2 = o2 >>> 3;
    return i3[a2] = r3, i3[a2 + 1] = r3 >>> 8, i3[a2 + 2] = 255 - i3[a2], i3[a2 + 3] = 255 - i3[a2 + 1], a2 += 4, i3.set(new Uint8Array(e3.buffer, t2, r3), a2), o2 + (r3 + 4 << 3);
  }, UZIP2.F.getTrees = function() {
    for (var e3 = UZIP2.F.U, t2 = UZIP2.F._hufTree(e3.lhst, e3.ltree, 15), r3 = UZIP2.F._hufTree(e3.dhst, e3.dtree, 15), i3 = [], o2 = UZIP2.F._lenCodes(e3.ltree, i3), a2 = [], s2 = UZIP2.F._lenCodes(e3.dtree, a2), f2 = 0; f2 < i3.length; f2 += 2)
      e3.ihst[i3[f2]]++;
    for (f2 = 0; f2 < a2.length; f2 += 2)
      e3.ihst[a2[f2]]++;
    for (var l2 = UZIP2.F._hufTree(e3.ihst, e3.itree, 7), c2 = 19; c2 > 4 && 0 == e3.itree[1 + (e3.ordr[c2 - 1] << 1)]; )
      c2--;
    return [t2, r3, l2, o2, s2, c2, i3, a2];
  }, UZIP2.F.getSecond = function(e3) {
    for (var t2 = [], r3 = 0; r3 < e3.length; r3 += 2)
      t2.push(e3[r3 + 1]);
    return t2;
  }, UZIP2.F.nonZero = function(e3) {
    for (var t2 = "", r3 = 0; r3 < e3.length; r3 += 2)
      0 != e3[r3 + 1] && (t2 += (r3 >> 1) + ",");
    return t2;
  }, UZIP2.F.contSize = function(e3, t2) {
    for (var r3 = 0, i3 = 0; i3 < t2.length; i3++)
      r3 += t2[i3] * e3[1 + (i3 << 1)];
    return r3;
  }, UZIP2.F._codeTiny = function(e3, t2, r3, i3) {
    for (var o2 = 0; o2 < e3.length; o2 += 2) {
      var a2 = e3[o2], s2 = e3[o2 + 1];
      i3 = UZIP2.F._writeLit(a2, t2, r3, i3);
      var f2 = 16 == a2 ? 2 : 17 == a2 ? 3 : 7;
      a2 > 15 && (UZIP2.F._putsE(r3, i3, s2, f2), i3 += f2);
    }
    return i3;
  }, UZIP2.F._lenCodes = function(e3, t2) {
    for (var r3 = e3.length; 2 != r3 && 0 == e3[r3 - 1]; )
      r3 -= 2;
    for (var i3 = 0; i3 < r3; i3 += 2) {
      var o2 = e3[i3 + 1], a2 = i3 + 3 < r3 ? e3[i3 + 3] : -1, s2 = i3 + 5 < r3 ? e3[i3 + 5] : -1, f2 = 0 == i3 ? -1 : e3[i3 - 1];
      if (0 == o2 && a2 == o2 && s2 == o2) {
        for (var l2 = i3 + 5; l2 + 2 < r3 && e3[l2 + 2] == o2; )
          l2 += 2;
        (c2 = Math.min(l2 + 1 - i3 >>> 1, 138)) < 11 ? t2.push(17, c2 - 3) : t2.push(18, c2 - 11), i3 += 2 * c2 - 2;
      } else if (o2 == f2 && a2 == o2 && s2 == o2) {
        for (l2 = i3 + 5; l2 + 2 < r3 && e3[l2 + 2] == o2; )
          l2 += 2;
        var c2 = Math.min(l2 + 1 - i3 >>> 1, 6);
        t2.push(16, c2 - 3), i3 += 2 * c2 - 2;
      } else
        t2.push(o2, 0);
    }
    return r3 >>> 1;
  }, UZIP2.F._hufTree = function(e3, t2, r3) {
    var i3 = [], o2 = e3.length, a2 = t2.length, s2 = 0;
    for (s2 = 0; s2 < a2; s2 += 2)
      t2[s2] = 0, t2[s2 + 1] = 0;
    for (s2 = 0; s2 < o2; s2++)
      0 != e3[s2] && i3.push({ lit: s2, f: e3[s2] });
    var f2 = i3.length, l2 = i3.slice(0);
    if (0 == f2)
      return 0;
    if (1 == f2) {
      var c2 = i3[0].lit;
      l2 = 0 == c2 ? 1 : 0;
      return t2[1 + (c2 << 1)] = 1, t2[1 + (l2 << 1)] = 1, 1;
    }
    i3.sort(function(e4, t3) {
      return e4.f - t3.f;
    });
    var u = i3[0], h = i3[1], d = 0, A = 1, g = 2;
    for (i3[0] = { lit: -1, f: u.f + h.f, l: u, r: h, d: 0 }; A != f2 - 1; )
      u = d != A && (g == f2 || i3[d].f < i3[g].f) ? i3[d++] : i3[g++], h = d != A && (g == f2 || i3[d].f < i3[g].f) ? i3[d++] : i3[g++], i3[A++] = { lit: -1, f: u.f + h.f, l: u, r: h };
    var p = UZIP2.F.setDepth(i3[A - 1], 0);
    for (p > r3 && (UZIP2.F.restrictDepth(l2, r3, p), p = r3), s2 = 0; s2 < f2; s2++)
      t2[1 + (l2[s2].lit << 1)] = l2[s2].d;
    return p;
  }, UZIP2.F.setDepth = function(e3, t2) {
    return -1 != e3.lit ? (e3.d = t2, t2) : Math.max(UZIP2.F.setDepth(e3.l, t2 + 1), UZIP2.F.setDepth(e3.r, t2 + 1));
  }, UZIP2.F.restrictDepth = function(e3, t2, r3) {
    var i3 = 0, o2 = 1 << r3 - t2, a2 = 0;
    for (e3.sort(function(e4, t3) {
      return t3.d == e4.d ? e4.f - t3.f : t3.d - e4.d;
    }), i3 = 0; i3 < e3.length && e3[i3].d > t2; i3++) {
      var s2 = e3[i3].d;
      e3[i3].d = t2, a2 += o2 - (1 << r3 - s2);
    }
    for (a2 >>>= r3 - t2; a2 > 0; ) {
      (s2 = e3[i3].d) < t2 ? (e3[i3].d++, a2 -= 1 << t2 - s2 - 1) : i3++;
    }
    for (; i3 >= 0; i3--)
      e3[i3].d == t2 && a2 < 0 && (e3[i3].d--, a2++);
    0 != a2 && console.log("debt left");
  }, UZIP2.F._goodIndex = function(e3, t2) {
    var r3 = 0;
    return t2[16 | r3] <= e3 && (r3 |= 16), t2[8 | r3] <= e3 && (r3 |= 8), t2[4 | r3] <= e3 && (r3 |= 4), t2[2 | r3] <= e3 && (r3 |= 2), t2[1 | r3] <= e3 && (r3 |= 1), r3;
  }, UZIP2.F._writeLit = function(e3, t2, r3, i3) {
    return UZIP2.F._putsF(r3, i3, t2[e3 << 1]), i3 + t2[1 + (e3 << 1)];
  }, UZIP2.F.inflate = function(e3, t2) {
    var r3 = Uint8Array;
    if (3 == e3[0] && 0 == e3[1])
      return t2 || new r3(0);
    var i3 = UZIP2.F, o2 = i3._bitsF, a2 = i3._bitsE, s2 = i3._decodeTiny, f2 = i3.makeCodes, l2 = i3.codes2map, c2 = i3._get17, u = i3.U, h = null == t2;
    h && (t2 = new r3(e3.length >>> 2 << 3));
    for (var d, A, g = 0, p = 0, m = 0, w = 0, v = 0, b = 0, y = 0, E = 0, F4 = 0; 0 == g; )
      if (g = o2(e3, F4, 1), p = o2(e3, F4 + 1, 2), F4 += 3, 0 != p) {
        if (h && (t2 = UZIP2.F._check(t2, E + (1 << 17))), 1 == p && (d = u.flmap, A = u.fdmap, b = 511, y = 31), 2 == p) {
          m = a2(e3, F4, 5) + 257, w = a2(e3, F4 + 5, 5) + 1, v = a2(e3, F4 + 10, 4) + 4, F4 += 14;
          for (var _ = 0; _ < 38; _ += 2)
            u.itree[_] = 0, u.itree[_ + 1] = 0;
          var B = 1;
          for (_ = 0; _ < v; _++) {
            var U3 = a2(e3, F4 + 3 * _, 3);
            u.itree[1 + (u.ordr[_] << 1)] = U3, U3 > B && (B = U3);
          }
          F4 += 3 * v, f2(u.itree, B), l2(u.itree, B, u.imap), d = u.lmap, A = u.dmap, F4 = s2(u.imap, (1 << B) - 1, m + w, e3, F4, u.ttree);
          var C = i3._copyOut(u.ttree, 0, m, u.ltree);
          b = (1 << C) - 1;
          var I = i3._copyOut(u.ttree, m, w, u.dtree);
          y = (1 << I) - 1, f2(u.ltree, C), l2(u.ltree, C, d), f2(u.dtree, I), l2(u.dtree, I, A);
        }
        for (; ; ) {
          var Q = d[c2(e3, F4) & b];
          F4 += 15 & Q;
          var M = Q >>> 4;
          if (M >>> 8 == 0)
            t2[E++] = M;
          else {
            if (256 == M)
              break;
            var x = E + M - 254;
            if (M > 264) {
              var S = u.ldef[M - 257];
              x = E + (S >>> 3) + a2(e3, F4, 7 & S), F4 += 7 & S;
            }
            var R4 = A[c2(e3, F4) & y];
            F4 += 15 & R4;
            var T = R4 >>> 4, O = u.ddef[T], P = (O >>> 4) + o2(e3, F4, 15 & O);
            for (F4 += 15 & O, h && (t2 = UZIP2.F._check(t2, E + (1 << 17))); E < x; )
              t2[E] = t2[E++ - P], t2[E] = t2[E++ - P], t2[E] = t2[E++ - P], t2[E] = t2[E++ - P];
            E = x;
          }
        }
      } else {
        0 != (7 & F4) && (F4 += 8 - (7 & F4));
        var H = 4 + (F4 >>> 3), L = e3[H - 4] | e3[H - 3] << 8;
        h && (t2 = UZIP2.F._check(t2, E + L)), t2.set(new r3(e3.buffer, e3.byteOffset + H, L), E), F4 = H + L << 3, E += L;
      }
    return t2.length == E ? t2 : t2.slice(0, E);
  }, UZIP2.F._check = function(e3, t2) {
    var r3 = e3.length;
    if (t2 <= r3)
      return e3;
    var i3 = new Uint8Array(Math.max(r3 << 1, t2));
    return i3.set(e3, 0), i3;
  }, UZIP2.F._decodeTiny = function(e3, t2, r3, i3, o2, a2) {
    for (var s2 = UZIP2.F._bitsE, f2 = UZIP2.F._get17, l2 = 0; l2 < r3; ) {
      var c2 = e3[f2(i3, o2) & t2];
      o2 += 15 & c2;
      var u = c2 >>> 4;
      if (u <= 15)
        a2[l2] = u, l2++;
      else {
        var h = 0, d = 0;
        16 == u ? (d = 3 + s2(i3, o2, 2), o2 += 2, h = a2[l2 - 1]) : 17 == u ? (d = 3 + s2(i3, o2, 3), o2 += 3) : 18 == u && (d = 11 + s2(i3, o2, 7), o2 += 7);
        for (var A = l2 + d; l2 < A; )
          a2[l2] = h, l2++;
      }
    }
    return o2;
  }, UZIP2.F._copyOut = function(e3, t2, r3, i3) {
    for (var o2 = 0, a2 = 0, s2 = i3.length >>> 1; a2 < r3; ) {
      var f2 = e3[a2 + t2];
      i3[a2 << 1] = 0, i3[1 + (a2 << 1)] = f2, f2 > o2 && (o2 = f2), a2++;
    }
    for (; a2 < s2; )
      i3[a2 << 1] = 0, i3[1 + (a2 << 1)] = 0, a2++;
    return o2;
  }, UZIP2.F.makeCodes = function(e3, t2) {
    for (var r3, i3, o2, a2, s2 = UZIP2.F.U, f2 = e3.length, l2 = s2.bl_count, c2 = 0; c2 <= t2; c2++)
      l2[c2] = 0;
    for (c2 = 1; c2 < f2; c2 += 2)
      l2[e3[c2]]++;
    var u = s2.next_code;
    for (r3 = 0, l2[0] = 0, i3 = 1; i3 <= t2; i3++)
      r3 = r3 + l2[i3 - 1] << 1, u[i3] = r3;
    for (o2 = 0; o2 < f2; o2 += 2)
      0 != (a2 = e3[o2 + 1]) && (e3[o2] = u[a2], u[a2]++);
  }, UZIP2.F.codes2map = function(e3, t2, r3) {
    for (var i3 = e3.length, o2 = UZIP2.F.U.rev15, a2 = 0; a2 < i3; a2 += 2)
      if (0 != e3[a2 + 1])
        for (var s2 = a2 >> 1, f2 = e3[a2 + 1], l2 = s2 << 4 | f2, c2 = t2 - f2, u = e3[a2] << c2, h = u + (1 << c2); u != h; ) {
          r3[o2[u] >>> 15 - t2] = l2, u++;
        }
  }, UZIP2.F.revCodes = function(e3, t2) {
    for (var r3 = UZIP2.F.U.rev15, i3 = 15 - t2, o2 = 0; o2 < e3.length; o2 += 2) {
      var a2 = e3[o2] << t2 - e3[o2 + 1];
      e3[o2] = r3[a2] >>> i3;
    }
  }, UZIP2.F._putsE = function(e3, t2, r3) {
    r3 <<= 7 & t2;
    var i3 = t2 >>> 3;
    e3[i3] |= r3, e3[i3 + 1] |= r3 >>> 8;
  }, UZIP2.F._putsF = function(e3, t2, r3) {
    r3 <<= 7 & t2;
    var i3 = t2 >>> 3;
    e3[i3] |= r3, e3[i3 + 1] |= r3 >>> 8, e3[i3 + 2] |= r3 >>> 16;
  }, UZIP2.F._bitsE = function(e3, t2, r3) {
    return (e3[t2 >>> 3] | e3[1 + (t2 >>> 3)] << 8) >>> (7 & t2) & (1 << r3) - 1;
  }, UZIP2.F._bitsF = function(e3, t2, r3) {
    return (e3[t2 >>> 3] | e3[1 + (t2 >>> 3)] << 8 | e3[2 + (t2 >>> 3)] << 16) >>> (7 & t2) & (1 << r3) - 1;
  }, UZIP2.F._get17 = function(e3, t2) {
    return (e3[t2 >>> 3] | e3[1 + (t2 >>> 3)] << 8 | e3[2 + (t2 >>> 3)] << 16) >>> (7 & t2);
  }, UZIP2.F._get25 = function(e3, t2) {
    return (e3[t2 >>> 3] | e3[1 + (t2 >>> 3)] << 8 | e3[2 + (t2 >>> 3)] << 16 | e3[3 + (t2 >>> 3)] << 24) >>> (7 & t2);
  }, UZIP2.F.U = (r2 = Uint16Array, i2 = Uint32Array, { next_code: new r2(16), bl_count: new r2(16), ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], ldef: new r2(32), df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], ddef: new i2(32), flmap: new r2(512), fltree: [], fdmap: new r2(32), fdtree: [], lmap: new r2(32768), ltree: [], ttree: [], dmap: new r2(32768), dtree: [], imap: new r2(512), itree: [], rev15: new r2(32768), lhst: new i2(286), dhst: new i2(30), ihst: new i2(19), lits: new i2(15e3), strt: new r2(65536), prev: new r2(32768) }), function() {
    for (var e3 = UZIP2.F.U, t2 = 0; t2 < 32768; t2++) {
      var r3 = t2;
      r3 = (4278255360 & (r3 = (4042322160 & (r3 = (3435973836 & (r3 = (2863311530 & r3) >>> 1 | (1431655765 & r3) << 1)) >>> 2 | (858993459 & r3) << 2)) >>> 4 | (252645135 & r3) << 4)) >>> 8 | (16711935 & r3) << 8, e3.rev15[t2] = (r3 >>> 16 | r3 << 16) >>> 17;
    }
    function pushV(e4, t3, r4) {
      for (; 0 != t3--; )
        e4.push(0, r4);
    }
    for (t2 = 0; t2 < 32; t2++)
      e3.ldef[t2] = e3.of0[t2] << 3 | e3.exb[t2], e3.ddef[t2] = e3.df0[t2] << 4 | e3.dxb[t2];
    pushV(e3.fltree, 144, 8), pushV(e3.fltree, 112, 9), pushV(e3.fltree, 24, 7), pushV(e3.fltree, 8, 8), UZIP2.F.makeCodes(e3.fltree, 9), UZIP2.F.codes2map(e3.fltree, 9, e3.flmap), UZIP2.F.revCodes(e3.fltree, 9), pushV(e3.fdtree, 32, 5), UZIP2.F.makeCodes(e3.fdtree, 5), UZIP2.F.codes2map(e3.fdtree, 5, e3.fdmap), UZIP2.F.revCodes(e3.fdtree, 5), pushV(e3.itree, 19, 0), pushV(e3.ltree, 286, 0), pushV(e3.dtree, 30, 0), pushV(e3.ttree, 320, 0);
  }();
}();
var UZIP = _mergeNamespaces({ __proto__: null, default: e }, [e]);
var UPNG = function() {
  var e2 = { nextZero(e3, t3) {
    for (; 0 != e3[t3]; )
      t3++;
    return t3;
  }, readUshort: (e3, t3) => e3[t3] << 8 | e3[t3 + 1], writeUshort(e3, t3, r2) {
    e3[t3] = r2 >> 8 & 255, e3[t3 + 1] = 255 & r2;
  }, readUint: (e3, t3) => 16777216 * e3[t3] + (e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | e3[t3 + 3]), writeUint(e3, t3, r2) {
    e3[t3] = r2 >> 24 & 255, e3[t3 + 1] = r2 >> 16 & 255, e3[t3 + 2] = r2 >> 8 & 255, e3[t3 + 3] = 255 & r2;
  }, readASCII(e3, t3, r2) {
    let i2 = "";
    for (let o2 = 0; o2 < r2; o2++)
      i2 += String.fromCharCode(e3[t3 + o2]);
    return i2;
  }, writeASCII(e3, t3, r2) {
    for (let i2 = 0; i2 < r2.length; i2++)
      e3[t3 + i2] = r2.charCodeAt(i2);
  }, readBytes(e3, t3, r2) {
    const i2 = [];
    for (let o2 = 0; o2 < r2; o2++)
      i2.push(e3[t3 + o2]);
    return i2;
  }, pad: (e3) => e3.length < 2 ? `0${e3}` : e3, readUTF8(t3, r2, i2) {
    let o2, a2 = "";
    for (let o3 = 0; o3 < i2; o3++)
      a2 += `%${e2.pad(t3[r2 + o3].toString(16))}`;
    try {
      o2 = decodeURIComponent(a2);
    } catch (o3) {
      return e2.readASCII(t3, r2, i2);
    }
    return o2;
  } };
  function decodeImage(t3, r2, i2, o2) {
    const a2 = r2 * i2, s2 = _getBPP(o2), f2 = Math.ceil(r2 * s2 / 8), l2 = new Uint8Array(4 * a2), c2 = new Uint32Array(l2.buffer), { ctype: u } = o2, { depth: h } = o2, d = e2.readUshort;
    if (6 == u) {
      const e3 = a2 << 2;
      if (8 == h)
        for (var A = 0; A < e3; A += 4)
          l2[A] = t3[A], l2[A + 1] = t3[A + 1], l2[A + 2] = t3[A + 2], l2[A + 3] = t3[A + 3];
      if (16 == h)
        for (A = 0; A < e3; A++)
          l2[A] = t3[A << 1];
    } else if (2 == u) {
      const e3 = o2.tabs.tRNS;
      if (null == e3) {
        if (8 == h)
          for (A = 0; A < a2; A++) {
            var g = 3 * A;
            c2[A] = 255 << 24 | t3[g + 2] << 16 | t3[g + 1] << 8 | t3[g];
          }
        if (16 == h)
          for (A = 0; A < a2; A++) {
            g = 6 * A;
            c2[A] = 255 << 24 | t3[g + 4] << 16 | t3[g + 2] << 8 | t3[g];
          }
      } else {
        var p = e3[0];
        const r3 = e3[1], i3 = e3[2];
        if (8 == h)
          for (A = 0; A < a2; A++) {
            var m = A << 2;
            g = 3 * A;
            c2[A] = 255 << 24 | t3[g + 2] << 16 | t3[g + 1] << 8 | t3[g], t3[g] == p && t3[g + 1] == r3 && t3[g + 2] == i3 && (l2[m + 3] = 0);
          }
        if (16 == h)
          for (A = 0; A < a2; A++) {
            m = A << 2, g = 6 * A;
            c2[A] = 255 << 24 | t3[g + 4] << 16 | t3[g + 2] << 8 | t3[g], d(t3, g) == p && d(t3, g + 2) == r3 && d(t3, g + 4) == i3 && (l2[m + 3] = 0);
          }
      }
    } else if (3 == u) {
      const e3 = o2.tabs.PLTE, s3 = o2.tabs.tRNS, c3 = s3 ? s3.length : 0;
      if (1 == h)
        for (var w = 0; w < i2; w++) {
          var v = w * f2, b = w * r2;
          for (A = 0; A < r2; A++) {
            m = b + A << 2;
            var y = 3 * (E = t3[v + (A >> 3)] >> 7 - ((7 & A) << 0) & 1);
            l2[m] = e3[y], l2[m + 1] = e3[y + 1], l2[m + 2] = e3[y + 2], l2[m + 3] = E < c3 ? s3[E] : 255;
          }
        }
      if (2 == h)
        for (w = 0; w < i2; w++)
          for (v = w * f2, b = w * r2, A = 0; A < r2; A++) {
            m = b + A << 2, y = 3 * (E = t3[v + (A >> 2)] >> 6 - ((3 & A) << 1) & 3);
            l2[m] = e3[y], l2[m + 1] = e3[y + 1], l2[m + 2] = e3[y + 2], l2[m + 3] = E < c3 ? s3[E] : 255;
          }
      if (4 == h)
        for (w = 0; w < i2; w++)
          for (v = w * f2, b = w * r2, A = 0; A < r2; A++) {
            m = b + A << 2, y = 3 * (E = t3[v + (A >> 1)] >> 4 - ((1 & A) << 2) & 15);
            l2[m] = e3[y], l2[m + 1] = e3[y + 1], l2[m + 2] = e3[y + 2], l2[m + 3] = E < c3 ? s3[E] : 255;
          }
      if (8 == h)
        for (A = 0; A < a2; A++) {
          var E;
          m = A << 2, y = 3 * (E = t3[A]);
          l2[m] = e3[y], l2[m + 1] = e3[y + 1], l2[m + 2] = e3[y + 2], l2[m + 3] = E < c3 ? s3[E] : 255;
        }
    } else if (4 == u) {
      if (8 == h)
        for (A = 0; A < a2; A++) {
          m = A << 2;
          var F4 = t3[_ = A << 1];
          l2[m] = F4, l2[m + 1] = F4, l2[m + 2] = F4, l2[m + 3] = t3[_ + 1];
        }
      if (16 == h)
        for (A = 0; A < a2; A++) {
          var _;
          m = A << 2, F4 = t3[_ = A << 2];
          l2[m] = F4, l2[m + 1] = F4, l2[m + 2] = F4, l2[m + 3] = t3[_ + 2];
        }
    } else if (0 == u)
      for (p = o2.tabs.tRNS ? o2.tabs.tRNS : -1, w = 0; w < i2; w++) {
        const e3 = w * f2, i3 = w * r2;
        if (1 == h)
          for (var B = 0; B < r2; B++) {
            var U3 = (F4 = 255 * (t3[e3 + (B >>> 3)] >>> 7 - (7 & B) & 1)) == 255 * p ? 0 : 255;
            c2[i3 + B] = U3 << 24 | F4 << 16 | F4 << 8 | F4;
          }
        else if (2 == h)
          for (B = 0; B < r2; B++) {
            U3 = (F4 = 85 * (t3[e3 + (B >>> 2)] >>> 6 - ((3 & B) << 1) & 3)) == 85 * p ? 0 : 255;
            c2[i3 + B] = U3 << 24 | F4 << 16 | F4 << 8 | F4;
          }
        else if (4 == h)
          for (B = 0; B < r2; B++) {
            U3 = (F4 = 17 * (t3[e3 + (B >>> 1)] >>> 4 - ((1 & B) << 2) & 15)) == 17 * p ? 0 : 255;
            c2[i3 + B] = U3 << 24 | F4 << 16 | F4 << 8 | F4;
          }
        else if (8 == h)
          for (B = 0; B < r2; B++) {
            U3 = (F4 = t3[e3 + B]) == p ? 0 : 255;
            c2[i3 + B] = U3 << 24 | F4 << 16 | F4 << 8 | F4;
          }
        else if (16 == h)
          for (B = 0; B < r2; B++) {
            F4 = t3[e3 + (B << 1)], U3 = d(t3, e3 + (B << 1)) == p ? 0 : 255;
            c2[i3 + B] = U3 << 24 | F4 << 16 | F4 << 8 | F4;
          }
      }
    return l2;
  }
  function _decompress(e3, r2, i2, o2) {
    const a2 = _getBPP(e3), s2 = Math.ceil(i2 * a2 / 8), f2 = new Uint8Array((s2 + 1 + e3.interlace) * o2);
    return r2 = e3.tabs.CgBI ? t2(r2, f2) : _inflate(r2, f2), 0 == e3.interlace ? r2 = _filterZero(r2, e3, 0, i2, o2) : 1 == e3.interlace && (r2 = function _readInterlace(e4, t3) {
      const r3 = t3.width, i3 = t3.height, o3 = _getBPP(t3), a3 = o3 >> 3, s3 = Math.ceil(r3 * o3 / 8), f3 = new Uint8Array(i3 * s3);
      let l2 = 0;
      const c2 = [0, 0, 4, 0, 2, 0, 1], u = [0, 4, 0, 2, 0, 1, 0], h = [8, 8, 8, 4, 4, 2, 2], d = [8, 8, 4, 4, 2, 2, 1];
      let A = 0;
      for (; A < 7; ) {
        const p = h[A], m = d[A];
        let w = 0, v = 0, b = c2[A];
        for (; b < i3; )
          b += p, v++;
        let y = u[A];
        for (; y < r3; )
          y += m, w++;
        const E = Math.ceil(w * o3 / 8);
        _filterZero(e4, t3, l2, w, v);
        let F4 = 0, _ = c2[A];
        for (; _ < i3; ) {
          let t4 = u[A], i4 = l2 + F4 * E << 3;
          for (; t4 < r3; ) {
            var g;
            if (1 == o3)
              g = (g = e4[i4 >> 3]) >> 7 - (7 & i4) & 1, f3[_ * s3 + (t4 >> 3)] |= g << 7 - ((7 & t4) << 0);
            if (2 == o3)
              g = (g = e4[i4 >> 3]) >> 6 - (7 & i4) & 3, f3[_ * s3 + (t4 >> 2)] |= g << 6 - ((3 & t4) << 1);
            if (4 == o3)
              g = (g = e4[i4 >> 3]) >> 4 - (7 & i4) & 15, f3[_ * s3 + (t4 >> 1)] |= g << 4 - ((1 & t4) << 2);
            if (o3 >= 8) {
              const r4 = _ * s3 + t4 * a3;
              for (let t5 = 0; t5 < a3; t5++)
                f3[r4 + t5] = e4[(i4 >> 3) + t5];
            }
            i4 += o3, t4 += m;
          }
          F4++, _ += p;
        }
        w * v != 0 && (l2 += v * (1 + E)), A += 1;
      }
      return f3;
    }(r2, e3)), r2;
  }
  function _inflate(e3, r2) {
    return t2(new Uint8Array(e3.buffer, 2, e3.length - 6), r2);
  }
  var t2 = function() {
    const e3 = { H: {} };
    return e3.H.N = function(t3, r2) {
      const i2 = Uint8Array;
      let o2, a2, s2 = 0, f2 = 0, l2 = 0, c2 = 0, u = 0, h = 0, d = 0, A = 0, g = 0;
      if (3 == t3[0] && 0 == t3[1])
        return r2 || new i2(0);
      const p = e3.H, m = p.b, w = p.e, v = p.R, b = p.n, y = p.A, E = p.Z, F4 = p.m, _ = null == r2;
      for (_ && (r2 = new i2(t3.length >>> 2 << 5)); 0 == s2; )
        if (s2 = m(t3, g, 1), f2 = m(t3, g + 1, 2), g += 3, 0 != f2) {
          if (_ && (r2 = e3.H.W(r2, A + (1 << 17))), 1 == f2 && (o2 = F4.J, a2 = F4.h, h = 511, d = 31), 2 == f2) {
            l2 = w(t3, g, 5) + 257, c2 = w(t3, g + 5, 5) + 1, u = w(t3, g + 10, 4) + 4, g += 14;
            let e4 = 1;
            for (var B = 0; B < 38; B += 2)
              F4.Q[B] = 0, F4.Q[B + 1] = 0;
            for (B = 0; B < u; B++) {
              const r4 = w(t3, g + 3 * B, 3);
              F4.Q[1 + (F4.X[B] << 1)] = r4, r4 > e4 && (e4 = r4);
            }
            g += 3 * u, b(F4.Q, e4), y(F4.Q, e4, F4.u), o2 = F4.w, a2 = F4.d, g = v(F4.u, (1 << e4) - 1, l2 + c2, t3, g, F4.v);
            const r3 = p.V(F4.v, 0, l2, F4.C);
            h = (1 << r3) - 1;
            const i3 = p.V(F4.v, l2, c2, F4.D);
            d = (1 << i3) - 1, b(F4.C, r3), y(F4.C, r3, o2), b(F4.D, i3), y(F4.D, i3, a2);
          }
          for (; ; ) {
            const e4 = o2[E(t3, g) & h];
            g += 15 & e4;
            const i3 = e4 >>> 4;
            if (i3 >>> 8 == 0)
              r2[A++] = i3;
            else {
              if (256 == i3)
                break;
              {
                let e5 = A + i3 - 254;
                if (i3 > 264) {
                  const r3 = F4.q[i3 - 257];
                  e5 = A + (r3 >>> 3) + w(t3, g, 7 & r3), g += 7 & r3;
                }
                const o3 = a2[E(t3, g) & d];
                g += 15 & o3;
                const s3 = o3 >>> 4, f3 = F4.c[s3], l3 = (f3 >>> 4) + m(t3, g, 15 & f3);
                for (g += 15 & f3; A < e5; )
                  r2[A] = r2[A++ - l3], r2[A] = r2[A++ - l3], r2[A] = r2[A++ - l3], r2[A] = r2[A++ - l3];
                A = e5;
              }
            }
          }
        } else {
          0 != (7 & g) && (g += 8 - (7 & g));
          const o3 = 4 + (g >>> 3), a3 = t3[o3 - 4] | t3[o3 - 3] << 8;
          _ && (r2 = e3.H.W(r2, A + a3)), r2.set(new i2(t3.buffer, t3.byteOffset + o3, a3), A), g = o3 + a3 << 3, A += a3;
        }
      return r2.length == A ? r2 : r2.slice(0, A);
    }, e3.H.W = function(e4, t3) {
      const r2 = e4.length;
      if (t3 <= r2)
        return e4;
      const i2 = new Uint8Array(r2 << 1);
      return i2.set(e4, 0), i2;
    }, e3.H.R = function(t3, r2, i2, o2, a2, s2) {
      const f2 = e3.H.e, l2 = e3.H.Z;
      let c2 = 0;
      for (; c2 < i2; ) {
        const e4 = t3[l2(o2, a2) & r2];
        a2 += 15 & e4;
        const i3 = e4 >>> 4;
        if (i3 <= 15)
          s2[c2] = i3, c2++;
        else {
          let e5 = 0, t4 = 0;
          16 == i3 ? (t4 = 3 + f2(o2, a2, 2), a2 += 2, e5 = s2[c2 - 1]) : 17 == i3 ? (t4 = 3 + f2(o2, a2, 3), a2 += 3) : 18 == i3 && (t4 = 11 + f2(o2, a2, 7), a2 += 7);
          const r3 = c2 + t4;
          for (; c2 < r3; )
            s2[c2] = e5, c2++;
        }
      }
      return a2;
    }, e3.H.V = function(e4, t3, r2, i2) {
      let o2 = 0, a2 = 0;
      const s2 = i2.length >>> 1;
      for (; a2 < r2; ) {
        const r3 = e4[a2 + t3];
        i2[a2 << 1] = 0, i2[1 + (a2 << 1)] = r3, r3 > o2 && (o2 = r3), a2++;
      }
      for (; a2 < s2; )
        i2[a2 << 1] = 0, i2[1 + (a2 << 1)] = 0, a2++;
      return o2;
    }, e3.H.n = function(t3, r2) {
      const i2 = e3.H.m, o2 = t3.length;
      let a2, s2, f2;
      let l2;
      const c2 = i2.j;
      for (var u = 0; u <= r2; u++)
        c2[u] = 0;
      for (u = 1; u < o2; u += 2)
        c2[t3[u]]++;
      const h = i2.K;
      for (a2 = 0, c2[0] = 0, s2 = 1; s2 <= r2; s2++)
        a2 = a2 + c2[s2 - 1] << 1, h[s2] = a2;
      for (f2 = 0; f2 < o2; f2 += 2)
        l2 = t3[f2 + 1], 0 != l2 && (t3[f2] = h[l2], h[l2]++);
    }, e3.H.A = function(t3, r2, i2) {
      const o2 = t3.length, a2 = e3.H.m.r;
      for (let e4 = 0; e4 < o2; e4 += 2)
        if (0 != t3[e4 + 1]) {
          const o3 = e4 >> 1, s2 = t3[e4 + 1], f2 = o3 << 4 | s2, l2 = r2 - s2;
          let c2 = t3[e4] << l2;
          const u = c2 + (1 << l2);
          for (; c2 != u; ) {
            i2[a2[c2] >>> 15 - r2] = f2, c2++;
          }
        }
    }, e3.H.l = function(t3, r2) {
      const i2 = e3.H.m.r, o2 = 15 - r2;
      for (let e4 = 0; e4 < t3.length; e4 += 2) {
        const a2 = t3[e4] << r2 - t3[e4 + 1];
        t3[e4] = i2[a2] >>> o2;
      }
    }, e3.H.M = function(e4, t3, r2) {
      r2 <<= 7 & t3;
      const i2 = t3 >>> 3;
      e4[i2] |= r2, e4[i2 + 1] |= r2 >>> 8;
    }, e3.H.I = function(e4, t3, r2) {
      r2 <<= 7 & t3;
      const i2 = t3 >>> 3;
      e4[i2] |= r2, e4[i2 + 1] |= r2 >>> 8, e4[i2 + 2] |= r2 >>> 16;
    }, e3.H.e = function(e4, t3, r2) {
      return (e4[t3 >>> 3] | e4[1 + (t3 >>> 3)] << 8) >>> (7 & t3) & (1 << r2) - 1;
    }, e3.H.b = function(e4, t3, r2) {
      return (e4[t3 >>> 3] | e4[1 + (t3 >>> 3)] << 8 | e4[2 + (t3 >>> 3)] << 16) >>> (7 & t3) & (1 << r2) - 1;
    }, e3.H.Z = function(e4, t3) {
      return (e4[t3 >>> 3] | e4[1 + (t3 >>> 3)] << 8 | e4[2 + (t3 >>> 3)] << 16) >>> (7 & t3);
    }, e3.H.i = function(e4, t3) {
      return (e4[t3 >>> 3] | e4[1 + (t3 >>> 3)] << 8 | e4[2 + (t3 >>> 3)] << 16 | e4[3 + (t3 >>> 3)] << 24) >>> (7 & t3);
    }, e3.H.m = function() {
      const e4 = Uint16Array, t3 = Uint32Array;
      return { K: new e4(16), j: new e4(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new e4(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new t3(32), J: new e4(512), _: [], h: new e4(32), $: [], w: new e4(32768), C: [], v: [], d: new e4(32768), D: [], u: new e4(512), Q: [], r: new e4(32768), s: new t3(286), Y: new t3(30), a: new t3(19), t: new t3(15e3), k: new e4(65536), g: new e4(32768) };
    }(), function() {
      const t3 = e3.H.m;
      for (var r2 = 0; r2 < 32768; r2++) {
        let e4 = r2;
        e4 = (2863311530 & e4) >>> 1 | (1431655765 & e4) << 1, e4 = (3435973836 & e4) >>> 2 | (858993459 & e4) << 2, e4 = (4042322160 & e4) >>> 4 | (252645135 & e4) << 4, e4 = (4278255360 & e4) >>> 8 | (16711935 & e4) << 8, t3.r[r2] = (e4 >>> 16 | e4 << 16) >>> 17;
      }
      function n(e4, t4, r3) {
        for (; 0 != t4--; )
          e4.push(0, r3);
      }
      for (r2 = 0; r2 < 32; r2++)
        t3.q[r2] = t3.S[r2] << 3 | t3.T[r2], t3.c[r2] = t3.p[r2] << 4 | t3.z[r2];
      n(t3._, 144, 8), n(t3._, 112, 9), n(t3._, 24, 7), n(t3._, 8, 8), e3.H.n(t3._, 9), e3.H.A(t3._, 9, t3.J), e3.H.l(t3._, 9), n(t3.$, 32, 5), e3.H.n(t3.$, 5), e3.H.A(t3.$, 5, t3.h), e3.H.l(t3.$, 5), n(t3.Q, 19, 0), n(t3.C, 286, 0), n(t3.D, 30, 0), n(t3.v, 320, 0);
    }(), e3.H.N;
  }();
  function _getBPP(e3) {
    return [1, null, 3, 1, 2, null, 4][e3.ctype] * e3.depth;
  }
  function _filterZero(e3, t3, r2, i2, o2) {
    let a2 = _getBPP(t3);
    const s2 = Math.ceil(i2 * a2 / 8);
    let f2, l2;
    a2 = Math.ceil(a2 / 8);
    let c2 = e3[r2], u = 0;
    if (c2 > 1 && (e3[r2] = [0, 0, 1][c2 - 2]), 3 == c2)
      for (u = a2; u < s2; u++)
        e3[u + 1] = e3[u + 1] + (e3[u + 1 - a2] >>> 1) & 255;
    for (let t4 = 0; t4 < o2; t4++)
      if (f2 = r2 + t4 * s2, l2 = f2 + t4 + 1, c2 = e3[l2 - 1], u = 0, 0 == c2)
        for (; u < s2; u++)
          e3[f2 + u] = e3[l2 + u];
      else if (1 == c2) {
        for (; u < a2; u++)
          e3[f2 + u] = e3[l2 + u];
        for (; u < s2; u++)
          e3[f2 + u] = e3[l2 + u] + e3[f2 + u - a2];
      } else if (2 == c2)
        for (; u < s2; u++)
          e3[f2 + u] = e3[l2 + u] + e3[f2 + u - s2];
      else if (3 == c2) {
        for (; u < a2; u++)
          e3[f2 + u] = e3[l2 + u] + (e3[f2 + u - s2] >>> 1);
        for (; u < s2; u++)
          e3[f2 + u] = e3[l2 + u] + (e3[f2 + u - s2] + e3[f2 + u - a2] >>> 1);
      } else {
        for (; u < a2; u++)
          e3[f2 + u] = e3[l2 + u] + _paeth(0, e3[f2 + u - s2], 0);
        for (; u < s2; u++)
          e3[f2 + u] = e3[l2 + u] + _paeth(e3[f2 + u - a2], e3[f2 + u - s2], e3[f2 + u - a2 - s2]);
      }
    return e3;
  }
  function _paeth(e3, t3, r2) {
    const i2 = e3 + t3 - r2, o2 = i2 - e3, a2 = i2 - t3, s2 = i2 - r2;
    return o2 * o2 <= a2 * a2 && o2 * o2 <= s2 * s2 ? e3 : a2 * a2 <= s2 * s2 ? t3 : r2;
  }
  function _IHDR(t3, r2, i2) {
    i2.width = e2.readUint(t3, r2), r2 += 4, i2.height = e2.readUint(t3, r2), r2 += 4, i2.depth = t3[r2], r2++, i2.ctype = t3[r2], r2++, i2.compress = t3[r2], r2++, i2.filter = t3[r2], r2++, i2.interlace = t3[r2], r2++;
  }
  function _copyTile(e3, t3, r2, i2, o2, a2, s2, f2, l2) {
    const c2 = Math.min(t3, o2), u = Math.min(r2, a2);
    let h = 0, d = 0;
    for (let r3 = 0; r3 < u; r3++)
      for (let a3 = 0; a3 < c2; a3++)
        if (s2 >= 0 && f2 >= 0 ? (h = r3 * t3 + a3 << 2, d = (f2 + r3) * o2 + s2 + a3 << 2) : (h = (-f2 + r3) * t3 - s2 + a3 << 2, d = r3 * o2 + a3 << 2), 0 == l2)
          i2[d] = e3[h], i2[d + 1] = e3[h + 1], i2[d + 2] = e3[h + 2], i2[d + 3] = e3[h + 3];
        else if (1 == l2) {
          var A = e3[h + 3] * (1 / 255), g = e3[h] * A, p = e3[h + 1] * A, m = e3[h + 2] * A, w = i2[d + 3] * (1 / 255), v = i2[d] * w, b = i2[d + 1] * w, y = i2[d + 2] * w;
          const t4 = 1 - A, r4 = A + w * t4, o3 = 0 == r4 ? 0 : 1 / r4;
          i2[d + 3] = 255 * r4, i2[d + 0] = (g + v * t4) * o3, i2[d + 1] = (p + b * t4) * o3, i2[d + 2] = (m + y * t4) * o3;
        } else if (2 == l2) {
          A = e3[h + 3], g = e3[h], p = e3[h + 1], m = e3[h + 2], w = i2[d + 3], v = i2[d], b = i2[d + 1], y = i2[d + 2];
          A == w && g == v && p == b && m == y ? (i2[d] = 0, i2[d + 1] = 0, i2[d + 2] = 0, i2[d + 3] = 0) : (i2[d] = g, i2[d + 1] = p, i2[d + 2] = m, i2[d + 3] = A);
        } else if (3 == l2) {
          A = e3[h + 3], g = e3[h], p = e3[h + 1], m = e3[h + 2], w = i2[d + 3], v = i2[d], b = i2[d + 1], y = i2[d + 2];
          if (A == w && g == v && p == b && m == y)
            continue;
          if (A < 220 && w > 20)
            return false;
        }
    return true;
  }
  return { decode: function decode4(r2) {
    const i2 = new Uint8Array(r2);
    let o2 = 8;
    const a2 = e2, s2 = a2.readUshort, f2 = a2.readUint, l2 = { tabs: {}, frames: [] }, c2 = new Uint8Array(i2.length);
    let u, h = 0, d = 0;
    const A = [137, 80, 78, 71, 13, 10, 26, 10];
    for (var g = 0; g < 8; g++)
      if (i2[g] != A[g])
        throw "The input is not a PNG file!";
    for (; o2 < i2.length; ) {
      const e3 = a2.readUint(i2, o2);
      o2 += 4;
      const r3 = a2.readASCII(i2, o2, 4);
      if (o2 += 4, "IHDR" == r3)
        _IHDR(i2, o2, l2);
      else if ("iCCP" == r3) {
        for (var p = o2; 0 != i2[p]; )
          p++;
        a2.readASCII(i2, o2, p - o2), i2[p + 1];
        const s3 = i2.slice(p + 2, o2 + e3);
        let f3 = null;
        try {
          f3 = _inflate(s3);
        } catch (e4) {
          f3 = t2(s3);
        }
        l2.tabs[r3] = f3;
      } else if ("CgBI" == r3)
        l2.tabs[r3] = i2.slice(o2, o2 + 4);
      else if ("IDAT" == r3) {
        for (g = 0; g < e3; g++)
          c2[h + g] = i2[o2 + g];
        h += e3;
      } else if ("acTL" == r3)
        l2.tabs[r3] = { num_frames: f2(i2, o2), num_plays: f2(i2, o2 + 4) }, u = new Uint8Array(i2.length);
      else if ("fcTL" == r3) {
        if (0 != d)
          (E = l2.frames[l2.frames.length - 1]).data = _decompress(l2, u.slice(0, d), E.rect.width, E.rect.height), d = 0;
        const e4 = { x: f2(i2, o2 + 12), y: f2(i2, o2 + 16), width: f2(i2, o2 + 4), height: f2(i2, o2 + 8) };
        let t3 = s2(i2, o2 + 22);
        t3 = s2(i2, o2 + 20) / (0 == t3 ? 100 : t3);
        const r4 = { rect: e4, delay: Math.round(1e3 * t3), dispose: i2[o2 + 24], blend: i2[o2 + 25] };
        l2.frames.push(r4);
      } else if ("fdAT" == r3) {
        for (g = 0; g < e3 - 4; g++)
          u[d + g] = i2[o2 + g + 4];
        d += e3 - 4;
      } else if ("pHYs" == r3)
        l2.tabs[r3] = [a2.readUint(i2, o2), a2.readUint(i2, o2 + 4), i2[o2 + 8]];
      else if ("cHRM" == r3) {
        l2.tabs[r3] = [];
        for (g = 0; g < 8; g++)
          l2.tabs[r3].push(a2.readUint(i2, o2 + 4 * g));
      } else if ("tEXt" == r3 || "zTXt" == r3) {
        null == l2.tabs[r3] && (l2.tabs[r3] = {});
        var m = a2.nextZero(i2, o2), w = a2.readASCII(i2, o2, m - o2), v = o2 + e3 - m - 1;
        if ("tEXt" == r3)
          y = a2.readASCII(i2, m + 1, v);
        else {
          var b = _inflate(i2.slice(m + 2, m + 2 + v));
          y = a2.readUTF8(b, 0, b.length);
        }
        l2.tabs[r3][w] = y;
      } else if ("iTXt" == r3) {
        null == l2.tabs[r3] && (l2.tabs[r3] = {});
        m = 0, p = o2;
        m = a2.nextZero(i2, p);
        w = a2.readASCII(i2, p, m - p);
        const t3 = i2[p = m + 1];
        var y;
        i2[p + 1], p += 2, m = a2.nextZero(i2, p), a2.readASCII(i2, p, m - p), p = m + 1, m = a2.nextZero(i2, p), a2.readUTF8(i2, p, m - p);
        v = e3 - ((p = m + 1) - o2);
        if (0 == t3)
          y = a2.readUTF8(i2, p, v);
        else {
          b = _inflate(i2.slice(p, p + v));
          y = a2.readUTF8(b, 0, b.length);
        }
        l2.tabs[r3][w] = y;
      } else if ("PLTE" == r3)
        l2.tabs[r3] = a2.readBytes(i2, o2, e3);
      else if ("hIST" == r3) {
        const e4 = l2.tabs.PLTE.length / 3;
        l2.tabs[r3] = [];
        for (g = 0; g < e4; g++)
          l2.tabs[r3].push(s2(i2, o2 + 2 * g));
      } else if ("tRNS" == r3)
        3 == l2.ctype ? l2.tabs[r3] = a2.readBytes(i2, o2, e3) : 0 == l2.ctype ? l2.tabs[r3] = s2(i2, o2) : 2 == l2.ctype && (l2.tabs[r3] = [s2(i2, o2), s2(i2, o2 + 2), s2(i2, o2 + 4)]);
      else if ("gAMA" == r3)
        l2.tabs[r3] = a2.readUint(i2, o2) / 1e5;
      else if ("sRGB" == r3)
        l2.tabs[r3] = i2[o2];
      else if ("bKGD" == r3)
        0 == l2.ctype || 4 == l2.ctype ? l2.tabs[r3] = [s2(i2, o2)] : 2 == l2.ctype || 6 == l2.ctype ? l2.tabs[r3] = [s2(i2, o2), s2(i2, o2 + 2), s2(i2, o2 + 4)] : 3 == l2.ctype && (l2.tabs[r3] = i2[o2]);
      else if ("IEND" == r3)
        break;
      o2 += e3, a2.readUint(i2, o2), o2 += 4;
    }
    var E;
    return 0 != d && ((E = l2.frames[l2.frames.length - 1]).data = _decompress(l2, u.slice(0, d), E.rect.width, E.rect.height)), l2.data = _decompress(l2, c2, l2.width, l2.height), delete l2.compress, delete l2.interlace, delete l2.filter, l2;
  }, toRGBA8: function toRGBA8(e3) {
    const t3 = e3.width, r2 = e3.height;
    if (null == e3.tabs.acTL)
      return [decodeImage(e3.data, t3, r2, e3).buffer];
    const i2 = [];
    null == e3.frames[0].data && (e3.frames[0].data = e3.data);
    const o2 = t3 * r2 * 4, a2 = new Uint8Array(o2), s2 = new Uint8Array(o2), f2 = new Uint8Array(o2);
    for (let c2 = 0; c2 < e3.frames.length; c2++) {
      const u = e3.frames[c2], h = u.rect.x, d = u.rect.y, A = u.rect.width, g = u.rect.height, p = decodeImage(u.data, A, g, e3);
      if (0 != c2)
        for (var l2 = 0; l2 < o2; l2++)
          f2[l2] = a2[l2];
      if (0 == u.blend ? _copyTile(p, A, g, a2, t3, r2, h, d, 0) : 1 == u.blend && _copyTile(p, A, g, a2, t3, r2, h, d, 1), i2.push(a2.buffer.slice(0)), 0 == u.dispose)
        ;
      else if (1 == u.dispose)
        _copyTile(s2, A, g, a2, t3, r2, h, d, 0);
      else if (2 == u.dispose)
        for (l2 = 0; l2 < o2; l2++)
          a2[l2] = f2[l2];
    }
    return i2;
  }, _paeth, _copyTile, _bin: e2 };
}();
!function() {
  const { _copyTile: e2 } = UPNG, { _bin: t2 } = UPNG, r2 = UPNG._paeth;
  var i2 = { table: function() {
    const e3 = new Uint32Array(256);
    for (let t3 = 0; t3 < 256; t3++) {
      let r3 = t3;
      for (let e4 = 0; e4 < 8; e4++)
        1 & r3 ? r3 = 3988292384 ^ r3 >>> 1 : r3 >>>= 1;
      e3[t3] = r3;
    }
    return e3;
  }(), update(e3, t3, r3, o3) {
    for (let a2 = 0; a2 < o3; a2++)
      e3 = i2.table[255 & (e3 ^ t3[r3 + a2])] ^ e3 >>> 8;
    return e3;
  }, crc: (e3, t3, r3) => 4294967295 ^ i2.update(4294967295, e3, t3, r3) };
  function addErr(e3, t3, r3, i3) {
    t3[r3] += e3[0] * i3 >> 4, t3[r3 + 1] += e3[1] * i3 >> 4, t3[r3 + 2] += e3[2] * i3 >> 4, t3[r3 + 3] += e3[3] * i3 >> 4;
  }
  function N6(e3) {
    return Math.max(0, Math.min(255, e3));
  }
  function D(e3, t3) {
    const r3 = e3[0] - t3[0], i3 = e3[1] - t3[1], o3 = e3[2] - t3[2], a2 = e3[3] - t3[3];
    return r3 * r3 + i3 * i3 + o3 * o3 + a2 * a2;
  }
  function dither(e3, t3, r3, i3, o3, a2, s2) {
    null == s2 && (s2 = 1);
    const f2 = i3.length, l2 = [];
    for (var c2 = 0; c2 < f2; c2++) {
      const e4 = i3[c2];
      l2.push([e4 >>> 0 & 255, e4 >>> 8 & 255, e4 >>> 16 & 255, e4 >>> 24 & 255]);
    }
    for (c2 = 0; c2 < f2; c2++) {
      let e4 = 4294967295;
      for (var u = 0, h = 0; h < f2; h++) {
        var d = D(l2[c2], l2[h]);
        h != c2 && d < e4 && (e4 = d, u = h);
      }
    }
    const A = new Uint32Array(o3.buffer), g = new Int16Array(t3 * r3 * 4), p = [0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5];
    for (c2 = 0; c2 < p.length; c2++)
      p[c2] = 255 * ((p[c2] + 0.5) / 16 - 0.5);
    for (let o4 = 0; o4 < r3; o4++)
      for (let w = 0; w < t3; w++) {
        var m;
        c2 = 4 * (o4 * t3 + w);
        if (2 != s2)
          m = [N6(e3[c2] + g[c2]), N6(e3[c2 + 1] + g[c2 + 1]), N6(e3[c2 + 2] + g[c2 + 2]), N6(e3[c2 + 3] + g[c2 + 3])];
        else {
          d = p[4 * (3 & o4) + (3 & w)];
          m = [N6(e3[c2] + d), N6(e3[c2 + 1] + d), N6(e3[c2 + 2] + d), N6(e3[c2 + 3] + d)];
        }
        u = 0;
        let v = 16777215;
        for (h = 0; h < f2; h++) {
          const e4 = D(m, l2[h]);
          e4 < v && (v = e4, u = h);
        }
        const b = l2[u], y = [m[0] - b[0], m[1] - b[1], m[2] - b[2], m[3] - b[3]];
        1 == s2 && (w != t3 - 1 && addErr(y, g, c2 + 4, 7), o4 != r3 - 1 && (0 != w && addErr(y, g, c2 + 4 * t3 - 4, 3), addErr(y, g, c2 + 4 * t3, 5), w != t3 - 1 && addErr(y, g, c2 + 4 * t3 + 4, 1))), a2[c2 >> 2] = u, A[c2 >> 2] = i3[u];
      }
  }
  function _main(e3, r3, o3, a2, s2) {
    null == s2 && (s2 = {});
    const { crc: f2 } = i2, l2 = t2.writeUint, c2 = t2.writeUshort, u = t2.writeASCII;
    let h = 8;
    const d = e3.frames.length > 1;
    let A, g = false, p = 33 + (d ? 20 : 0);
    if (null != s2.sRGB && (p += 13), null != s2.pHYs && (p += 21), null != s2.iCCP && (A = pako.deflate(s2.iCCP), p += 21 + A.length + 4), 3 == e3.ctype) {
      for (var m = e3.plte.length, w = 0; w < m; w++)
        e3.plte[w] >>> 24 != 255 && (g = true);
      p += 8 + 3 * m + 4 + (g ? 8 + 1 * m + 4 : 0);
    }
    for (var v = 0; v < e3.frames.length; v++) {
      d && (p += 38), p += (F4 = e3.frames[v]).cimg.length + 12, 0 != v && (p += 4);
    }
    p += 12;
    const b = new Uint8Array(p), y = [137, 80, 78, 71, 13, 10, 26, 10];
    for (w = 0; w < 8; w++)
      b[w] = y[w];
    if (l2(b, h, 13), h += 4, u(b, h, "IHDR"), h += 4, l2(b, h, r3), h += 4, l2(b, h, o3), h += 4, b[h] = e3.depth, h++, b[h] = e3.ctype, h++, b[h] = 0, h++, b[h] = 0, h++, b[h] = 0, h++, l2(b, h, f2(b, h - 17, 17)), h += 4, null != s2.sRGB && (l2(b, h, 1), h += 4, u(b, h, "sRGB"), h += 4, b[h] = s2.sRGB, h++, l2(b, h, f2(b, h - 5, 5)), h += 4), null != s2.iCCP) {
      const e4 = 13 + A.length;
      l2(b, h, e4), h += 4, u(b, h, "iCCP"), h += 4, u(b, h, "ICC profile"), h += 11, h += 2, b.set(A, h), h += A.length, l2(b, h, f2(b, h - (e4 + 4), e4 + 4)), h += 4;
    }
    if (null != s2.pHYs && (l2(b, h, 9), h += 4, u(b, h, "pHYs"), h += 4, l2(b, h, s2.pHYs[0]), h += 4, l2(b, h, s2.pHYs[1]), h += 4, b[h] = s2.pHYs[2], h++, l2(b, h, f2(b, h - 13, 13)), h += 4), d && (l2(b, h, 8), h += 4, u(b, h, "acTL"), h += 4, l2(b, h, e3.frames.length), h += 4, l2(b, h, null != s2.loop ? s2.loop : 0), h += 4, l2(b, h, f2(b, h - 12, 12)), h += 4), 3 == e3.ctype) {
      l2(b, h, 3 * (m = e3.plte.length)), h += 4, u(b, h, "PLTE"), h += 4;
      for (w = 0; w < m; w++) {
        const t3 = 3 * w, r4 = e3.plte[w], i3 = 255 & r4, o4 = r4 >>> 8 & 255, a3 = r4 >>> 16 & 255;
        b[h + t3 + 0] = i3, b[h + t3 + 1] = o4, b[h + t3 + 2] = a3;
      }
      if (h += 3 * m, l2(b, h, f2(b, h - 3 * m - 4, 3 * m + 4)), h += 4, g) {
        l2(b, h, m), h += 4, u(b, h, "tRNS"), h += 4;
        for (w = 0; w < m; w++)
          b[h + w] = e3.plte[w] >>> 24 & 255;
        h += m, l2(b, h, f2(b, h - m - 4, m + 4)), h += 4;
      }
    }
    let E = 0;
    for (v = 0; v < e3.frames.length; v++) {
      var F4 = e3.frames[v];
      d && (l2(b, h, 26), h += 4, u(b, h, "fcTL"), h += 4, l2(b, h, E++), h += 4, l2(b, h, F4.rect.width), h += 4, l2(b, h, F4.rect.height), h += 4, l2(b, h, F4.rect.x), h += 4, l2(b, h, F4.rect.y), h += 4, c2(b, h, a2[v]), h += 2, c2(b, h, 1e3), h += 2, b[h] = F4.dispose, h++, b[h] = F4.blend, h++, l2(b, h, f2(b, h - 30, 30)), h += 4);
      const t3 = F4.cimg;
      l2(b, h, (m = t3.length) + (0 == v ? 0 : 4)), h += 4;
      const r4 = h;
      u(b, h, 0 == v ? "IDAT" : "fdAT"), h += 4, 0 != v && (l2(b, h, E++), h += 4), b.set(t3, h), h += m, l2(b, h, f2(b, r4, h - r4)), h += 4;
    }
    return l2(b, h, 0), h += 4, u(b, h, "IEND"), h += 4, l2(b, h, f2(b, h - 4, 4)), h += 4, b.buffer;
  }
  function compressPNG(e3, t3, r3) {
    for (let i3 = 0; i3 < e3.frames.length; i3++) {
      const o3 = e3.frames[i3];
      o3.rect.width;
      const a2 = o3.rect.height, s2 = new Uint8Array(a2 * o3.bpl + a2);
      o3.cimg = _filterZero(o3.img, a2, o3.bpp, o3.bpl, s2, t3, r3);
    }
  }
  function compress4(t3, r3, i3, o3, a2) {
    const s2 = a2[0], f2 = a2[1], l2 = a2[2], c2 = a2[3], u = a2[4], h = a2[5];
    let d = 6, A = 8, g = 255;
    for (var p = 0; p < t3.length; p++) {
      const e3 = new Uint8Array(t3[p]);
      for (var m = e3.length, w = 0; w < m; w += 4)
        g &= e3[w + 3];
    }
    const v = 255 != g, b = function framize(t4, r4, i4, o4, a3, s3) {
      const f3 = [];
      for (var l3 = 0; l3 < t4.length; l3++) {
        const h3 = new Uint8Array(t4[l3]), A3 = new Uint32Array(h3.buffer);
        var c3;
        let g2 = 0, p2 = 0, m2 = r4, w2 = i4, v2 = o4 ? 1 : 0;
        if (0 != l3) {
          const b2 = s3 || o4 || 1 == l3 || 0 != f3[l3 - 2].dispose ? 1 : 2;
          let y2 = 0, E2 = 1e9;
          for (let e3 = 0; e3 < b2; e3++) {
            var u2 = new Uint8Array(t4[l3 - 1 - e3]);
            const o5 = new Uint32Array(t4[l3 - 1 - e3]);
            let s4 = r4, f4 = i4, c4 = -1, h4 = -1;
            for (let e4 = 0; e4 < i4; e4++)
              for (let t5 = 0; t5 < r4; t5++) {
                A3[d2 = e4 * r4 + t5] != o5[d2] && (t5 < s4 && (s4 = t5), t5 > c4 && (c4 = t5), e4 < f4 && (f4 = e4), e4 > h4 && (h4 = e4));
              }
            -1 == c4 && (s4 = f4 = c4 = h4 = 0), a3 && (1 == (1 & s4) && s4--, 1 == (1 & f4) && f4--);
            const v3 = (c4 - s4 + 1) * (h4 - f4 + 1);
            v3 < E2 && (E2 = v3, y2 = e3, g2 = s4, p2 = f4, m2 = c4 - s4 + 1, w2 = h4 - f4 + 1);
          }
          u2 = new Uint8Array(t4[l3 - 1 - y2]);
          1 == y2 && (f3[l3 - 1].dispose = 2), c3 = new Uint8Array(m2 * w2 * 4), e2(u2, r4, i4, c3, m2, w2, -g2, -p2, 0), v2 = e2(h3, r4, i4, c3, m2, w2, -g2, -p2, 3) ? 1 : 0, 1 == v2 ? _prepareDiff(h3, r4, i4, c3, { x: g2, y: p2, width: m2, height: w2 }) : e2(h3, r4, i4, c3, m2, w2, -g2, -p2, 0);
        } else
          c3 = h3.slice(0);
        f3.push({ rect: { x: g2, y: p2, width: m2, height: w2 }, img: c3, blend: v2, dispose: 0 });
      }
      if (o4)
        for (l3 = 0; l3 < f3.length; l3++) {
          if (1 == (A2 = f3[l3]).blend)
            continue;
          const e3 = A2.rect, o5 = f3[l3 - 1].rect, s4 = Math.min(e3.x, o5.x), c4 = Math.min(e3.y, o5.y), u3 = { x: s4, y: c4, width: Math.max(e3.x + e3.width, o5.x + o5.width) - s4, height: Math.max(e3.y + e3.height, o5.y + o5.height) - c4 };
          f3[l3 - 1].dispose = 1, l3 - 1 != 0 && _updateFrame(t4, r4, i4, f3, l3 - 1, u3, a3), _updateFrame(t4, r4, i4, f3, l3, u3, a3);
        }
      let h2 = 0;
      if (1 != t4.length)
        for (var d2 = 0; d2 < f3.length; d2++) {
          var A2;
          h2 += (A2 = f3[d2]).rect.width * A2.rect.height;
        }
      return f3;
    }(t3, r3, i3, s2, f2, l2), y = {}, E = [], F4 = [];
    if (0 != o3) {
      const e3 = [];
      for (w = 0; w < b.length; w++)
        e3.push(b[w].img.buffer);
      const t4 = function concatRGBA(e4) {
        let t5 = 0;
        for (var r5 = 0; r5 < e4.length; r5++)
          t5 += e4[r5].byteLength;
        const i5 = new Uint8Array(t5);
        let o4 = 0;
        for (r5 = 0; r5 < e4.length; r5++) {
          const t6 = new Uint8Array(e4[r5]), a3 = t6.length;
          for (let e5 = 0; e5 < a3; e5 += 4) {
            let r6 = t6[e5], a4 = t6[e5 + 1], s3 = t6[e5 + 2];
            const f3 = t6[e5 + 3];
            0 == f3 && (r6 = a4 = s3 = 0), i5[o4 + e5] = r6, i5[o4 + e5 + 1] = a4, i5[o4 + e5 + 2] = s3, i5[o4 + e5 + 3] = f3;
          }
          o4 += a3;
        }
        return i5.buffer;
      }(e3), r4 = quantize(t4, o3);
      for (w = 0; w < r4.plte.length; w++)
        E.push(r4.plte[w].est.rgba);
      let i4 = 0;
      for (w = 0; w < b.length; w++) {
        const e4 = (B = b[w]).img.length;
        var _ = new Uint8Array(r4.inds.buffer, i4 >> 2, e4 >> 2);
        F4.push(_);
        const t5 = new Uint8Array(r4.abuf, i4, e4);
        h && dither(B.img, B.rect.width, B.rect.height, E, t5, _), B.img.set(t5), i4 += e4;
      }
    } else
      for (p = 0; p < b.length; p++) {
        var B = b[p];
        const e3 = new Uint32Array(B.img.buffer);
        var U3 = B.rect.width;
        m = e3.length, _ = new Uint8Array(m);
        F4.push(_);
        for (w = 0; w < m; w++) {
          const t4 = e3[w];
          if (0 != w && t4 == e3[w - 1])
            _[w] = _[w - 1];
          else if (w > U3 && t4 == e3[w - U3])
            _[w] = _[w - U3];
          else {
            let e4 = y[t4];
            if (null == e4 && (y[t4] = e4 = E.length, E.push(t4), E.length >= 300))
              break;
            _[w] = e4;
          }
        }
      }
    const C = E.length;
    C <= 256 && 0 == u && (A = C <= 2 ? 1 : C <= 4 ? 2 : C <= 16 ? 4 : 8, A = Math.max(A, c2));
    for (p = 0; p < b.length; p++) {
      (B = b[p]).rect.x, B.rect.y;
      U3 = B.rect.width;
      const e3 = B.rect.height;
      let t4 = B.img;
      new Uint32Array(t4.buffer);
      let r4 = 4 * U3, i4 = 4;
      if (C <= 256 && 0 == u) {
        r4 = Math.ceil(A * U3 / 8);
        var I = new Uint8Array(r4 * e3);
        const o4 = F4[p];
        for (let t5 = 0; t5 < e3; t5++) {
          w = t5 * r4;
          const e4 = t5 * U3;
          if (8 == A)
            for (var Q = 0; Q < U3; Q++)
              I[w + Q] = o4[e4 + Q];
          else if (4 == A)
            for (Q = 0; Q < U3; Q++)
              I[w + (Q >> 1)] |= o4[e4 + Q] << 4 - 4 * (1 & Q);
          else if (2 == A)
            for (Q = 0; Q < U3; Q++)
              I[w + (Q >> 2)] |= o4[e4 + Q] << 6 - 2 * (3 & Q);
          else if (1 == A)
            for (Q = 0; Q < U3; Q++)
              I[w + (Q >> 3)] |= o4[e4 + Q] << 7 - 1 * (7 & Q);
        }
        t4 = I, d = 3, i4 = 1;
      } else if (0 == v && 1 == b.length) {
        I = new Uint8Array(U3 * e3 * 3);
        const o4 = U3 * e3;
        for (w = 0; w < o4; w++) {
          const e4 = 3 * w, r5 = 4 * w;
          I[e4] = t4[r5], I[e4 + 1] = t4[r5 + 1], I[e4 + 2] = t4[r5 + 2];
        }
        t4 = I, d = 2, i4 = 3, r4 = 3 * U3;
      }
      B.img = t4, B.bpl = r4, B.bpp = i4;
    }
    return { ctype: d, depth: A, plte: E, frames: b };
  }
  function _updateFrame(t3, r3, i3, o3, a2, s2, f2) {
    const l2 = Uint8Array, c2 = Uint32Array, u = new l2(t3[a2 - 1]), h = new c2(t3[a2 - 1]), d = a2 + 1 < t3.length ? new l2(t3[a2 + 1]) : null, A = new l2(t3[a2]), g = new c2(A.buffer);
    let p = r3, m = i3, w = -1, v = -1;
    for (let e3 = 0; e3 < s2.height; e3++)
      for (let t4 = 0; t4 < s2.width; t4++) {
        const i4 = s2.x + t4, f3 = s2.y + e3, l3 = f3 * r3 + i4, c3 = g[l3];
        0 == c3 || 0 == o3[a2 - 1].dispose && h[l3] == c3 && (null == d || 0 != d[4 * l3 + 3]) || (i4 < p && (p = i4), i4 > w && (w = i4), f3 < m && (m = f3), f3 > v && (v = f3));
      }
    -1 == w && (p = m = w = v = 0), f2 && (1 == (1 & p) && p--, 1 == (1 & m) && m--), s2 = { x: p, y: m, width: w - p + 1, height: v - m + 1 };
    const b = o3[a2];
    b.rect = s2, b.blend = 1, b.img = new Uint8Array(s2.width * s2.height * 4), 0 == o3[a2 - 1].dispose ? (e2(u, r3, i3, b.img, s2.width, s2.height, -s2.x, -s2.y, 0), _prepareDiff(A, r3, i3, b.img, s2)) : e2(A, r3, i3, b.img, s2.width, s2.height, -s2.x, -s2.y, 0);
  }
  function _prepareDiff(t3, r3, i3, o3, a2) {
    e2(t3, r3, i3, o3, a2.width, a2.height, -a2.x, -a2.y, 2);
  }
  function _filterZero(e3, t3, r3, i3, o3, a2, s2) {
    const f2 = [];
    let l2, c2 = [0, 1, 2, 3, 4];
    -1 != a2 ? c2 = [a2] : (t3 * i3 > 5e5 || 1 == r3) && (c2 = [0]), s2 && (l2 = { level: 0 });
    const u = UZIP;
    for (var h = 0; h < c2.length; h++) {
      for (let a3 = 0; a3 < t3; a3++)
        _filterLine(o3, e3, a3, i3, r3, c2[h]);
      f2.push(u.deflate(o3, l2));
    }
    let d, A = 1e9;
    for (h = 0; h < f2.length; h++)
      f2[h].length < A && (d = h, A = f2[h].length);
    return f2[d];
  }
  function _filterLine(e3, t3, i3, o3, a2, s2) {
    const f2 = i3 * o3;
    let l2 = f2 + i3;
    if (e3[l2] = s2, l2++, 0 == s2)
      if (o3 < 500)
        for (var c2 = 0; c2 < o3; c2++)
          e3[l2 + c2] = t3[f2 + c2];
      else
        e3.set(new Uint8Array(t3.buffer, f2, o3), l2);
    else if (1 == s2) {
      for (c2 = 0; c2 < a2; c2++)
        e3[l2 + c2] = t3[f2 + c2];
      for (c2 = a2; c2 < o3; c2++)
        e3[l2 + c2] = t3[f2 + c2] - t3[f2 + c2 - a2] + 256 & 255;
    } else if (0 == i3) {
      for (c2 = 0; c2 < a2; c2++)
        e3[l2 + c2] = t3[f2 + c2];
      if (2 == s2)
        for (c2 = a2; c2 < o3; c2++)
          e3[l2 + c2] = t3[f2 + c2];
      if (3 == s2)
        for (c2 = a2; c2 < o3; c2++)
          e3[l2 + c2] = t3[f2 + c2] - (t3[f2 + c2 - a2] >> 1) + 256 & 255;
      if (4 == s2)
        for (c2 = a2; c2 < o3; c2++)
          e3[l2 + c2] = t3[f2 + c2] - r2(t3[f2 + c2 - a2], 0, 0) + 256 & 255;
    } else {
      if (2 == s2)
        for (c2 = 0; c2 < o3; c2++)
          e3[l2 + c2] = t3[f2 + c2] + 256 - t3[f2 + c2 - o3] & 255;
      if (3 == s2) {
        for (c2 = 0; c2 < a2; c2++)
          e3[l2 + c2] = t3[f2 + c2] + 256 - (t3[f2 + c2 - o3] >> 1) & 255;
        for (c2 = a2; c2 < o3; c2++)
          e3[l2 + c2] = t3[f2 + c2] + 256 - (t3[f2 + c2 - o3] + t3[f2 + c2 - a2] >> 1) & 255;
      }
      if (4 == s2) {
        for (c2 = 0; c2 < a2; c2++)
          e3[l2 + c2] = t3[f2 + c2] + 256 - r2(0, t3[f2 + c2 - o3], 0) & 255;
        for (c2 = a2; c2 < o3; c2++)
          e3[l2 + c2] = t3[f2 + c2] + 256 - r2(t3[f2 + c2 - a2], t3[f2 + c2 - o3], t3[f2 + c2 - a2 - o3]) & 255;
      }
    }
  }
  function quantize(e3, t3) {
    const r3 = new Uint8Array(e3), i3 = r3.slice(0), o3 = new Uint32Array(i3.buffer), a2 = getKDtree(i3, t3), s2 = a2[0], f2 = a2[1], l2 = r3.length, c2 = new Uint8Array(l2 >> 2);
    let u;
    if (r3.length < 2e7)
      for (var h = 0; h < l2; h += 4) {
        u = getNearest(s2, d = r3[h] * (1 / 255), A = r3[h + 1] * (1 / 255), g = r3[h + 2] * (1 / 255), p = r3[h + 3] * (1 / 255)), c2[h >> 2] = u.ind, o3[h >> 2] = u.est.rgba;
      }
    else
      for (h = 0; h < l2; h += 4) {
        var d = r3[h] * (1 / 255), A = r3[h + 1] * (1 / 255), g = r3[h + 2] * (1 / 255), p = r3[h + 3] * (1 / 255);
        for (u = s2; u.left; )
          u = planeDst(u.est, d, A, g, p) <= 0 ? u.left : u.right;
        c2[h >> 2] = u.ind, o3[h >> 2] = u.est.rgba;
      }
    return { abuf: i3.buffer, inds: c2, plte: f2 };
  }
  function getKDtree(e3, t3, r3) {
    null == r3 && (r3 = 1e-4);
    const i3 = new Uint32Array(e3.buffer), o3 = { i0: 0, i1: e3.length, bst: null, est: null, tdst: 0, left: null, right: null };
    o3.bst = stats(e3, o3.i0, o3.i1), o3.est = estats(o3.bst);
    const a2 = [o3];
    for (; a2.length < t3; ) {
      let t4 = 0, o4 = 0;
      for (var s2 = 0; s2 < a2.length; s2++)
        a2[s2].est.L > t4 && (t4 = a2[s2].est.L, o4 = s2);
      if (t4 < r3)
        break;
      const f2 = a2[o4], l2 = splitPixels(e3, i3, f2.i0, f2.i1, f2.est.e, f2.est.eMq255);
      if (f2.i0 >= l2 || f2.i1 <= l2) {
        f2.est.L = 0;
        continue;
      }
      const c2 = { i0: f2.i0, i1: l2, bst: null, est: null, tdst: 0, left: null, right: null };
      c2.bst = stats(e3, c2.i0, c2.i1), c2.est = estats(c2.bst);
      const u = { i0: l2, i1: f2.i1, bst: null, est: null, tdst: 0, left: null, right: null };
      u.bst = { R: [], m: [], N: f2.bst.N - c2.bst.N };
      for (s2 = 0; s2 < 16; s2++)
        u.bst.R[s2] = f2.bst.R[s2] - c2.bst.R[s2];
      for (s2 = 0; s2 < 4; s2++)
        u.bst.m[s2] = f2.bst.m[s2] - c2.bst.m[s2];
      u.est = estats(u.bst), f2.left = c2, f2.right = u, a2[o4] = c2, a2.push(u);
    }
    a2.sort((e4, t4) => t4.bst.N - e4.bst.N);
    for (s2 = 0; s2 < a2.length; s2++)
      a2[s2].ind = s2;
    return [o3, a2];
  }
  function getNearest(e3, t3, r3, i3, o3) {
    if (null == e3.left)
      return e3.tdst = function dist(e4, t4, r4, i4, o4) {
        const a3 = t4 - e4[0], s3 = r4 - e4[1], f3 = i4 - e4[2], l3 = o4 - e4[3];
        return a3 * a3 + s3 * s3 + f3 * f3 + l3 * l3;
      }(e3.est.q, t3, r3, i3, o3), e3;
    const a2 = planeDst(e3.est, t3, r3, i3, o3);
    let s2 = e3.left, f2 = e3.right;
    a2 > 0 && (s2 = e3.right, f2 = e3.left);
    const l2 = getNearest(s2, t3, r3, i3, o3);
    if (l2.tdst <= a2 * a2)
      return l2;
    const c2 = getNearest(f2, t3, r3, i3, o3);
    return c2.tdst < l2.tdst ? c2 : l2;
  }
  function planeDst(e3, t3, r3, i3, o3) {
    const { e: a2 } = e3;
    return a2[0] * t3 + a2[1] * r3 + a2[2] * i3 + a2[3] * o3 - e3.eMq;
  }
  function splitPixels(e3, t3, r3, i3, o3, a2) {
    for (i3 -= 4; r3 < i3; ) {
      for (; vecDot(e3, r3, o3) <= a2; )
        r3 += 4;
      for (; vecDot(e3, i3, o3) > a2; )
        i3 -= 4;
      if (r3 >= i3)
        break;
      const s2 = t3[r3 >> 2];
      t3[r3 >> 2] = t3[i3 >> 2], t3[i3 >> 2] = s2, r3 += 4, i3 -= 4;
    }
    for (; vecDot(e3, r3, o3) > a2; )
      r3 -= 4;
    return r3 + 4;
  }
  function vecDot(e3, t3, r3) {
    return e3[t3] * r3[0] + e3[t3 + 1] * r3[1] + e3[t3 + 2] * r3[2] + e3[t3 + 3] * r3[3];
  }
  function stats(e3, t3, r3) {
    const i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], o3 = [0, 0, 0, 0], a2 = r3 - t3 >> 2;
    for (let a3 = t3; a3 < r3; a3 += 4) {
      const t4 = e3[a3] * (1 / 255), r4 = e3[a3 + 1] * (1 / 255), s2 = e3[a3 + 2] * (1 / 255), f2 = e3[a3 + 3] * (1 / 255);
      o3[0] += t4, o3[1] += r4, o3[2] += s2, o3[3] += f2, i3[0] += t4 * t4, i3[1] += t4 * r4, i3[2] += t4 * s2, i3[3] += t4 * f2, i3[5] += r4 * r4, i3[6] += r4 * s2, i3[7] += r4 * f2, i3[10] += s2 * s2, i3[11] += s2 * f2, i3[15] += f2 * f2;
    }
    return i3[4] = i3[1], i3[8] = i3[2], i3[9] = i3[6], i3[12] = i3[3], i3[13] = i3[7], i3[14] = i3[11], { R: i3, m: o3, N: a2 };
  }
  function estats(e3) {
    const { R: t3 } = e3, { m: r3 } = e3, { N: i3 } = e3, a2 = r3[0], s2 = r3[1], f2 = r3[2], l2 = r3[3], c2 = 0 == i3 ? 0 : 1 / i3, u = [t3[0] - a2 * a2 * c2, t3[1] - a2 * s2 * c2, t3[2] - a2 * f2 * c2, t3[3] - a2 * l2 * c2, t3[4] - s2 * a2 * c2, t3[5] - s2 * s2 * c2, t3[6] - s2 * f2 * c2, t3[7] - s2 * l2 * c2, t3[8] - f2 * a2 * c2, t3[9] - f2 * s2 * c2, t3[10] - f2 * f2 * c2, t3[11] - f2 * l2 * c2, t3[12] - l2 * a2 * c2, t3[13] - l2 * s2 * c2, t3[14] - l2 * f2 * c2, t3[15] - l2 * l2 * c2], h = u, d = o2;
    let A = [Math.random(), Math.random(), Math.random(), Math.random()], g = 0, p = 0;
    if (0 != i3)
      for (let e4 = 0; e4 < 16 && (A = d.multVec(h, A), p = Math.sqrt(d.dot(A, A)), A = d.sml(1 / p, A), !(0 != e4 && Math.abs(p - g) < 1e-9)); e4++)
        g = p;
    const m = [a2 * c2, s2 * c2, f2 * c2, l2 * c2];
    return { Cov: u, q: m, e: A, L: g, eMq255: d.dot(d.sml(255, m), A), eMq: d.dot(A, m), rgba: (Math.round(255 * m[3]) << 24 | Math.round(255 * m[2]) << 16 | Math.round(255 * m[1]) << 8 | Math.round(255 * m[0]) << 0) >>> 0 };
  }
  var o2 = { multVec: (e3, t3) => [e3[0] * t3[0] + e3[1] * t3[1] + e3[2] * t3[2] + e3[3] * t3[3], e3[4] * t3[0] + e3[5] * t3[1] + e3[6] * t3[2] + e3[7] * t3[3], e3[8] * t3[0] + e3[9] * t3[1] + e3[10] * t3[2] + e3[11] * t3[3], e3[12] * t3[0] + e3[13] * t3[1] + e3[14] * t3[2] + e3[15] * t3[3]], dot: (e3, t3) => e3[0] * t3[0] + e3[1] * t3[1] + e3[2] * t3[2] + e3[3] * t3[3], sml: (e3, t3) => [e3 * t3[0], e3 * t3[1], e3 * t3[2], e3 * t3[3]] };
  UPNG.encode = function encode4(e3, t3, r3, i3, o3, a2, s2) {
    null == i3 && (i3 = 0), null == s2 && (s2 = false);
    const f2 = compress4(e3, t3, r3, i3, [false, false, false, 0, s2, false]);
    return compressPNG(f2, -1), _main(f2, t3, r3, o3, a2);
  }, UPNG.encodeLL = function encodeLL(e3, t3, r3, i3, o3, a2, s2, f2) {
    const l2 = { ctype: 0 + (1 == i3 ? 0 : 2) + (0 == o3 ? 0 : 4), depth: a2, frames: [] }, c2 = (i3 + o3) * a2, u = c2 * t3;
    for (let i4 = 0; i4 < e3.length; i4++)
      l2.frames.push({ rect: { x: 0, y: 0, width: t3, height: r3 }, img: new Uint8Array(e3[i4]), blend: 0, dispose: 1, bpp: Math.ceil(c2 / 8), bpl: Math.ceil(u / 8) });
    return compressPNG(l2, 0, true), _main(l2, t3, r3, s2, f2);
  }, UPNG.encode.compress = compress4, UPNG.encode.dither = dither, UPNG.quantize = quantize, UPNG.quantize.getKDtree = getKDtree, UPNG.quantize.getNearest = getNearest;
}();
var r = { toArrayBuffer(e2, t2) {
  const i2 = e2.width, o2 = e2.height, a2 = i2 << 2, s2 = e2.getContext("2d").getImageData(0, 0, i2, o2), f2 = new Uint32Array(s2.data.buffer), l2 = (32 * i2 + 31) / 32 << 2, c2 = l2 * o2, u = 122 + c2, h = new ArrayBuffer(u), d = new DataView(h), A = 1 << 20;
  let g, p, m, w, v = A, b = 0, y = 0, E = 0;
  function set16(e3) {
    d.setUint16(y, e3, true), y += 2;
  }
  function set32(e3) {
    d.setUint32(y, e3, true), y += 4;
  }
  function seek(e3) {
    y += e3;
  }
  set16(19778), set32(u), seek(4), set32(122), set32(108), set32(i2), set32(-o2 >>> 0), set16(1), set16(32), set32(3), set32(c2), set32(2835), set32(2835), seek(8), set32(16711680), set32(65280), set32(255), set32(4278190080), set32(1466527264), function convert() {
    for (; b < o2 && v > 0; ) {
      for (w = 122 + b * l2, g = 0; g < a2; )
        v--, p = f2[E++], m = p >>> 24, d.setUint32(w + g, p << 8 | m), g += 4;
      b++;
    }
    E < f2.length ? (v = A, setTimeout(convert, r._dly)) : t2(h);
  }();
}, toBlob(e2, t2) {
  this.toArrayBuffer(e2, (e3) => {
    t2(new Blob([e3], { type: "image/bmp" }));
  });
}, _dly: 9 };
var i = { CHROME: "CHROME", FIREFOX: "FIREFOX", DESKTOP_SAFARI: "DESKTOP_SAFARI", IE: "IE", IOS: "IOS", ETC: "ETC" };
var o = { [i.CHROME]: 16384, [i.FIREFOX]: 11180, [i.DESKTOP_SAFARI]: 16384, [i.IE]: 8192, [i.IOS]: 4096, [i.ETC]: 8192 };
var a = "undefined" != typeof window;
var s = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope;
var f = a && window.cordova && window.cordova.require && window.cordova.require("cordova/modulemapper");
var CustomFile = (a || s) && (f && f.getOriginalSymbol(window, "File") || "undefined" != typeof File && File);
var CustomFileReader = (a || s) && (f && f.getOriginalSymbol(window, "FileReader") || "undefined" != typeof FileReader && FileReader);
function getFilefromDataUrl(e2, t2, r2 = Date.now()) {
  return new Promise((i2) => {
    const o2 = e2.split(","), a2 = o2[0].match(/:(.*?);/)[1], s2 = globalThis.atob(o2[1]);
    let f2 = s2.length;
    const l2 = new Uint8Array(f2);
    for (; f2--; )
      l2[f2] = s2.charCodeAt(f2);
    const c2 = new Blob([l2], { type: a2 });
    c2.name = t2, c2.lastModified = r2, i2(c2);
  });
}
function getDataUrlFromFile(e2) {
  return new Promise((t2, r2) => {
    const i2 = new CustomFileReader();
    i2.onload = () => t2(i2.result), i2.onerror = (e3) => r2(e3), i2.readAsDataURL(e2);
  });
}
function loadImage(e2) {
  return new Promise((t2, r2) => {
    const i2 = new Image();
    i2.onload = () => t2(i2), i2.onerror = (e3) => r2(e3), i2.src = e2;
  });
}
function getBrowserName() {
  if (void 0 !== getBrowserName.cachedResult)
    return getBrowserName.cachedResult;
  let e2 = i.ETC;
  const { userAgent: t2 } = navigator;
  return /Chrom(e|ium)/i.test(t2) ? e2 = i.CHROME : /iP(ad|od|hone)/i.test(t2) && /WebKit/i.test(t2) ? e2 = i.IOS : /Safari/i.test(t2) ? e2 = i.DESKTOP_SAFARI : /Firefox/i.test(t2) ? e2 = i.FIREFOX : (/MSIE/i.test(t2) || true == !!document.documentMode) && (e2 = i.IE), getBrowserName.cachedResult = e2, getBrowserName.cachedResult;
}
function approximateBelowMaximumCanvasSizeOfBrowser(e2, t2) {
  const r2 = getBrowserName(), i2 = o[r2];
  let a2 = e2, s2 = t2, f2 = a2 * s2;
  const l2 = a2 > s2 ? s2 / a2 : a2 / s2;
  for (; f2 > i2 * i2; ) {
    const e3 = (i2 + a2) / 2, t3 = (i2 + s2) / 2;
    e3 < t3 ? (s2 = t3, a2 = t3 * l2) : (s2 = e3 * l2, a2 = e3), f2 = a2 * s2;
  }
  return { width: a2, height: s2 };
}
function getNewCanvasAndCtx(e2, t2) {
  let r2, i2;
  try {
    if (r2 = new OffscreenCanvas(e2, t2), i2 = r2.getContext("2d"), null === i2)
      throw new Error("getContext of OffscreenCanvas returns null");
  } catch (e3) {
    r2 = document.createElement("canvas"), i2 = r2.getContext("2d");
  }
  return r2.width = e2, r2.height = t2, [r2, i2];
}
function drawImageInCanvas(e2, t2) {
  const { width: r2, height: i2 } = approximateBelowMaximumCanvasSizeOfBrowser(e2.width, e2.height), [o2, a2] = getNewCanvasAndCtx(r2, i2);
  return t2 && /jpe?g/.test(t2) && (a2.fillStyle = "white", a2.fillRect(0, 0, o2.width, o2.height)), a2.drawImage(e2, 0, 0, o2.width, o2.height), o2;
}
function isIOS() {
  return void 0 !== isIOS.cachedResult || (isIOS.cachedResult = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "undefined" != typeof document && "ontouchend" in document), isIOS.cachedResult;
}
function drawFileInCanvas(e2, t2 = {}) {
  return new Promise(function(r2, o2) {
    let a2, s2;
    var $Try_2_Post = function() {
      try {
        return s2 = drawImageInCanvas(a2, t2.fileType || e2.type), r2([a2, s2]);
      } catch (e3) {
        return o2(e3);
      }
    }, $Try_2_Catch = function(t3) {
      try {
        0;
        var $Try_3_Catch = function(e3) {
          try {
            throw e3;
          } catch (e4) {
            return o2(e4);
          }
        };
        try {
          let t4;
          return getDataUrlFromFile(e2).then(function(e3) {
            try {
              return t4 = e3, loadImage(t4).then(function(e4) {
                try {
                  return a2 = e4, function() {
                    try {
                      return $Try_2_Post();
                    } catch (e5) {
                      return o2(e5);
                    }
                  }();
                } catch (e5) {
                  return $Try_3_Catch(e5);
                }
              }, $Try_3_Catch);
            } catch (e4) {
              return $Try_3_Catch(e4);
            }
          }, $Try_3_Catch);
        } catch (e3) {
          $Try_3_Catch(e3);
        }
      } catch (e3) {
        return o2(e3);
      }
    };
    try {
      if (isIOS() || [i.DESKTOP_SAFARI, i.MOBILE_SAFARI].includes(getBrowserName()))
        throw new Error("Skip createImageBitmap on IOS and Safari");
      return createImageBitmap(e2).then(function(e3) {
        try {
          return a2 = e3, $Try_2_Post();
        } catch (e4) {
          return $Try_2_Catch();
        }
      }, $Try_2_Catch);
    } catch (e3) {
      $Try_2_Catch();
    }
  });
}
function canvasToFile(e2, t2, i2, o2, a2 = 1) {
  return new Promise(function(s2, f2) {
    let l2;
    if ("image/png" === t2) {
      let c2, u, h;
      return c2 = e2.getContext("2d"), { data: u } = c2.getImageData(0, 0, e2.width, e2.height), h = UPNG.encode([u.buffer], e2.width, e2.height, 4096 * a2), l2 = new Blob([h], { type: t2 }), l2.name = i2, l2.lastModified = o2, $If_4.call(this);
    }
    {
      let $If_5 = function() {
        return $If_4.call(this);
      };
      if ("image/bmp" === t2)
        return new Promise((t3) => r.toBlob(e2, t3)).then(function(e3) {
          try {
            return l2 = e3, l2.name = i2, l2.lastModified = o2, $If_5.call(this);
          } catch (e4) {
            return f2(e4);
          }
        }.bind(this), f2);
      {
        let $If_6 = function() {
          return $If_5.call(this);
        };
        if ("function" == typeof OffscreenCanvas && e2 instanceof OffscreenCanvas)
          return e2.convertToBlob({ type: t2, quality: a2 }).then(function(e3) {
            try {
              return l2 = e3, l2.name = i2, l2.lastModified = o2, $If_6.call(this);
            } catch (e4) {
              return f2(e4);
            }
          }.bind(this), f2);
        {
          let d;
          return d = e2.toDataURL(t2, a2), getFilefromDataUrl(d, i2, o2).then(function(e3) {
            try {
              return l2 = e3, $If_6.call(this);
            } catch (e4) {
              return f2(e4);
            }
          }.bind(this), f2);
        }
      }
    }
    function $If_4() {
      return s2(l2);
    }
  });
}
function cleanupCanvasMemory(e2) {
  e2.width = 0, e2.height = 0;
}
function isAutoOrientationInBrowser() {
  return new Promise(function(e2, t2) {
    let r2, i2, o2, a2, s2;
    return void 0 !== isAutoOrientationInBrowser.cachedResult ? e2(isAutoOrientationInBrowser.cachedResult) : (r2 = "data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==", getFilefromDataUrl("data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==", "test.jpg", Date.now()).then(function(r3) {
      try {
        return i2 = r3, drawFileInCanvas(i2).then(function(r4) {
          try {
            return o2 = r4[1], canvasToFile(o2, i2.type, i2.name, i2.lastModified).then(function(r5) {
              try {
                return a2 = r5, cleanupCanvasMemory(o2), drawFileInCanvas(a2).then(function(r6) {
                  try {
                    return s2 = r6[0], isAutoOrientationInBrowser.cachedResult = 1 === s2.width && 2 === s2.height, e2(isAutoOrientationInBrowser.cachedResult);
                  } catch (e3) {
                    return t2(e3);
                  }
                }, t2);
              } catch (e3) {
                return t2(e3);
              }
            }, t2);
          } catch (e3) {
            return t2(e3);
          }
        }, t2);
      } catch (e3) {
        return t2(e3);
      }
    }, t2));
  });
}
function getExifOrientation(e2) {
  return new Promise((t2, r2) => {
    const i2 = new CustomFileReader();
    i2.onload = (e3) => {
      const r3 = new DataView(e3.target.result);
      if (65496 != r3.getUint16(0, false))
        return t2(-2);
      const i3 = r3.byteLength;
      let o2 = 2;
      for (; o2 < i3; ) {
        if (r3.getUint16(o2 + 2, false) <= 8)
          return t2(-1);
        const e4 = r3.getUint16(o2, false);
        if (o2 += 2, 65505 == e4) {
          if (1165519206 != r3.getUint32(o2 += 2, false))
            return t2(-1);
          const e5 = 18761 == r3.getUint16(o2 += 6, false);
          o2 += r3.getUint32(o2 + 4, e5);
          const i4 = r3.getUint16(o2, e5);
          o2 += 2;
          for (let a2 = 0; a2 < i4; a2++)
            if (274 == r3.getUint16(o2 + 12 * a2, e5))
              return t2(r3.getUint16(o2 + 12 * a2 + 8, e5));
        } else {
          if (65280 != (65280 & e4))
            break;
          o2 += r3.getUint16(o2, false);
        }
      }
      return t2(-1);
    }, i2.onerror = (e3) => r2(e3), i2.readAsArrayBuffer(e2);
  });
}
function handleMaxWidthOrHeight(e2, t2) {
  const { width: r2 } = e2, { height: i2 } = e2, { maxWidthOrHeight: o2 } = t2;
  let a2, s2 = e2;
  return isFinite(o2) && (r2 > o2 || i2 > o2) && ([s2, a2] = getNewCanvasAndCtx(r2, i2), r2 > i2 ? (s2.width = o2, s2.height = i2 / r2 * o2) : (s2.width = r2 / i2 * o2, s2.height = o2), a2.drawImage(e2, 0, 0, s2.width, s2.height), cleanupCanvasMemory(e2)), s2;
}
function followExifOrientation(e2, t2) {
  const { width: r2 } = e2, { height: i2 } = e2, [o2, a2] = getNewCanvasAndCtx(r2, i2);
  switch (t2 > 4 && t2 < 9 ? (o2.width = i2, o2.height = r2) : (o2.width = r2, o2.height = i2), t2) {
    case 2:
      a2.transform(-1, 0, 0, 1, r2, 0);
      break;
    case 3:
      a2.transform(-1, 0, 0, -1, r2, i2);
      break;
    case 4:
      a2.transform(1, 0, 0, -1, 0, i2);
      break;
    case 5:
      a2.transform(0, 1, 1, 0, 0, 0);
      break;
    case 6:
      a2.transform(0, 1, -1, 0, i2, 0);
      break;
    case 7:
      a2.transform(0, -1, -1, 0, i2, r2);
      break;
    case 8:
      a2.transform(0, -1, 1, 0, 0, r2);
  }
  return a2.drawImage(e2, 0, 0, r2, i2), cleanupCanvasMemory(e2), o2;
}
function compress(e2, t2, r2 = 0) {
  return new Promise(function(i2, o2) {
    let a2, s2, f2, l2, c2, u, h, d, A, g, p, m, w, v, b, y, E, F4, _, B;
    function incProgress(e3 = 5) {
      if (t2.signal && t2.signal.aborted)
        throw t2.signal.reason;
      a2 += e3, t2.onProgress(Math.min(a2, 100));
    }
    function setProgress(e3) {
      if (t2.signal && t2.signal.aborted)
        throw t2.signal.reason;
      a2 = Math.min(Math.max(e3, a2), 100), t2.onProgress(a2);
    }
    return a2 = r2, s2 = t2.maxIteration || 10, f2 = 1024 * t2.maxSizeMB * 1024, incProgress(), drawFileInCanvas(e2, t2).then(function(r3) {
      try {
        return [, l2] = r3, incProgress(), c2 = handleMaxWidthOrHeight(l2, t2), incProgress(), new Promise(function(r4, i3) {
          var o3;
          if (!(o3 = t2.exifOrientation))
            return getExifOrientation(e2).then(function(e3) {
              try {
                return o3 = e3, $If_2.call(this);
              } catch (e4) {
                return i3(e4);
              }
            }.bind(this), i3);
          function $If_2() {
            return r4(o3);
          }
          return $If_2.call(this);
        }).then(function(r4) {
          try {
            return u = r4, incProgress(), isAutoOrientationInBrowser().then(function(r5) {
              try {
                return h = r5 ? c2 : followExifOrientation(c2, u), incProgress(), d = t2.initialQuality || 1, A = t2.fileType || e2.type, canvasToFile(h, A, e2.name, e2.lastModified, d).then(function(r6) {
                  try {
                    {
                      let $Loop_3 = function() {
                        if (s2-- && (b > f2 || b > w)) {
                          let t3, r7;
                          return t3 = B ? 0.95 * _.width : _.width, r7 = B ? 0.95 * _.height : _.height, [E, F4] = getNewCanvasAndCtx(t3, r7), F4.drawImage(_, 0, 0, t3, r7), d *= "image/png" === A ? 0.85 : 0.95, canvasToFile(E, A, e2.name, e2.lastModified, d).then(function(e3) {
                            try {
                              return y = e3, cleanupCanvasMemory(_), _ = E, b = y.size, setProgress(Math.min(99, Math.floor((v - b) / (v - f2) * 100))), $Loop_3;
                            } catch (e4) {
                              return o2(e4);
                            }
                          }, o2);
                        }
                        return [1];
                      }, $Loop_3_exit = function() {
                        return cleanupCanvasMemory(_), cleanupCanvasMemory(E), cleanupCanvasMemory(c2), cleanupCanvasMemory(h), cleanupCanvasMemory(l2), setProgress(100), i2(y);
                      };
                      if (g = r6, incProgress(), p = g.size > f2, m = g.size > e2.size, !p && !m)
                        return setProgress(100), i2(g);
                      var a3;
                      return w = e2.size, v = g.size, b = v, _ = h, B = !t2.alwaysKeepResolution && p, (a3 = function(e3) {
                        for (; e3; ) {
                          if (e3.then)
                            return void e3.then(a3, o2);
                          try {
                            if (e3.pop) {
                              if (e3.length)
                                return e3.pop() ? $Loop_3_exit.call(this) : e3;
                              e3 = $Loop_3;
                            } else
                              e3 = e3.call(this);
                          } catch (e4) {
                            return o2(e4);
                          }
                        }
                      }.bind(this))($Loop_3);
                    }
                  } catch (u2) {
                    return o2(u2);
                  }
                }.bind(this), o2);
              } catch (e3) {
                return o2(e3);
              }
            }.bind(this), o2);
          } catch (e3) {
            return o2(e3);
          }
        }.bind(this), o2);
      } catch (e3) {
        return o2(e3);
      }
    }.bind(this), o2);
  });
}
var l = "\nlet scriptImported = false\nself.addEventListener('message', async (e) => {\n  const { file, id, imageCompressionLibUrl, options } = e.data\n  options.onProgress = (progress) => self.postMessage({ progress, id })\n  try {\n    if (!scriptImported) {\n      // console.log('[worker] importScripts', imageCompressionLibUrl)\n      self.importScripts(imageCompressionLibUrl)\n      scriptImported = true\n    }\n    // console.log('[worker] self', self)\n    const compressedFile = await imageCompression(file, options)\n    self.postMessage({ file: compressedFile, id })\n  } catch (e) {\n    // console.error('[worker] error', e)\n    self.postMessage({ error: e.message + '\\n' + e.stack, id })\n  }\n})\n";
var c;
function compressOnWebWorker(e2, t2) {
  return new Promise((r2, i2) => {
    c || (c = function createWorkerScriptURL(e3) {
      const t3 = [];
      return "function" == typeof e3 ? t3.push(`(${e3})()`) : t3.push(e3), URL.createObjectURL(new Blob(t3));
    }(l));
    const o2 = new Worker(c);
    o2.addEventListener("message", function handler(e3) {
      if (t2.signal && t2.signal.aborted)
        o2.terminate();
      else if (void 0 === e3.data.progress) {
        if (e3.data.error)
          return i2(new Error(e3.data.error)), void o2.terminate();
        r2(e3.data.file), o2.terminate();
      } else
        t2.onProgress(e3.data.progress);
    }), o2.addEventListener("error", i2), t2.signal && t2.signal.addEventListener("abort", () => {
      i2(t2.signal.reason), o2.terminate();
    }), o2.postMessage({ file: e2, imageCompressionLibUrl: t2.libURL, options: { ...t2, onProgress: void 0, signal: void 0 } });
  });
}
function imageCompression(e2, t2) {
  return new Promise(function(r2, i2) {
    let o2, a2, s2, f2, l2, c2;
    if (o2 = { ...t2 }, s2 = 0, { onProgress: f2 } = o2, o2.maxSizeMB = o2.maxSizeMB || Number.POSITIVE_INFINITY, l2 = "boolean" != typeof o2.useWebWorker || o2.useWebWorker, delete o2.useWebWorker, o2.onProgress = (e3) => {
      s2 = e3, "function" == typeof f2 && f2(s2);
    }, !(e2 instanceof Blob || e2 instanceof CustomFile))
      return i2(new Error("The file given is not an instance of Blob or File"));
    if (!/^image/.test(e2.type))
      return i2(new Error("The file given is not an image"));
    if (c2 = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope, !l2 || "function" != typeof Worker || c2)
      return compress(e2, o2).then(function(e3) {
        try {
          return a2 = e3, $If_4.call(this);
        } catch (e4) {
          return i2(e4);
        }
      }.bind(this), i2);
    var u = function() {
      try {
        return $If_4.call(this);
      } catch (e3) {
        return i2(e3);
      }
    }.bind(this), $Try_1_Catch = function(t3) {
      try {
        return compress(e2, o2).then(function(e3) {
          try {
            return a2 = e3, u();
          } catch (e4) {
            return i2(e4);
          }
        }, i2);
      } catch (e3) {
        return i2(e3);
      }
    };
    try {
      return o2.libURL = o2.libURL || "https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js", compressOnWebWorker(e2, o2).then(function(e3) {
        try {
          return a2 = e3, u();
        } catch (e4) {
          return $Try_1_Catch();
        }
      }, $Try_1_Catch);
    } catch (e3) {
      $Try_1_Catch();
    }
    function $If_4() {
      try {
        a2.name = e2.name, a2.lastModified = e2.lastModified;
      } catch (e3) {
      }
      try {
        o2.preserveExif && "image/jpeg" === e2.type && (!o2.fileType || o2.fileType && o2.fileType === e2.type) && (a2 = copyExifWithoutOrientation(e2, a2));
      } catch (e3) {
      }
      return r2(a2);
    }
  });
}
imageCompression.getDataUrlFromFile = getDataUrlFromFile, imageCompression.getFilefromDataUrl = getFilefromDataUrl, imageCompression.loadImage = loadImage, imageCompression.drawImageInCanvas = drawImageInCanvas, imageCompression.drawFileInCanvas = drawFileInCanvas, imageCompression.canvasToFile = canvasToFile, imageCompression.getExifOrientation = getExifOrientation, imageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight, imageCompression.followExifOrientation = followExifOrientation, imageCompression.cleanupCanvasMemory = cleanupCanvasMemory, imageCompression.isAutoOrientationInBrowser = isAutoOrientationInBrowser, imageCompression.approximateBelowMaximumCanvasSizeOfBrowser = approximateBelowMaximumCanvasSizeOfBrowser, imageCompression.copyExifWithoutOrientation = copyExifWithoutOrientation, imageCompression.getBrowserName = getBrowserName, imageCompression.version = "2.0.2";

// src/Compressor.ts
var types2 = {
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  bmp: "image/jpeg"
  // force convert to JPG
};
async function compressArrayBuffer(data, mimeType, options) {
  const file = new File([data], "", { type: mimeType });
  const blob = await imageCompression(file, options);
  return blob.arrayBuffer();
}
async function compressImage(data, filetype) {
  const type = types2[filetype];
  let changed = false;
  if (type && data.byteLength > 100 * 1024) {
    try {
      const defaultOptions = {
        maxSizeMB: 0.7,
        maxWidthOrHeight: 1400,
        preserveExif: false,
        initialQuality: 0.6,
        fileType: type
      };
      const originalData = data;
      data = await compressArrayBuffer(data, type, defaultOptions);
      if (data.byteLength > 200 * 1024) {
        const test = await compressArrayBuffer(data, type, Object.assign(defaultOptions, {
          fileType: "image/jpeg"
        }));
        if (test.byteLength < data.byteLength) {
          data = test;
          filetype = "jpg";
        }
      }
      if (data.byteLength > originalData.byteLength) {
        data = originalData;
      }
      changed = data.byteLength !== originalData.byteLength;
    } catch (e2) {
      console.log(e2);
    }
  }
  return {
    data,
    filetype,
    changed
  };
}

// src/api.ts
var pluginVersion = require_manifest().version;
var API = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.uploadQueue = [];
  }
  async authHeaders() {
    const nonce = Date.now().toString();
    return {
      "x-sharenote-id": this.plugin.settings.uid,
      "x-sharenote-key": await sha256(nonce + this.plugin.settings.apiKey),
      "x-sharenote-nonce": nonce,
      "x-sharenote-version": pluginVersion
    };
  }
  async post(endpoint, data, retries = 1) {
    var _a;
    const headers = {
      ...await this.authHeaders(),
      "Content-Type": "application/json"
    };
    if (data == null ? void 0 : data.byteLength)
      headers["x-sharenote-bytelength"] = data.byteLength.toString();
    const body = Object.assign({}, data);
    if (this.plugin.settings.debug)
      body.debug = this.plugin.settings.debug;
    while (retries > 0) {
      try {
        const res = await (0, import_obsidian3.requestUrl)({
          url: this.plugin.settings.server + endpoint,
          method: "POST",
          headers,
          body: JSON.stringify(body)
        });
        if (this.plugin.settings.debug === 1 && (data == null ? void 0 : data.filetype) === "html") {
          console.log(res.json.html);
        }
        return res.json;
      } catch (error) {
        if (error.status < 500 || retries <= 1) {
          const message = (_a = error.headers) == null ? void 0 : _a.message;
          if (message) {
            if (error.status === 462) {
              this.plugin.authRedirect("share").then();
            } else {
              new StatusMessage(message, 2 /* Error */);
            }
            throw new Error("Known error");
          }
          throw new Error("Unknown error");
        } else {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
      console.log("Retrying " + retries);
      retries--;
    }
  }
  async postRaw(endpoint, data, retries = 4) {
    const headers = {
      ...await this.authHeaders(),
      "x-sharenote-filetype": data.filetype,
      "x-sharenote-hash": data.hash
    };
    if (data.byteLength)
      headers["x-sharenote-bytelength"] = data.byteLength.toString();
    while (retries > 0) {
      const res = await fetch(this.plugin.settings.server + endpoint, {
        method: "POST",
        headers,
        body: data.content
      });
      if (res.status !== 200) {
        if (res.status < 500 || retries <= 1) {
          const message = await res.text();
          if (message) {
            new StatusMessage(message, 2 /* Error */);
            throw new Error("Known error");
          }
          throw new Error("Unknown error");
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      } else {
        return res.json();
      }
      console.log("Retrying " + retries);
      retries--;
    }
  }
  async queueUpload(item) {
    if (item.data.content) {
      const compressed = await compressImage(item.data.content, item.data.filetype);
      if (compressed.changed) {
        item.data.content = compressed.data;
        item.data.filetype = compressed.filetype;
        item.data.hash = await sha1(compressed.data);
      }
    }
    this.uploadQueue.push(item);
  }
  async processQueue(status, type = "attachment") {
    const res = await this.post("/v1/file/check-files", {
      files: this.uploadQueue.map((x) => {
        return {
          hash: x.data.hash,
          filetype: x.data.filetype,
          byteLength: x.data.byteLength
        };
      })
    });
    let count = 1;
    const promises = [];
    for (const queueItem of this.uploadQueue) {
      const checkFile = res == null ? void 0 : res.files.find((item) => item.hash === queueItem.data.hash && item.filetype === queueItem.data.filetype);
      if (checkFile == null ? void 0 : checkFile.url) {
        status.setStatus(`Uploading ${type} ${count++} of ${this.uploadQueue.length}...`);
        queueItem.callback(checkFile.url);
      } else {
        promises.push(new Promise((resolve) => {
          this.postRaw("/v1/file/upload", queueItem.data).then((res2) => {
            status.setStatus(`Uploading ${type} ${count++} of ${this.uploadQueue.length}...`);
            queueItem.callback(res2.url);
            resolve();
          }).catch((e2) => {
            console.log(e2);
            resolve();
          });
        }));
      }
    }
    await Promise.all(promises);
    this.uploadQueue = [];
    return res;
  }
  async upload(data) {
    const res = await this.postRaw("/v1/file/upload", data);
    return res.url;
  }
  async createNote(template, expiration) {
    const res = await this.post("/v1/file/create-note", {
      filename: template.filename,
      filetype: "html",
      hash: await sha1(template.content),
      expiration,
      template
    }, 3);
    return res.url;
  }
  async deleteSharedNote(shareUrl) {
    const url = parseExistingShareUrl(shareUrl);
    if (url) {
      await this.post("/v1/file/delete", {
        filename: url.filename,
        filetype: "html"
      });
      new StatusMessage("The note has been deleted \u{1F5D1}\uFE0F", 1 /* Info */);
    }
  }
};
function parseExistingShareUrl(url) {
  const match = url.match(/(\w+)(#.+?|)$/);
  if (match) {
    return {
      filename: match[1],
      decryptionKey: match[2].slice(1) || "",
      url
    };
  }
  return false;
}

// node_modules/csso/lib/syntax.js
var syntax_exports = {};
__export(syntax_exports, {
  compress: () => compress2,
  find: () => find2,
  findAll: () => findAll2,
  findLast: () => findLast2,
  fromPlainObject: () => fromPlainObject2,
  generate: () => generate43,
  lexer: () => lexer2,
  parse: () => parse43,
  specificity: () => specificity_default,
  toPlainObject: () => toPlainObject2,
  tokenize: () => tokenize3,
  walk: () => walk3
});

// node_modules/css-tree/lib/tokenizer/types.js
var types_exports = {};
__export(types_exports, {
  AtKeyword: () => AtKeyword,
  BadString: () => BadString,
  BadUrl: () => BadUrl,
  CDC: () => CDC,
  CDO: () => CDO,
  Colon: () => Colon,
  Comma: () => Comma,
  Comment: () => Comment,
  Delim: () => Delim,
  Dimension: () => Dimension,
  EOF: () => EOF,
  Function: () => Function,
  Hash: () => Hash,
  Ident: () => Ident,
  LeftCurlyBracket: () => LeftCurlyBracket,
  LeftParenthesis: () => LeftParenthesis,
  LeftSquareBracket: () => LeftSquareBracket,
  Number: () => Number2,
  Percentage: () => Percentage,
  RightCurlyBracket: () => RightCurlyBracket,
  RightParenthesis: () => RightParenthesis,
  RightSquareBracket: () => RightSquareBracket,
  Semicolon: () => Semicolon,
  String: () => String2,
  Url: () => Url,
  WhiteSpace: () => WhiteSpace
});
var EOF = 0;
var Ident = 1;
var Function = 2;
var AtKeyword = 3;
var Hash = 4;
var String2 = 5;
var BadString = 6;
var Url = 7;
var BadUrl = 8;
var Delim = 9;
var Number2 = 10;
var Percentage = 11;
var Dimension = 12;
var WhiteSpace = 13;
var CDO = 14;
var CDC = 15;
var Colon = 16;
var Semicolon = 17;
var Comma = 18;
var LeftSquareBracket = 19;
var RightSquareBracket = 20;
var LeftParenthesis = 21;
var RightParenthesis = 22;
var LeftCurlyBracket = 23;
var RightCurlyBracket = 24;
var Comment = 25;

// node_modules/css-tree/lib/tokenizer/char-code-definitions.js
var EOF2 = 0;
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isHexDigit(code2) {
  return isDigit(code2) || // 0 .. 9
  code2 >= 65 && code2 <= 70 || // A .. F
  code2 >= 97 && code2 <= 102;
}
function isUppercaseLetter(code2) {
  return code2 >= 65 && code2 <= 90;
}
function isLowercaseLetter(code2) {
  return code2 >= 97 && code2 <= 122;
}
function isLetter(code2) {
  return isUppercaseLetter(code2) || isLowercaseLetter(code2);
}
function isNonAscii(code2) {
  return code2 >= 128;
}
function isNameStart(code2) {
  return isLetter(code2) || isNonAscii(code2) || code2 === 95;
}
function isName(code2) {
  return isNameStart(code2) || isDigit(code2) || code2 === 45;
}
function isNonPrintable(code2) {
  return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
}
function isNewline(code2) {
  return code2 === 10 || code2 === 13 || code2 === 12;
}
function isWhiteSpace(code2) {
  return isNewline(code2) || code2 === 32 || code2 === 9;
}
function isValidEscape(first, second) {
  if (first !== 92) {
    return false;
  }
  if (isNewline(second) || second === EOF2) {
    return false;
  }
  return true;
}
function isIdentifierStart(first, second, third) {
  if (first === 45) {
    return isNameStart(second) || second === 45 || isValidEscape(second, third);
  }
  if (isNameStart(first)) {
    return true;
  }
  if (first === 92) {
    return isValidEscape(first, second);
  }
  return false;
}
function isNumberStart(first, second, third) {
  if (first === 43 || first === 45) {
    if (isDigit(second)) {
      return 2;
    }
    return second === 46 && isDigit(third) ? 3 : 0;
  }
  if (first === 46) {
    return isDigit(second) ? 2 : 0;
  }
  if (isDigit(first)) {
    return 1;
  }
  return 0;
}
function isBOM(code2) {
  if (code2 === 65279) {
    return 1;
  }
  if (code2 === 65534) {
    return 1;
  }
  return 0;
}
var CATEGORY = new Array(128);
var EofCategory = 128;
var WhiteSpaceCategory = 130;
var DigitCategory = 131;
var NameStartCategory = 132;
var NonPrintableCategory = 133;
for (let i2 = 0; i2 < CATEGORY.length; i2++) {
  CATEGORY[i2] = isWhiteSpace(i2) && WhiteSpaceCategory || isDigit(i2) && DigitCategory || isNameStart(i2) && NameStartCategory || isNonPrintable(i2) && NonPrintableCategory || i2 || EofCategory;
}
function charCodeCategory(code2) {
  return code2 < 128 ? CATEGORY[code2] : NameStartCategory;
}

// node_modules/css-tree/lib/tokenizer/utils.js
function getCharCode(source, offset) {
  return offset < source.length ? source.charCodeAt(offset) : 0;
}
function getNewlineLength(source, offset, code2) {
  if (code2 === 13 && getCharCode(source, offset + 1) === 10) {
    return 2;
  }
  return 1;
}
function cmpChar(testStr, offset, referenceCode) {
  let code2 = testStr.charCodeAt(offset);
  if (isUppercaseLetter(code2)) {
    code2 = code2 | 32;
  }
  return code2 === referenceCode;
}
function cmpStr(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }
  if (start < 0 || end > testStr.length) {
    return false;
  }
  for (let i2 = start; i2 < end; i2++) {
    const referenceCode = referenceStr.charCodeAt(i2 - start);
    let testCode = testStr.charCodeAt(i2);
    if (isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function findWhiteSpaceStart(source, offset) {
  for (; offset >= 0; offset--) {
    if (!isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset + 1;
}
function findWhiteSpaceEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset;
}
function findDecimalNumberEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isDigit(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset;
}
function consumeEscaped(source, offset) {
  offset += 2;
  if (isHexDigit(getCharCode(source, offset - 1))) {
    for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
      if (!isHexDigit(getCharCode(source, offset))) {
        break;
      }
    }
    const code2 = getCharCode(source, offset);
    if (isWhiteSpace(code2)) {
      offset += getNewlineLength(source, offset, code2);
    }
  }
  return offset;
}
function consumeName(source, offset) {
  for (; offset < source.length; offset++) {
    const code2 = source.charCodeAt(offset);
    if (isName(code2)) {
      continue;
    }
    if (isValidEscape(code2, getCharCode(source, offset + 1))) {
      offset = consumeEscaped(source, offset) - 1;
      continue;
    }
    break;
  }
  return offset;
}
function consumeNumber(source, offset) {
  let code2 = source.charCodeAt(offset);
  if (code2 === 43 || code2 === 45) {
    code2 = source.charCodeAt(offset += 1);
  }
  if (isDigit(code2)) {
    offset = findDecimalNumberEnd(source, offset + 1);
    code2 = source.charCodeAt(offset);
  }
  if (code2 === 46 && isDigit(source.charCodeAt(offset + 1))) {
    offset += 2;
    offset = findDecimalNumberEnd(source, offset);
  }
  if (cmpChar(
    source,
    offset,
    101
    /* e */
  )) {
    let sign = 0;
    code2 = source.charCodeAt(offset + 1);
    if (code2 === 45 || code2 === 43) {
      sign = 1;
      code2 = source.charCodeAt(offset + 2);
    }
    if (isDigit(code2)) {
      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
    }
  }
  return offset;
}
function consumeBadUrlRemnants(source, offset) {
  for (; offset < source.length; offset++) {
    const code2 = source.charCodeAt(offset);
    if (code2 === 41) {
      offset++;
      break;
    }
    if (isValidEscape(code2, getCharCode(source, offset + 1))) {
      offset = consumeEscaped(source, offset);
    }
  }
  return offset;
}
function decodeEscaped(escaped) {
  if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
    return escaped[0];
  }
  let code2 = parseInt(escaped, 16);
  if (code2 === 0 || // If this number is zero,
  code2 >= 55296 && code2 <= 57343 || // or is for a surrogate,
  code2 > 1114111) {
    code2 = 65533;
  }
  return String.fromCodePoint(code2);
}

// node_modules/css-tree/lib/tokenizer/names.js
var names_default = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token"
];

// node_modules/css-tree/lib/tokenizer/adopt-buffer.js
var MIN_SIZE = 16 * 1024;
function adoptBuffer(buffer = null, size) {
  if (buffer === null || buffer.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
  }
  return buffer;
}

// node_modules/css-tree/lib/tokenizer/OffsetToLocation.js
var N = 10;
var F = 12;
var R = 13;
function computeLinesAndColumns(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer(host.lines, sourceLength);
  const columns = adoptBuffer(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;
  for (let i2 = startOffset; i2 < sourceLength; i2++) {
    const code2 = source.charCodeAt(i2);
    lines[i2] = line;
    columns[i2] = column++;
    if (code2 === N || code2 === R || code2 === F) {
      if (code2 === R && i2 + 1 < sourceLength && source.charCodeAt(i2 + 1) === N) {
        i2++;
        lines[i2] = line;
        columns[i2] = column;
      }
      line++;
      column = 1;
    }
  }
  lines[sourceLength] = line;
  columns[sourceLength] = column;
  host.lines = lines;
  host.columns = columns;
  host.computed = true;
}
var OffsetToLocation = class {
  constructor() {
    this.lines = null;
    this.columns = null;
    this.computed = false;
  }
  setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      offset: this.startOffset + offset,
      line: this.lines[offset],
      column: this.columns[offset]
    };
  }
  getLocationRange(start, end, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start]
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end]
      }
    };
  }
};

// node_modules/css-tree/lib/tokenizer/TokenStream.js
var OFFSET_MASK = 16777215;
var TYPE_SHIFT = 24;
var balancePair = /* @__PURE__ */ new Map([
  [Function, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
var TokenStream = class {
  constructor(source, tokenize4) {
    this.setSource(source, tokenize4);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize4 = () => {
  }) {
    source = String(source || "");
    const sourceLength = source.length;
    const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
    const balance = adoptBuffer(this.balance, source.length + 1);
    let tokenCount = 0;
    let balanceCloseType = 0;
    let balanceStart = 0;
    let firstCharOffset = -1;
    this.offsetAndType = null;
    this.balance = null;
    tokenize4(source, (type, start, end) => {
      switch (type) {
        default:
          balance[tokenCount] = sourceLength;
          break;
        case balanceCloseType: {
          let balancePrev = balanceStart & OFFSET_MASK;
          balanceStart = balance[balancePrev];
          balanceCloseType = balanceStart >> TYPE_SHIFT;
          balance[tokenCount] = balancePrev;
          balance[balancePrev++] = tokenCount;
          for (; balancePrev < tokenCount; balancePrev++) {
            if (balance[balancePrev] === sourceLength) {
              balance[balancePrev] = tokenCount;
            }
          }
          break;
        }
        case LeftParenthesis:
        case Function:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balance[tokenCount] = balanceStart;
          balanceCloseType = balancePair.get(type);
          balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
          break;
      }
      offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start;
      }
    });
    offsetAndType[tokenCount] = EOF << TYPE_SHIFT | sourceLength;
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength;
    while (balanceStart !== 0) {
      const balancePrev = balanceStart & OFFSET_MASK;
      balanceStart = balance[balancePrev];
      balance[balancePrev] = sourceLength;
    }
    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;
    this.reset();
    this.next();
  }
  lookupType(offset) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return this.offsetAndType[offset] >> TYPE_SHIFT;
    }
    return EOF;
  }
  lookupOffset(offset) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return this.offsetAndType[offset - 1] & OFFSET_MASK;
    }
    return this.source.length;
  }
  lookupValue(offset, referenceStr) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return cmpStr(
        this.source,
        this.offsetAndType[offset - 1] & OFFSET_MASK,
        this.offsetAndType[offset] & OFFSET_MASK,
        referenceStr
      );
    }
    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }
    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }
    return this.firstCharOffset;
  }
  substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  }
  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code2, offset) {
    if (offset) {
      return this.lookupType(offset) === Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code2;
    }
    return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code2;
  }
  skip(tokenCount) {
    let next = this.tokenIndex + tokenCount;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next = this.tokenIndex + 1;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = EOF;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (this.tokenType === WhiteSpace || this.tokenType === Comment) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd;
    let offset;
    loop:
      for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor];
        if (balanceEnd < startToken) {
          break loop;
        }
        offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
        switch (stopConsume(this.source.charCodeAt(offset))) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            if (this.balance[balanceEnd] === cursor) {
              cursor = balanceEnd;
            }
        }
      }
    this.skip(cursor - this.tokenIndex);
  }
  forEachToken(fn) {
    for (let i2 = 0, offset = this.firstCharOffset; i2 < this.tokenCount; i2++) {
      const start = offset;
      const item = this.offsetAndType[i2];
      const end = item & OFFSET_MASK;
      const type = item >> TYPE_SHIFT;
      offset = end;
      fn(type, start, end, i2);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);
    this.forEachToken((type, start, end, index) => {
      tokens[index] = {
        idx: index,
        type: names_default[type],
        chunk: this.source.substring(start, end),
        balance: this.balance[index]
      };
    });
    return tokens;
  }
};

// node_modules/css-tree/lib/tokenizer/index.js
function tokenize(source, onToken) {
  function getCharCode2(offset2) {
    return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
  }
  function consumeNumericToken() {
    offset = consumeNumber(source, offset);
    if (isIdentifierStart(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
      type = Dimension;
      offset = consumeName(source, offset);
      return;
    }
    if (getCharCode2(offset) === 37) {
      type = Percentage;
      offset++;
      return;
    }
    type = Number2;
  }
  function consumeIdentLikeToken() {
    const nameStartOffset = offset;
    offset = consumeName(source, offset);
    if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
      offset = findWhiteSpaceEnd(source, offset + 1);
      if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
        type = Function;
        offset = nameStartOffset + 4;
        return;
      }
      consumeUrlToken();
      return;
    }
    if (getCharCode2(offset) === 40) {
      type = Function;
      offset++;
      return;
    }
    type = Ident;
  }
  function consumeStringToken(endingCodePoint) {
    if (!endingCodePoint) {
      endingCodePoint = getCharCode2(offset++);
    }
    type = String2;
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        case endingCodePoint:
          offset++;
          return;
        case WhiteSpaceCategory:
          if (isNewline(code2)) {
            offset += getNewlineLength(source, offset, code2);
            type = BadString;
            return;
          }
          break;
        case 92:
          if (offset === source.length - 1) {
            break;
          }
          const nextCode = getCharCode2(offset + 1);
          if (isNewline(nextCode)) {
            offset += getNewlineLength(source, offset + 1, nextCode);
          } else if (isValidEscape(code2, nextCode)) {
            offset = consumeEscaped(source, offset) - 1;
          }
          break;
      }
    }
  }
  function consumeUrlToken() {
    type = Url;
    offset = findWhiteSpaceEnd(source, offset);
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        case 41:
          offset++;
          return;
        case WhiteSpaceCategory:
          offset = findWhiteSpaceEnd(source, offset);
          if (getCharCode2(offset) === 41 || offset >= source.length) {
            if (offset < source.length) {
              offset++;
            }
            return;
          }
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
        case 34:
        case 39:
        case 40:
        case NonPrintableCategory:
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
        case 92:
          if (isValidEscape(code2, getCharCode2(offset + 1))) {
            offset = consumeEscaped(source, offset) - 1;
            break;
          }
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
      }
    }
  }
  source = String(source || "");
  const sourceLength = source.length;
  let start = isBOM(getCharCode2(0));
  let offset = start;
  let type;
  while (offset < sourceLength) {
    const code2 = source.charCodeAt(offset);
    switch (charCodeCategory(code2)) {
      case WhiteSpaceCategory:
        type = WhiteSpace;
        offset = findWhiteSpaceEnd(source, offset + 1);
        break;
      case 34:
        consumeStringToken();
        break;
      case 35:
        if (isName(getCharCode2(offset + 1)) || isValidEscape(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          type = Hash;
          offset = consumeName(source, offset + 1);
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 39:
        consumeStringToken();
        break;
      case 40:
        type = LeftParenthesis;
        offset++;
        break;
      case 41:
        type = RightParenthesis;
        offset++;
        break;
      case 43:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 44:
        type = Comma;
        offset++;
        break;
      case 45:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
            type = CDC;
            offset = offset + 3;
          } else {
            if (isIdentifierStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
              consumeIdentLikeToken();
            } else {
              type = Delim;
              offset++;
            }
          }
        }
        break;
      case 46:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 47:
        if (getCharCode2(offset + 1) === 42) {
          type = Comment;
          offset = source.indexOf("*/", offset + 2);
          offset = offset === -1 ? source.length : offset + 2;
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 58:
        type = Colon;
        offset++;
        break;
      case 59:
        type = Semicolon;
        offset++;
        break;
      case 60:
        if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
          type = CDO;
          offset = offset + 4;
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 64:
        if (isIdentifierStart(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
          type = AtKeyword;
          offset = consumeName(source, offset + 1);
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 91:
        type = LeftSquareBracket;
        offset++;
        break;
      case 92:
        if (isValidEscape(code2, getCharCode2(offset + 1))) {
          consumeIdentLikeToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      case 93:
        type = RightSquareBracket;
        offset++;
        break;
      case 123:
        type = LeftCurlyBracket;
        offset++;
        break;
      case 125:
        type = RightCurlyBracket;
        offset++;
        break;
      case DigitCategory:
        consumeNumericToken();
        break;
      case NameStartCategory:
        consumeIdentLikeToken();
        break;
      default:
        type = Delim;
        offset++;
    }
    onToken(type, start, start = offset);
  }
}

// node_modules/css-tree/lib/utils/List.js
var releasedCursors = null;
var List = class {
  static createItem(data) {
    return {
      prev: null,
      next: null,
      data
    };
  }
  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data) {
    return List.createItem(data);
  }
  // cursor helpers
  allocateCursor(prev, next) {
    let cursor;
    if (releasedCursors !== null) {
      cursor = releasedCursors;
      releasedCursors = releasedCursors.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next,
        cursor: this.cursor
      };
    }
    this.cursor = cursor;
    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;
    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors;
    releasedCursors = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;
    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }
      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }
      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }
  // getters
  get size() {
    let size = 0;
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      size++;
    }
    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  // convertors
  fromArray(array) {
    let cursor = null;
    this.head = null;
    for (let data of array) {
      const item = List.createItem(data);
      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }
      item.prev = cursor;
      cursor = item;
    }
    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  // array-like methods
  forEach(fn, thisArg = this) {
    const cursor = this.allocateCursor(null, this.head);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  forEachRight(fn, thisArg = this) {
    const cursor = this.allocateCursor(this.tail, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  reduce(fn, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;
    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;
      acc = fn.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  reduceRight(fn, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;
    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;
      acc = fn.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  some(fn, thisArg = this) {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }
    return false;
  }
  map(fn, thisArg = this) {
    const result = new List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      result.appendData(fn.call(thisArg, cursor.data, cursor, this));
    }
    return result;
  }
  filter(fn, thisArg = this) {
    const result = new List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }
    return result;
  }
  nextUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(null, start);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  prevUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(start, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  // mutation
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new List();
    for (let data of this) {
      result.appendData(data);
    }
    return result;
  }
  prepend(item) {
    this.updateCursors(null, item, this.head, item);
    if (this.head !== null) {
      this.head.prev = item;
      item.next = this.head;
    } else {
      this.tail = item;
    }
    this.head = item;
    return this;
  }
  prependData(data) {
    return this.prepend(List.createItem(data));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data) {
    return this.insert(List.createItem(data));
  }
  insert(item, before = null) {
    if (before !== null) {
      this.updateCursors(before.prev, item, before, item);
      if (before.prev === null) {
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      this.updateCursors(this.tail, item, null, item);
      if (this.tail !== null) {
        this.tail.next = item;
        item.prev = this.tail;
      } else {
        this.head = item;
      }
      this.tail = item;
    }
    return this;
  }
  insertData(data, before) {
    return this.insert(List.createItem(data), before);
  }
  remove(item) {
    this.updateCursors(item, item.prev, item, item.next);
    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.head = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.tail = item.prev;
    }
    item.prev = null;
    item.next = null;
    return item;
  }
  push(data) {
    this.insert(List.createItem(data));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data) {
    this.prepend(List.createItem(data));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list) {
    return this.insertList(list, this.head);
  }
  appendList(list) {
    return this.insertList(list);
  }
  insertList(list, before) {
    if (list.head === null) {
      return this;
    }
    if (before !== void 0 && before !== null) {
      this.updateCursors(before.prev, list.tail, before, list.head);
      if (before.prev !== null) {
        before.prev.next = list.head;
        list.head.prev = before.prev;
      } else {
        this.head = list.head;
      }
      before.prev = list.tail;
      list.tail.next = before;
    } else {
      this.updateCursors(this.tail, list.tail, null, list.head);
      if (this.tail !== null) {
        this.tail.next = list.head;
        list.head.prev = this.tail;
      } else {
        this.head = list.head;
      }
      this.tail = list.tail;
    }
    list.head = null;
    list.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }
    this.remove(oldItem);
  }
};

// node_modules/css-tree/lib/utils/create-custom-error.js
function createCustomError(name41, message) {
  const error = Object.create(SyntaxError.prototype);
  const errorStack = new Error();
  return Object.assign(error, {
    name: name41,
    message,
    get stack() {
      return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name41}: ${message}
`);
    }
  });
}

// node_modules/css-tree/lib/parser/SyntaxError.js
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = "    ";
function sourceFragment({ source, line, column }, extraLines) {
  function processLines(start, end) {
    return lines.slice(start, end).map(
      (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
    ).join("\n");
  }
  const lines = source.split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;
  column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }
  for (let i2 = startLine; i2 <= endLine; i2++) {
    if (i2 >= 0 && i2 < lines.length) {
      lines[i2] = lines[i2].replace(/\t/g, TAB_REPLACEMENT);
      lines[i2] = (cutLeft > 0 && lines[i2].length > cutLeft ? "\u2026" : "") + lines[i2].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i2].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
    }
  }
  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine)
  ].filter(Boolean).join("\n");
}
function SyntaxError2(message, source, offset, line, column) {
  const error = Object.assign(createCustomError("SyntaxError", message), {
    source,
    offset,
    line,
    column,
    sourceFragment(extraLines) {
      return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
    },
    get formattedMessage() {
      return `Parse error: ${message}
` + sourceFragment({ source, line, column }, 2);
    }
  });
  return error;
}

// node_modules/css-tree/lib/parser/sequence.js
function readSequence(recognizer) {
  const children = this.createList();
  let space = false;
  const context = {
    recognizer
  };
  while (!this.eof) {
    switch (this.tokenType) {
      case Comment:
        this.next();
        continue;
      case WhiteSpace:
        space = true;
        this.next();
        continue;
    }
    let child = recognizer.getNode.call(this, context);
    if (child === void 0) {
      break;
    }
    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context);
      }
      space = false;
    }
    children.push(child);
  }
  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context);
  }
  return children;
}

// node_modules/css-tree/lib/parser/create.js
var NOOP = () => {
};
var EXCLAMATIONMARK = 33;
var NUMBERSIGN = 35;
var SEMICOLON = 59;
var LEFTCURLYBRACKET = 123;
var NULL = 0;
function createParseContext(name41) {
  return function() {
    return this[name41]();
  };
}
function fetchParseValues(dict) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const name41 in dict) {
    const item = dict[name41];
    const fn = item.parse || item;
    if (fn) {
      result[name41] = fn;
    }
  }
  return result;
}
function processConfig(config) {
  const parseConfig = {
    context: /* @__PURE__ */ Object.create(null),
    scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
    atrule: fetchParseValues(config.atrule),
    pseudo: fetchParseValues(config.pseudo),
    node: fetchParseValues(config.node)
  };
  for (const name41 in config.parseContext) {
    switch (typeof config.parseContext[name41]) {
      case "function":
        parseConfig.context[name41] = config.parseContext[name41];
        break;
      case "string":
        parseConfig.context[name41] = createParseContext(config.parseContext[name41]);
        break;
    }
  }
  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node
  };
}
function createParser(config) {
  let source = "";
  let filename = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP;
  let onParseErrorThrow = false;
  const locationMap = new OffsetToLocation();
  const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence,
    consumeUntilBalanceEnd: () => 0,
    consumeUntilLeftCurlyBracket(code2) {
      return code2 === LEFTCURLYBRACKET ? 1 : 0;
    },
    consumeUntilLeftCurlyBracketOrSemicolon(code2) {
      return code2 === LEFTCURLYBRACKET || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilExclamationMarkOrSemicolon(code2) {
      return code2 === EXCLAMATIONMARK || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilSemicolonIncluded(code2) {
      return code2 === SEMICOLON ? 2 : 0;
    },
    createList() {
      return new List();
    },
    createSingleNodeList(node) {
      return new List().appendData(node);
    },
    getFirstListNode(list) {
      return list && list.first;
    },
    getLastListNode(list) {
      return list && list.last;
    },
    parseWithFallback(consumer, fallback) {
      const startToken = this.tokenIndex;
      try {
        return consumer.call(this);
      } catch (e2) {
        if (onParseErrorThrow) {
          throw e2;
        }
        const fallbackNode = fallback.call(this, startToken);
        onParseErrorThrow = true;
        onParseError(e2, fallbackNode);
        onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType(offset) {
      let type;
      do {
        type = this.lookupType(offset++);
        if (type !== WhiteSpace) {
          return type;
        }
      } while (type !== NULL);
      return NULL;
    },
    charCodeAt(offset) {
      return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
    },
    substring(offsetStart, offsetEnd) {
      return source.substring(offsetStart, offsetEnd);
    },
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    },
    cmpChar(offset, charCode) {
      return cmpChar(source, offset, charCode);
    },
    cmpStr(offsetStart, offsetEnd, str) {
      return cmpStr(source, offsetStart, offsetEnd, str);
    },
    consume(tokenType2) {
      const start = this.tokenStart;
      this.eat(tokenType2);
      return this.substrToCursor(start);
    },
    consumeFunctionName() {
      const name41 = source.substring(this.tokenStart, this.tokenEnd - 1);
      this.eat(Function);
      return name41;
    },
    consumeNumber(type) {
      const number2 = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
      this.eat(type);
      return number2;
    },
    eat(tokenType2) {
      if (this.tokenType !== tokenType2) {
        const tokenName = names_default[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
        let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
        let offset = this.tokenStart;
        switch (tokenType2) {
          case Ident:
            if (this.tokenType === Function || this.tokenType === Url) {
              offset = this.tokenEnd - 1;
              message = "Identifier is expected but function found";
            } else {
              message = "Identifier is expected";
            }
            break;
          case Hash:
            if (this.isDelim(NUMBERSIGN)) {
              this.next();
              offset++;
              message = "Name is expected";
            }
            break;
          case Percentage:
            if (this.tokenType === Number2) {
              offset = this.tokenEnd;
              message = "Percent sign is expected";
            }
            break;
        }
        this.error(message, offset);
      }
      this.next();
    },
    eatIdent(name41) {
      if (this.tokenType !== Ident || this.lookupValue(0, name41) === false) {
        this.error(`Identifier "${name41}" is expected`);
      }
      this.next();
    },
    eatDelim(code2) {
      if (!this.isDelim(code2)) {
        this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
      }
      this.next();
    },
    getLocation(start, end) {
      if (needPositions) {
        return locationMap.getLocationRange(
          start,
          end,
          filename
        );
      }
      return null;
    },
    getLocationFromList(list) {
      if (needPositions) {
        const head = this.getFirstListNode(list);
        const tail = this.getLastListNode(list);
        return locationMap.getLocationRange(
          head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
          tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
          filename
        );
      }
      return null;
    },
    error(message, offset) {
      const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
      throw new SyntaxError2(
        message || "Unexpected input",
        source,
        location.offset,
        location.line,
        location.column
      );
    }
  });
  const parse45 = function(source_, options) {
    source = source_;
    options = options || {};
    parser.setSource(source, tokenize);
    locationMap.setSource(
      source,
      options.offset,
      options.line,
      options.column
    );
    filename = options.filename || "<unknown>";
    needPositions = Boolean(options.positions);
    onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
    onParseErrorThrow = false;
    parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
    parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
    const { context = "default", onComment } = options;
    if (context in parser.context === false) {
      throw new Error("Unknown context `" + context + "`");
    }
    if (typeof onComment === "function") {
      parser.forEachToken((type, start, end) => {
        if (type === Comment) {
          const loc = parser.getLocation(start, end);
          const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
          onComment(value, loc);
        }
      });
    }
    const ast = parser.context[context].call(parser, options);
    if (!parser.eof) {
      parser.error();
    }
    return ast;
  };
  return Object.assign(parse45, {
    SyntaxError: SyntaxError2,
    config: parser.config
  });
}

// node_modules/css-tree/lib/generator/sourceMap.js
var import_source_map_generator = __toESM(require_source_map_generator(), 1);
var trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
function generateSourceMap(handlers4) {
  const map = new import_source_map_generator.SourceMapGenerator();
  const generated = {
    line: 1,
    column: 0
  };
  const original = {
    line: 0,
    // should be zero to add first mapping
    column: 0
  };
  const activatedGenerated = {
    line: 1,
    column: 0
  };
  const activatedMapping = {
    generated: activatedGenerated
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;
  const origHandlersNode = handlers4.node;
  handlers4.node = function(node) {
    if (node.loc && node.loc.start && trackNodes.has(node.type)) {
      const nodeLine = node.loc.start.line;
      const nodeColumn = node.loc.start.column - 1;
      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;
        generated.line = line;
        generated.column = column;
        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
            map.addMapping(activatedMapping);
          }
        }
        sourceMappingActive = true;
        map.addMapping({
          source: node.loc.source,
          original,
          generated
        });
      }
    }
    origHandlersNode.call(this, node);
    if (sourceMappingActive && trackNodes.has(node.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };
  const origHandlersEmit = handlers4.emit;
  handlers4.emit = function(value, type, auto) {
    for (let i2 = 0; i2 < value.length; i2++) {
      if (value.charCodeAt(i2) === 10) {
        line++;
        column = 0;
      } else {
        column++;
      }
    }
    origHandlersEmit(value, type, auto);
  };
  const origHandlersResult = handlers4.result;
  handlers4.result = function() {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }
    return {
      css: origHandlersResult(),
      map
    };
  };
  return handlers4;
}

// node_modules/css-tree/lib/generator/token-before.js
var token_before_exports = {};
__export(token_before_exports, {
  safe: () => safe,
  spec: () => spec
});
var PLUSSIGN = 43;
var HYPHENMINUS = 45;
var code = (type, value) => {
  if (type === Delim) {
    type = value;
  }
  if (typeof type === "string") {
    const charCode = type.charCodeAt(0);
    return charCode > 127 ? 32768 : charCode << 8;
  }
  return type;
};
var specPairs = [
  [Ident, Ident],
  [Ident, Function],
  [Ident, Url],
  [Ident, BadUrl],
  [Ident, "-"],
  [Ident, Number2],
  [Ident, Percentage],
  [Ident, Dimension],
  [Ident, CDC],
  [Ident, LeftParenthesis],
  [AtKeyword, Ident],
  [AtKeyword, Function],
  [AtKeyword, Url],
  [AtKeyword, BadUrl],
  [AtKeyword, "-"],
  [AtKeyword, Number2],
  [AtKeyword, Percentage],
  [AtKeyword, Dimension],
  [AtKeyword, CDC],
  [Hash, Ident],
  [Hash, Function],
  [Hash, Url],
  [Hash, BadUrl],
  [Hash, "-"],
  [Hash, Number2],
  [Hash, Percentage],
  [Hash, Dimension],
  [Hash, CDC],
  [Dimension, Ident],
  [Dimension, Function],
  [Dimension, Url],
  [Dimension, BadUrl],
  [Dimension, "-"],
  [Dimension, Number2],
  [Dimension, Percentage],
  [Dimension, Dimension],
  [Dimension, CDC],
  ["#", Ident],
  ["#", Function],
  ["#", Url],
  ["#", BadUrl],
  ["#", "-"],
  ["#", Number2],
  ["#", Percentage],
  ["#", Dimension],
  ["#", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["-", Ident],
  ["-", Function],
  ["-", Url],
  ["-", BadUrl],
  ["-", "-"],
  ["-", Number2],
  ["-", Percentage],
  ["-", Dimension],
  ["-", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [Number2, Ident],
  [Number2, Function],
  [Number2, Url],
  [Number2, BadUrl],
  [Number2, Number2],
  [Number2, Percentage],
  [Number2, Dimension],
  [Number2, "%"],
  [Number2, CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["@", Ident],
  ["@", Function],
  ["@", Url],
  ["@", BadUrl],
  ["@", "-"],
  ["@", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [".", Number2],
  [".", Percentage],
  [".", Dimension],
  ["+", Number2],
  ["+", Percentage],
  ["+", Dimension],
  ["/", "*"]
];
var safePairs = specPairs.concat([
  [Ident, Hash],
  [Dimension, Hash],
  [Hash, Hash],
  [AtKeyword, LeftParenthesis],
  [AtKeyword, String2],
  [AtKeyword, Colon],
  [Percentage, Percentage],
  [Percentage, Dimension],
  [Percentage, Function],
  [Percentage, "-"],
  [RightParenthesis, Ident],
  [RightParenthesis, Function],
  [RightParenthesis, Percentage],
  [RightParenthesis, Dimension],
  [RightParenthesis, Hash],
  [RightParenthesis, "-"]
]);
function createMap(pairs) {
  const isWhiteSpaceRequired = new Set(
    pairs.map(([prev, next]) => code(prev) << 16 | code(next))
  );
  return function(prevCode, type, value) {
    const nextCode = code(type, value);
    const nextCharCode = value.charCodeAt(0);
    const emitWs = nextCharCode === HYPHENMINUS && type !== Ident && type !== Function && type !== CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
    if (emitWs) {
      this.emit(" ", WhiteSpace, true);
    }
    return nextCode;
  };
}
var spec = createMap(specPairs);
var safe = createMap(safePairs);

// node_modules/css-tree/lib/generator/create.js
var REVERSESOLIDUS = 92;
function processChildren(node, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;
    node.children.forEach((node2) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }
      this.node(node2);
      prev = node2;
    });
    return;
  }
  node.children.forEach(this.node, this);
}
function processChunk(chunk) {
  tokenize(chunk, (type, start, end) => {
    this.token(type, chunk.slice(start, end));
  });
}
function createGenerator(config) {
  const types3 = /* @__PURE__ */ new Map();
  for (let name41 in config.node) {
    const item = config.node[name41];
    const fn = item.generate || item;
    if (typeof fn === "function") {
      types3.set(name41, item.generate || item);
    }
  }
  return function(node, options) {
    let buffer = "";
    let prevCode = 0;
    let handlers4 = {
      node(node2) {
        if (types3.has(node2.type)) {
          types3.get(node2.type).call(publicApi, node2);
        } else {
          throw new Error("Unknown node type: " + node2.type);
        }
      },
      tokenBefore: safe,
      token(type, value) {
        prevCode = this.tokenBefore(prevCode, type, value);
        this.emit(value, type, false);
        if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
          this.emit("\n", WhiteSpace, true);
        }
      },
      emit(value) {
        buffer += value;
      },
      result() {
        return buffer;
      }
    };
    if (options) {
      if (typeof options.decorator === "function") {
        handlers4 = options.decorator(handlers4);
      }
      if (options.sourceMap) {
        handlers4 = generateSourceMap(handlers4);
      }
      if (options.mode in token_before_exports) {
        handlers4.tokenBefore = token_before_exports[options.mode];
      }
    }
    const publicApi = {
      node: (node2) => handlers4.node(node2),
      children: processChildren,
      token: (type, value) => handlers4.token(type, value),
      tokenize: processChunk
    };
    handlers4.node(node);
    return handlers4.result();
  };
}

// node_modules/css-tree/lib/convertor/create.js
function createConvertor(walk4) {
  return {
    fromPlainObject(ast) {
      walk4(ast, {
        enter(node) {
          if (node.children && node.children instanceof List === false) {
            node.children = new List().fromArray(node.children);
          }
        }
      });
      return ast;
    },
    toPlainObject(ast) {
      walk4(ast, {
        leave(node) {
          if (node.children && node.children instanceof List) {
            node.children = node.children.toArray();
          }
        }
      });
      return ast;
    }
  };
}

// node_modules/css-tree/lib/walker/create.js
var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
var noop = function() {
};
function ensureFunction(value) {
  return typeof value === "function" ? value : noop;
}
function invokeForType(fn, type) {
  return function(node, item, list) {
    if (node.type === type) {
      fn.call(this, node, item, list);
    }
  };
}
function getWalkersFromStructure(name41, nodeType) {
  const structure41 = nodeType.structure;
  const walkers = [];
  for (const key in structure41) {
    if (hasOwnProperty2.call(structure41, key) === false) {
      continue;
    }
    let fieldTypes = structure41[key];
    const walker = {
      name: key,
      type: false,
      nullable: false
    };
    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }
    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }
    if (walker.type) {
      walkers.push(walker);
    }
  }
  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers
    };
  }
  return null;
}
function getTypesFromConfig(config) {
  const types3 = {};
  for (const name41 in config.node) {
    if (hasOwnProperty2.call(config.node, name41)) {
      const nodeType = config.node[name41];
      if (!nodeType.structure) {
        throw new Error("Missed `structure` field in `" + name41 + "` node type definition");
      }
      types3[name41] = getWalkersFromStructure(name41, nodeType);
    }
  }
  return types3;
}
function createTypeIterator(config, reverse) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";
  if (reverse) {
    fields.reverse();
  }
  return function(node, context, walk4, walkReducer) {
    let prevContextValue;
    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node;
    }
    for (const field of fields) {
      const ref = node[field.name];
      if (!field.nullable || ref) {
        if (field.type === "list") {
          const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
          if (breakWalk) {
            return true;
          }
        } else if (walk4(ref)) {
          return true;
        }
      }
    }
    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}
function createFastTraveralMap({
  StyleSheet,
  Atrule,
  Rule,
  Block,
  DeclarationList
}) {
  return {
    Atrule: {
      StyleSheet,
      Atrule,
      Rule,
      Block
    },
    Rule: {
      StyleSheet,
      Atrule,
      Rule,
      Block
    },
    Declaration: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
      DeclarationList
    }
  };
}
function createWalker(config) {
  const types3 = getTypesFromConfig(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");
  for (const name41 in types3) {
    if (hasOwnProperty2.call(types3, name41) && types3[name41] !== null) {
      iteratorsNatural[name41] = createTypeIterator(types3[name41], false);
      iteratorsReverse[name41] = createTypeIterator(types3[name41], true);
    }
  }
  const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
  const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
  const walk4 = function(root, options) {
    function walkNode(node, item, list) {
      const enterRet = enter.call(context, node, item, list);
      if (enterRet === breakWalk) {
        return true;
      }
      if (enterRet === skipNode) {
        return false;
      }
      if (iterators.hasOwnProperty(node.type)) {
        if (iterators[node.type](node, context, walkNode, walkReducer)) {
          return true;
        }
      }
      if (leave.call(context, node, item, list) === breakWalk) {
        return true;
      }
      return false;
    }
    let enter = noop;
    let leave = noop;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
    const context = {
      break: breakWalk,
      skip: skipNode,
      root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null
    };
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);
      if (options.reverse) {
        iterators = iteratorsReverse;
      }
      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
        } else if (!types3.hasOwnProperty(options.visit)) {
          throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types3).sort().join(", ") + ")");
        }
        enter = invokeForType(enter, options.visit);
        leave = invokeForType(leave, options.visit);
      }
    }
    if (enter === noop && leave === noop) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walkNode(root);
  };
  walk4.break = breakWalk;
  walk4.skip = skipNode;
  walk4.find = function(ast, fn) {
    let found = null;
    walk4(ast, function(node, item, list) {
      if (fn.call(this, node, item, list)) {
        found = node;
        return breakWalk;
      }
    });
    return found;
  };
  walk4.findLast = function(ast, fn) {
    let found = null;
    walk4(ast, {
      reverse: true,
      enter(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found = node;
          return breakWalk;
        }
      }
    });
    return found;
  };
  walk4.findAll = function(ast, fn) {
    const found = [];
    walk4(ast, function(node, item, list) {
      if (fn.call(this, node, item, list)) {
        found.push(node);
      }
    });
    return found;
  };
  return walk4;
}

// node_modules/css-tree/lib/definition-syntax/generate.js
function noop2(value) {
  return value;
}
function generateMultiplier(multiplier) {
  const { min, max, comma } = multiplier;
  if (min === 0 && max === 0) {
    return comma ? "#?" : "*";
  }
  if (min === 0 && max === 1) {
    return "?";
  }
  if (min === 1 && max === 0) {
    return comma ? "#" : "+";
  }
  if (min === 1 && max === 1) {
    return "";
  }
  return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
}
function generateTypeOpts(node) {
  switch (node.type) {
    case "Range":
      return " [" + (node.min === null ? "-\u221E" : node.min) + "," + (node.max === null ? "\u221E" : node.max) + "]";
    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
}
function generateSequence(node, decorate, forceBraces, compact) {
  const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
  const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
  if (node.explicit || forceBraces) {
    return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
  }
  return result;
}
function internalGenerate(node, decorate, forceBraces, compact) {
  let result;
  switch (node.type) {
    case "Group":
      result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
    case "Type":
      result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
      break;
    case "Property":
      result = "<'" + node.name + "'>";
      break;
    case "Keyword":
      result = node.name;
      break;
    case "AtKeyword":
      result = "@" + node.name;
      break;
    case "Function":
      result = node.name + "(";
      break;
    case "String":
    case "Token":
      result = node.value;
      break;
    case "Comma":
      result = ",";
      break;
    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
  return decorate(result, node);
}
function generate(node, options) {
  let decorate = noop2;
  let forceBraces = false;
  let compact = false;
  if (typeof options === "function") {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);
    if (typeof options.decorate === "function") {
      decorate = options.decorate;
    }
  }
  return internalGenerate(node, decorate, forceBraces, compact);
}

// node_modules/css-tree/lib/lexer/error.js
var defaultLoc = { offset: 0, line: 1, column: 1 };
function locateMismatch(matchResult, node) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start;
  let end;
  for (let i2 = 0; i2 < tokens.length; i2++) {
    const token = tokens[i2].value;
    if (i2 === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }
    if (badNode !== null && tokens[i2].node === badNode) {
      if (i2 <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }
    css += token;
  }
  if (longestMatch === tokens.length || entries > 1) {
    start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
    end = buildLoc(start);
  } else {
    start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
    end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
  }
  return {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  };
}
function fromLoc(node, point) {
  const value = node && node.loc && node.loc[point];
  if (value) {
    return "line" in value ? buildLoc(value) : value;
  }
  return null;
}
function buildLoc({ offset, line, column }, extra) {
  const loc = {
    offset,
    line,
    column
  };
  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);
    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }
  return loc;
}
var SyntaxReferenceError = function(type, referenceName) {
  const error = createCustomError(
    "SyntaxReferenceError",
    type + (referenceName ? " `" + referenceName + "`" : "")
  );
  error.reference = referenceName;
  return error;
};
var SyntaxMatchError = function(message, syntax, node, matchResult) {
  const error = createCustomError("SyntaxMatchError", message);
  const {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  } = locateMismatch(matchResult, node);
  error.rawMessage = message;
  error.syntax = syntax ? generate(syntax) : "<generic>";
  error.css = css;
  error.mismatchOffset = mismatchOffset;
  error.mismatchLength = mismatchLength;
  error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
  Object.assign(error, start);
  error.loc = {
    source: node && node.loc && node.loc.source || "<unknown>",
    start,
    end
  };
  return error;
};

// node_modules/css-tree/lib/utils/names.js
var keywords = /* @__PURE__ */ new Map();
var properties = /* @__PURE__ */ new Map();
var HYPHENMINUS2 = 45;
var keyword = getKeywordDescriptor;
var property = getPropertyDescriptor;
function isCustomProperty(str, offset) {
  offset = offset || 0;
  return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS2 && str.charCodeAt(offset + 1) === HYPHENMINUS2;
}
function getVendorPrefix(str, offset) {
  offset = offset || 0;
  if (str.length - offset >= 3) {
    if (str.charCodeAt(offset) === HYPHENMINUS2 && str.charCodeAt(offset + 1) !== HYPHENMINUS2) {
      const secondDashIndex = str.indexOf("-", offset + 2);
      if (secondDashIndex !== -1) {
        return str.substring(offset, secondDashIndex + 1);
      }
    }
  }
  return "";
}
function getKeywordDescriptor(keyword2) {
  if (keywords.has(keyword2)) {
    return keywords.get(keyword2);
  }
  const name41 = keyword2.toLowerCase();
  let descriptor = keywords.get(name41);
  if (descriptor === void 0) {
    const custom = isCustomProperty(name41, 0);
    const vendor = !custom ? getVendorPrefix(name41, 0) : "";
    descriptor = Object.freeze({
      basename: name41.substr(vendor.length),
      name: name41,
      prefix: vendor,
      vendor,
      custom
    });
  }
  keywords.set(keyword2, descriptor);
  return descriptor;
}
function getPropertyDescriptor(property2) {
  if (properties.has(property2)) {
    return properties.get(property2);
  }
  let name41 = property2;
  let hack = property2[0];
  if (hack === "/") {
    hack = property2[1] === "/" ? "//" : "/";
  } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
    hack = "";
  }
  const custom = isCustomProperty(name41, hack.length);
  if (!custom) {
    name41 = name41.toLowerCase();
    if (properties.has(name41)) {
      const descriptor2 = properties.get(name41);
      properties.set(property2, descriptor2);
      return descriptor2;
    }
  }
  const vendor = !custom ? getVendorPrefix(name41, hack.length) : "";
  const prefix = name41.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name41.substr(prefix.length),
    name: name41.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom
  });
  properties.set(property2, descriptor);
  return descriptor;
}

// node_modules/css-tree/lib/lexer/generic-const.js
var cssWideKeywords = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer"
];

// node_modules/css-tree/lib/lexer/generic-an-plus-b.js
var PLUSSIGN2 = 43;
var HYPHENMINUS3 = 45;
var N2 = 110;
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;
function isDelim(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function skipSC(token, offset, getNextToken) {
  while (token !== null && (token.type === WhiteSpace || token.type === Comment)) {
    token = getNextToken(++offset);
  }
  return offset;
}
function checkInteger(token, valueOffset, disallowSign, offset) {
  if (!token) {
    return 0;
  }
  const code2 = token.value.charCodeAt(valueOffset);
  if (code2 === PLUSSIGN2 || code2 === HYPHENMINUS3) {
    if (disallowSign) {
      return 0;
    }
    valueOffset++;
  }
  for (; valueOffset < token.value.length; valueOffset++) {
    if (!isDigit(token.value.charCodeAt(valueOffset))) {
      return 0;
    }
  }
  return offset + 1;
}
function consumeB(token, offset_, getNextToken) {
  let sign = false;
  let offset = skipSC(token, offset_, getNextToken);
  token = getNextToken(offset);
  if (token === null) {
    return offset_;
  }
  if (token.type !== Number2) {
    if (isDelim(token, PLUSSIGN2) || isDelim(token, HYPHENMINUS3)) {
      sign = true;
      offset = skipSC(getNextToken(++offset), offset, getNextToken);
      token = getNextToken(offset);
      if (token === null || token.type !== Number2) {
        return 0;
      }
    } else {
      return offset_;
    }
  }
  if (!sign) {
    const code2 = token.value.charCodeAt(0);
    if (code2 !== PLUSSIGN2 && code2 !== HYPHENMINUS3) {
      return 0;
    }
  }
  return checkInteger(token, sign ? 0 : 1, sign, offset);
}
function anPlusB(token, getNextToken) {
  let offset = 0;
  if (!token) {
    return 0;
  }
  if (token.type === Number2) {
    return checkInteger(token, 0, ALLOW_SIGN, offset);
  } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS3) {
    if (!cmpChar(token.value, 1, N2)) {
      return 0;
    }
    switch (token.value.length) {
      case 2:
        return consumeB(getNextToken(++offset), offset, getNextToken);
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
          return 0;
        }
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger(token, 0, DISALLOW_SIGN, offset);
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
          return 0;
        }
        return checkInteger(token, 3, DISALLOW_SIGN, offset);
    }
  } else if (token.type === Ident || isDelim(token, PLUSSIGN2) && getNextToken(offset + 1).type === Ident) {
    if (token.type !== Ident) {
      token = getNextToken(++offset);
    }
    if (token === null || !cmpChar(token.value, 0, N2)) {
      return 0;
    }
    switch (token.value.length) {
      case 1:
        return consumeB(getNextToken(++offset), offset, getNextToken);
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
          return 0;
        }
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger(token, 0, DISALLOW_SIGN, offset);
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
          return 0;
        }
        return checkInteger(token, 2, DISALLOW_SIGN, offset);
    }
  } else if (token.type === Dimension) {
    let code2 = token.value.charCodeAt(0);
    let sign = code2 === PLUSSIGN2 || code2 === HYPHENMINUS3 ? 1 : 0;
    let i2 = sign;
    for (; i2 < token.value.length; i2++) {
      if (!isDigit(token.value.charCodeAt(i2))) {
        break;
      }
    }
    if (i2 === sign) {
      return 0;
    }
    if (!cmpChar(token.value, i2, N2)) {
      return 0;
    }
    if (i2 + 1 === token.value.length) {
      return consumeB(getNextToken(++offset), offset, getNextToken);
    } else {
      if (token.value.charCodeAt(i2 + 1) !== HYPHENMINUS3) {
        return 0;
      }
      if (i2 + 2 === token.value.length) {
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger(token, 0, DISALLOW_SIGN, offset);
      } else {
        return checkInteger(token, i2 + 2, DISALLOW_SIGN, offset);
      }
    }
  }
  return 0;
}

// node_modules/css-tree/lib/lexer/generic-urange.js
var PLUSSIGN3 = 43;
var HYPHENMINUS4 = 45;
var QUESTIONMARK = 63;
var U = 117;
function isDelim2(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function startsWith(token, code2) {
  return token.value.charCodeAt(0) === code2;
}
function hexSequence(token, offset, allowDash) {
  let hexlen = 0;
  for (let pos = offset; pos < token.value.length; pos++) {
    const code2 = token.value.charCodeAt(pos);
    if (code2 === HYPHENMINUS4 && allowDash && hexlen !== 0) {
      hexSequence(token, offset + hexlen + 1, false);
      return 6;
    }
    if (!isHexDigit(code2)) {
      return 0;
    }
    if (++hexlen > 6) {
      return 0;
    }
    ;
  }
  return hexlen;
}
function withQuestionMarkSequence(consumed, length, getNextToken) {
  if (!consumed) {
    return 0;
  }
  while (isDelim2(getNextToken(length), QUESTIONMARK)) {
    if (++consumed > 6) {
      return 0;
    }
    length++;
  }
  return length;
}
function urange(token, getNextToken) {
  let length = 0;
  if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U)) {
    return 0;
  }
  token = getNextToken(++length);
  if (token === null) {
    return 0;
  }
  if (isDelim2(token, PLUSSIGN3)) {
    token = getNextToken(++length);
    if (token === null) {
      return 0;
    }
    if (token.type === Ident) {
      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
    }
    if (isDelim2(token, QUESTIONMARK)) {
      return withQuestionMarkSequence(1, ++length, getNextToken);
    }
    return 0;
  }
  if (token.type === Number2) {
    const consumedHexLength = hexSequence(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }
    token = getNextToken(++length);
    if (token === null) {
      return length;
    }
    if (token.type === Dimension || token.type === Number2) {
      if (!startsWith(token, HYPHENMINUS4) || !hexSequence(token, 1, false)) {
        return 0;
      }
      return length + 1;
    }
    return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
  }
  if (token.type === Dimension) {
    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
  }
  return 0;
}

// node_modules/css-tree/lib/lexer/generic.js
var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
var balancePair2 = /* @__PURE__ */ new Map([
  [Function, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
var LENGTH = [
  // absolute length units https://www.w3.org/TR/css-values-3/#lengths
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
var ANGLE = ["deg", "grad", "rad", "turn"];
var TIME = ["s", "ms"];
var FREQUENCY = ["hz", "khz"];
var RESOLUTION = ["dpi", "dpcm", "dppx", "x"];
var FLEX = ["fr"];
var DECIBEL = ["db"];
var SEMITONES = ["st"];
function charCodeAt(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}
function eqStr(actual, expected) {
  return cmpStr(actual, 0, actual.length, expected);
}
function eqStrAny(actual, expected) {
  for (let i2 = 0; i2 < expected.length; i2++) {
    if (eqStr(actual, expected[i2])) {
      return true;
    }
  }
  return false;
}
function isPostfixIeHack(str, offset) {
  if (offset !== str.length - 2) {
    return false;
  }
  return charCodeAt(str, offset) === 92 && // U+005C REVERSE SOLIDUS (\)
  isDigit(charCodeAt(str, offset + 1));
}
function outOfRange(opts, value, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(
      numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
    );
    if (isNaN(num)) {
      return true;
    }
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }
  return false;
}
function consumeFunction(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;
  scan:
    do {
      switch (token.type) {
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          if (balanceStash.length === 0) {
            length++;
            break scan;
          }
          break;
        case Function:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length++;
    } while (token = getNextToken(length));
  return length;
}
function calc(next) {
  return function(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    if (token.type === Function && eqStrAny(token.value, calcFunctionNames)) {
      return consumeFunction(token, getNextToken);
    }
    return next(token, getNextToken, opts);
  };
}
function tokenType(expectedTokenType) {
  return function(token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }
    return 1;
  };
}
function customIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  const name41 = token.value.toLowerCase();
  if (eqStrAny(name41, cssWideKeywords)) {
    return 0;
  }
  if (eqStr(name41, "default")) {
    return 0;
  }
  return 1;
}
function customPropertyName(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
    return 0;
  }
  return 1;
}
function hexColor(token) {
  if (token === null || token.type !== Hash) {
    return 0;
  }
  const length = token.value.length;
  if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
    return 0;
  }
  for (let i2 = 1; i2 < length; i2++) {
    if (!isHexDigit(charCodeAt(token.value, i2))) {
      return 0;
    }
  }
  return 1;
}
function idSelector(token) {
  if (token === null || token.type !== Hash) {
    return 0;
  }
  if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
    return 0;
  }
  return 1;
}
function declarationValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Semicolon:
          if (balanceCloseType === 0) {
            break scan;
          }
          break;
        case Delim:
          if (balanceCloseType === 0 && token.value === "!") {
            break scan;
          }
          break;
        case Function:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length++;
    } while (token = getNextToken(length));
  return length;
}
function anyValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Function:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length++;
    } while (token = getNextToken(length));
  return length;
}
function dimension(type) {
  if (type) {
    type = new Set(type);
  }
  return function(token, getNextToken, opts) {
    if (token === null || token.type !== Dimension) {
      return 0;
    }
    const numberEnd = consumeNumber(token.value, 0);
    if (type !== null) {
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
      if (type.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  };
}
function percentage(token, getNextToken, opts) {
  if (token === null || token.type !== Percentage) {
    return 0;
  }
  if (outOfRange(opts, token.value, token.value.length - 1)) {
    return 0;
  }
  return 1;
}
function zero(next) {
  if (typeof next !== "function") {
    next = function() {
      return 0;
    };
  }
  return function(token, getNextToken, opts) {
    if (token !== null && token.type === Number2) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }
    return next(token, getNextToken, opts);
  };
}
function number(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }
  const numberEnd = consumeNumber(token.value, 0);
  const isNumber = numberEnd === token.value.length;
  if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
    return 0;
  }
  if (outOfRange(opts, token.value, numberEnd)) {
    return 0;
  }
  return 1;
}
function integer(token, getNextToken, opts) {
  if (token === null || token.type !== Number2) {
    return 0;
  }
  let i2 = charCodeAt(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
  charCodeAt(token.value, 0) === 45 ? 1 : 0;
  for (; i2 < token.value.length; i2++) {
    if (!isDigit(charCodeAt(token.value, i2))) {
      return 0;
    }
  }
  if (outOfRange(opts, token.value, i2)) {
    return 0;
  }
  return 1;
}
var generic_default = {
  // token types
  "ident-token": tokenType(Ident),
  "function-token": tokenType(Function),
  "at-keyword-token": tokenType(AtKeyword),
  "hash-token": tokenType(Hash),
  "string-token": tokenType(String2),
  "bad-string-token": tokenType(BadString),
  "url-token": tokenType(Url),
  "bad-url-token": tokenType(BadUrl),
  "delim-token": tokenType(Delim),
  "number-token": tokenType(Number2),
  "percentage-token": tokenType(Percentage),
  "dimension-token": tokenType(Dimension),
  "whitespace-token": tokenType(WhiteSpace),
  "CDO-token": tokenType(CDO),
  "CDC-token": tokenType(CDC),
  "colon-token": tokenType(Colon),
  "semicolon-token": tokenType(Semicolon),
  "comma-token": tokenType(Comma),
  "[-token": tokenType(LeftSquareBracket),
  "]-token": tokenType(RightSquareBracket),
  "(-token": tokenType(LeftParenthesis),
  ")-token": tokenType(RightParenthesis),
  "{-token": tokenType(LeftCurlyBracket),
  "}-token": tokenType(RightCurlyBracket),
  // token type aliases
  "string": tokenType(String2),
  "ident": tokenType(Ident),
  // complex types
  "custom-ident": customIdent,
  "custom-property-name": customPropertyName,
  "hex-color": hexColor,
  "id-selector": idSelector,
  // element( <id-selector> )
  "an-plus-b": anPlusB,
  "urange": urange,
  "declaration-value": declarationValue,
  "any-value": anyValue,
  // dimensions
  "dimension": calc(dimension(null)),
  "angle": calc(dimension(ANGLE)),
  "decibel": calc(dimension(DECIBEL)),
  "frequency": calc(dimension(FREQUENCY)),
  "flex": calc(dimension(FLEX)),
  "length": calc(zero(dimension(LENGTH))),
  "resolution": calc(dimension(RESOLUTION)),
  "semitones": calc(dimension(SEMITONES)),
  "time": calc(dimension(TIME)),
  // percentage
  "percentage": calc(percentage),
  // numeric
  "zero": zero(),
  "number": calc(number),
  "integer": calc(integer)
};

// node_modules/css-tree/lib/definition-syntax/index.js
var definition_syntax_exports = {};
__export(definition_syntax_exports, {
  SyntaxError: () => SyntaxError3,
  generate: () => generate,
  parse: () => parse,
  walk: () => walk
});

// node_modules/css-tree/lib/definition-syntax/SyntaxError.js
function SyntaxError3(message, input, offset) {
  return Object.assign(createCustomError("SyntaxError", message), {
    input,
    offset,
    rawMessage: message,
    message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
  });
}

// node_modules/css-tree/lib/definition-syntax/tokenizer.js
var TAB = 9;
var N3 = 10;
var F2 = 12;
var R2 = 13;
var SPACE = 32;
var Tokenizer = class {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      const code2 = this.str.charCodeAt(pos);
      if (code2 !== R2 && code2 !== N3 && code2 !== F2 && code2 !== SPACE && code2 !== TAB) {
        break;
      }
    }
    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, this.pos = end);
  }
  eat(code2) {
    if (this.charCode() !== code2) {
      this.error("Expect `" + String.fromCharCode(code2) + "`");
    }
    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError3(message, this.str, this.pos);
  }
};

// node_modules/css-tree/lib/definition-syntax/parse.js
var TAB2 = 9;
var N4 = 10;
var F3 = 12;
var R3 = 13;
var SPACE2 = 32;
var EXCLAMATIONMARK2 = 33;
var NUMBERSIGN2 = 35;
var AMPERSAND = 38;
var APOSTROPHE = 39;
var LEFTPARENTHESIS = 40;
var RIGHTPARENTHESIS = 41;
var ASTERISK = 42;
var PLUSSIGN4 = 43;
var COMMA = 44;
var HYPERMINUS = 45;
var LESSTHANSIGN = 60;
var GREATERTHANSIGN = 62;
var QUESTIONMARK2 = 63;
var COMMERCIALAT = 64;
var LEFTSQUAREBRACKET = 91;
var RIGHTSQUAREBRACKET = 93;
var LEFTCURLYBRACKET2 = 123;
var VERTICALLINE = 124;
var RIGHTCURLYBRACKET = 125;
var INFINITY = 8734;
var NAME_CHAR = new Uint8Array(128).map(
  (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
var COMBINATOR_PRECEDENCE = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4
};
function scanSpaces(tokenizer) {
  return tokenizer.substringToPos(
    tokenizer.findWsEnd(tokenizer.pos)
  );
}
function scanWord(tokenizer) {
  let end = tokenizer.pos;
  for (; end < tokenizer.str.length; end++) {
    const code2 = tokenizer.str.charCodeAt(end);
    if (code2 >= 128 || NAME_CHAR[code2] === 0) {
      break;
    }
  }
  if (tokenizer.pos === end) {
    tokenizer.error("Expect a keyword");
  }
  return tokenizer.substringToPos(end);
}
function scanNumber(tokenizer) {
  let end = tokenizer.pos;
  for (; end < tokenizer.str.length; end++) {
    const code2 = tokenizer.str.charCodeAt(end);
    if (code2 < 48 || code2 > 57) {
      break;
    }
  }
  if (tokenizer.pos === end) {
    tokenizer.error("Expect a number");
  }
  return tokenizer.substringToPos(end);
}
function scanString(tokenizer) {
  const end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
  if (end === -1) {
    tokenizer.pos = tokenizer.str.length;
    tokenizer.error("Expect an apostrophe");
  }
  return tokenizer.substringToPos(end + 1);
}
function readMultiplierRange(tokenizer) {
  let min = null;
  let max = null;
  tokenizer.eat(LEFTCURLYBRACKET2);
  min = scanNumber(tokenizer);
  if (tokenizer.charCode() === COMMA) {
    tokenizer.pos++;
    if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
      max = scanNumber(tokenizer);
    }
  } else {
    max = min;
  }
  tokenizer.eat(RIGHTCURLYBRACKET);
  return {
    min: Number(min),
    max: max ? Number(max) : 0
  };
}
function readMultiplier(tokenizer) {
  let range = null;
  let comma = false;
  switch (tokenizer.charCode()) {
    case ASTERISK:
      tokenizer.pos++;
      range = {
        min: 0,
        max: 0
      };
      break;
    case PLUSSIGN4:
      tokenizer.pos++;
      range = {
        min: 1,
        max: 0
      };
      break;
    case QUESTIONMARK2:
      tokenizer.pos++;
      range = {
        min: 0,
        max: 1
      };
      break;
    case NUMBERSIGN2:
      tokenizer.pos++;
      comma = true;
      if (tokenizer.charCode() === LEFTCURLYBRACKET2) {
        range = readMultiplierRange(tokenizer);
      } else if (tokenizer.charCode() === QUESTIONMARK2) {
        tokenizer.pos++;
        range = {
          min: 0,
          max: 0
        };
      } else {
        range = {
          min: 1,
          max: 0
        };
      }
      break;
    case LEFTCURLYBRACKET2:
      range = readMultiplierRange(tokenizer);
      break;
    default:
      return null;
  }
  return {
    type: "Multiplier",
    comma,
    min: range.min,
    max: range.max,
    term: null
  };
}
function maybeMultiplied(tokenizer, node) {
  const multiplier = readMultiplier(tokenizer);
  if (multiplier !== null) {
    multiplier.term = node;
    if (tokenizer.charCode() === NUMBERSIGN2 && tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN4) {
      return maybeMultiplied(tokenizer, multiplier);
    }
    return multiplier;
  }
  return node;
}
function maybeToken(tokenizer) {
  const ch = tokenizer.peek();
  if (ch === "") {
    return null;
  }
  return {
    type: "Token",
    value: ch
  };
}
function readProperty(tokenizer) {
  let name41;
  tokenizer.eat(LESSTHANSIGN);
  tokenizer.eat(APOSTROPHE);
  name41 = scanWord(tokenizer);
  tokenizer.eat(APOSTROPHE);
  tokenizer.eat(GREATERTHANSIGN);
  return maybeMultiplied(tokenizer, {
    type: "Property",
    name: name41
  });
}
function readTypeRange(tokenizer) {
  let min = null;
  let max = null;
  let sign = 1;
  tokenizer.eat(LEFTSQUAREBRACKET);
  if (tokenizer.charCode() === HYPERMINUS) {
    tokenizer.peek();
    sign = -1;
  }
  if (sign == -1 && tokenizer.charCode() === INFINITY) {
    tokenizer.peek();
  } else {
    min = sign * Number(scanNumber(tokenizer));
    if (NAME_CHAR[tokenizer.charCode()] !== 0) {
      min += scanWord(tokenizer);
    }
  }
  scanSpaces(tokenizer);
  tokenizer.eat(COMMA);
  scanSpaces(tokenizer);
  if (tokenizer.charCode() === INFINITY) {
    tokenizer.peek();
  } else {
    sign = 1;
    if (tokenizer.charCode() === HYPERMINUS) {
      tokenizer.peek();
      sign = -1;
    }
    max = sign * Number(scanNumber(tokenizer));
    if (NAME_CHAR[tokenizer.charCode()] !== 0) {
      max += scanWord(tokenizer);
    }
  }
  tokenizer.eat(RIGHTSQUAREBRACKET);
  return {
    type: "Range",
    min,
    max
  };
}
function readType(tokenizer) {
  let name41;
  let opts = null;
  tokenizer.eat(LESSTHANSIGN);
  name41 = scanWord(tokenizer);
  if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
    tokenizer.pos += 2;
    name41 += "()";
  }
  if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
    scanSpaces(tokenizer);
    opts = readTypeRange(tokenizer);
  }
  tokenizer.eat(GREATERTHANSIGN);
  return maybeMultiplied(tokenizer, {
    type: "Type",
    name: name41,
    opts
  });
}
function readKeywordOrFunction(tokenizer) {
  const name41 = scanWord(tokenizer);
  if (tokenizer.charCode() === LEFTPARENTHESIS) {
    tokenizer.pos++;
    return {
      type: "Function",
      name: name41
    };
  }
  return maybeMultiplied(tokenizer, {
    type: "Keyword",
    name: name41
  });
}
function regroupTerms(terms, combinators) {
  function createGroup(terms2, combinator2) {
    return {
      type: "Group",
      terms: terms2,
      combinator: combinator2,
      disallowEmpty: false,
      explicit: false
    };
  }
  let combinator;
  combinators = Object.keys(combinators).sort((a2, b) => COMBINATOR_PRECEDENCE[a2] - COMBINATOR_PRECEDENCE[b]);
  while (combinators.length > 0) {
    combinator = combinators.shift();
    let i2 = 0;
    let subgroupStart = 0;
    for (; i2 < terms.length; i2++) {
      const term = terms[i2];
      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i2 - 1;
          }
          terms.splice(i2, 1);
          i2--;
        } else {
          if (subgroupStart !== -1 && i2 - subgroupStart > 1) {
            terms.splice(
              subgroupStart,
              i2 - subgroupStart,
              createGroup(terms.slice(subgroupStart, i2), combinator)
            );
            i2 = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }
    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(
        subgroupStart,
        i2 - subgroupStart,
        createGroup(terms.slice(subgroupStart, i2), combinator)
      );
    }
  }
  return combinator;
}
function readImplicitGroup(tokenizer) {
  const terms = [];
  const combinators = {};
  let token;
  let prevToken = null;
  let prevTokenPos = tokenizer.pos;
  while (token = peek(tokenizer)) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        if (prevToken === null || prevToken.type === "Combinator") {
          tokenizer.pos = prevTokenPos;
          tokenizer.error("Unexpected combinator");
        }
        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true;
        terms.push({
          type: "Combinator",
          value: " "
        });
      }
      terms.push(token);
      prevToken = token;
      prevTokenPos = tokenizer.pos;
    }
  }
  if (prevToken !== null && prevToken.type === "Combinator") {
    tokenizer.pos -= prevTokenPos;
    tokenizer.error("Unexpected combinator");
  }
  return {
    type: "Group",
    terms,
    combinator: regroupTerms(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false
  };
}
function readGroup(tokenizer) {
  let result;
  tokenizer.eat(LEFTSQUAREBRACKET);
  result = readImplicitGroup(tokenizer);
  tokenizer.eat(RIGHTSQUAREBRACKET);
  result.explicit = true;
  if (tokenizer.charCode() === EXCLAMATIONMARK2) {
    tokenizer.pos++;
    result.disallowEmpty = true;
  }
  return result;
}
function peek(tokenizer) {
  let code2 = tokenizer.charCode();
  if (code2 < 128 && NAME_CHAR[code2] === 1) {
    return readKeywordOrFunction(tokenizer);
  }
  switch (code2) {
    case RIGHTSQUAREBRACKET:
      break;
    case LEFTSQUAREBRACKET:
      return maybeMultiplied(tokenizer, readGroup(tokenizer));
    case LESSTHANSIGN:
      return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);
    case VERTICALLINE:
      return {
        type: "Combinator",
        value: tokenizer.substringToPos(
          tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE ? 2 : 1)
        )
      };
    case AMPERSAND:
      tokenizer.pos++;
      tokenizer.eat(AMPERSAND);
      return {
        type: "Combinator",
        value: "&&"
      };
    case COMMA:
      tokenizer.pos++;
      return {
        type: "Comma"
      };
    case APOSTROPHE:
      return maybeMultiplied(tokenizer, {
        type: "String",
        value: scanString(tokenizer)
      });
    case SPACE2:
    case TAB2:
    case N4:
    case R3:
    case F3:
      return {
        type: "Spaces",
        value: scanSpaces(tokenizer)
      };
    case COMMERCIALAT:
      code2 = tokenizer.nextCharCode();
      if (code2 < 128 && NAME_CHAR[code2] === 1) {
        tokenizer.pos++;
        return {
          type: "AtKeyword",
          name: scanWord(tokenizer)
        };
      }
      return maybeToken(tokenizer);
    case ASTERISK:
    case PLUSSIGN4:
    case QUESTIONMARK2:
    case NUMBERSIGN2:
    case EXCLAMATIONMARK2:
      break;
    case LEFTCURLYBRACKET2:
      code2 = tokenizer.nextCharCode();
      if (code2 < 48 || code2 > 57) {
        return maybeToken(tokenizer);
      }
      break;
    default:
      return maybeToken(tokenizer);
  }
}
function parse(source) {
  const tokenizer = new Tokenizer(source);
  const result = readImplicitGroup(tokenizer);
  if (tokenizer.pos !== source.length) {
    tokenizer.error("Unexpected input");
  }
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }
  return result;
}

// node_modules/css-tree/lib/definition-syntax/walk.js
var noop3 = function() {
};
function ensureFunction2(value) {
  return typeof value === "function" ? value : noop3;
}
function walk(node, options, context) {
  function walk4(node2) {
    enter.call(context, node2);
    switch (node2.type) {
      case "Group":
        node2.terms.forEach(walk4);
        break;
      case "Multiplier":
        walk4(node2.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + node2.type);
    }
    leave.call(context, node2);
  }
  let enter = noop3;
  let leave = noop3;
  if (typeof options === "function") {
    enter = options;
  } else if (options) {
    enter = ensureFunction2(options.enter);
    leave = ensureFunction2(options.leave);
  }
  if (enter === noop3 && leave === noop3) {
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  }
  walk4(node, context);
}

// node_modules/css-tree/lib/lexer/prepare-tokens.js
var astToTokens = {
  decorator(handlers4) {
    const tokens = [];
    let curNode = null;
    return {
      ...handlers4,
      node(node) {
        const tmp = curNode;
        curNode = node;
        handlers4.node.call(this, node);
        curNode = tmp;
      },
      emit(value, type, auto) {
        tokens.push({
          type,
          value,
          node: auto ? null : curNode
        });
      },
      result() {
        return tokens;
      }
    };
  }
};
function stringToTokens(str) {
  const tokens = [];
  tokenize(
    str,
    (type, start, end) => tokens.push({
      type,
      value: str.slice(start, end),
      node: null
    })
  );
  return tokens;
}
function prepare_tokens_default(value, syntax) {
  if (typeof value === "string") {
    return stringToTokens(value);
  }
  return syntax.generate(value, astToTokens);
}

// node_modules/css-tree/lib/lexer/match-graph.js
var MATCH = { type: "Match" };
var MISMATCH = { type: "Mismatch" };
var DISALLOW_EMPTY = { type: "DisallowEmpty" };
var LEFTPARENTHESIS2 = 40;
var RIGHTPARENTHESIS2 = 41;
function createCondition(match, thenBranch, elseBranch) {
  if (thenBranch === MATCH && elseBranch === MISMATCH) {
    return match;
  }
  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    return match;
  }
  if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
    thenBranch = match.then;
    match = match.match;
  }
  return {
    type: "If",
    match,
    then: thenBranch,
    else: elseBranch
  };
}
function isFunctionType(name41) {
  return name41.length > 2 && name41.charCodeAt(name41.length - 2) === LEFTPARENTHESIS2 && name41.charCodeAt(name41.length - 1) === RIGHTPARENTHESIS2;
}
function isEnumCapatible(term) {
  return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
}
function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      let result = MATCH;
      for (let i2 = terms.length - 1; i2 >= 0; i2--) {
        const term = terms[i2];
        result = createCondition(
          term,
          result,
          MISMATCH
        );
      }
      ;
      return result;
    }
    case "|": {
      let result = MISMATCH;
      let map = null;
      for (let i2 = terms.length - 1; i2 >= 0; i2--) {
        let term = terms[i2];
        if (isEnumCapatible(term)) {
          if (map === null && i2 > 0 && isEnumCapatible(terms[i2 - 1])) {
            map = /* @__PURE__ */ Object.create(null);
            result = createCondition(
              {
                type: "Enum",
                map
              },
              MATCH,
              result
            );
          }
          if (map !== null) {
            const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }
        map = null;
        result = createCondition(
          term,
          MATCH,
          result
        );
      }
      ;
      return result;
    }
    case "&&": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true
        };
      }
      let result = MISMATCH;
      for (let i2 = terms.length - 1; i2 >= 0; i2--) {
        const term = terms[i2];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            false
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      ;
      return result;
    }
    case "||": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false
        };
      }
      let result = atLeastOneTermMatched ? MATCH : MISMATCH;
      for (let i2 = terms.length - 1; i2 >= 0; i2--) {
        const term = terms[i2];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            true
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      ;
      return result;
    }
  }
}
function buildMultiplierMatchGraph(node) {
  let result = MATCH;
  let matchTerm = buildMatchGraphInternal(node.term);
  if (node.max === 0) {
    matchTerm = createCondition(
      matchTerm,
      DISALLOW_EMPTY,
      MISMATCH
    );
    result = createCondition(
      matchTerm,
      null,
      // will be a loop
      MISMATCH
    );
    result.then = createCondition(
      MATCH,
      MATCH,
      result
      // make a loop
    );
    if (node.comma) {
      result.then.else = createCondition(
        { type: "Comma", syntax: node },
        result,
        MISMATCH
      );
    }
  } else {
    for (let i2 = node.min || 1; i2 <= node.max; i2++) {
      if (node.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        createCondition(
          MATCH,
          MATCH,
          result
        ),
        MISMATCH
      );
    }
  }
  if (node.min === 0) {
    result = createCondition(
      MATCH,
      MATCH,
      result
    );
  } else {
    for (let i2 = 0; i2 < node.min - 1; i2++) {
      if (node.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        result,
        MISMATCH
      );
    }
  }
  return result;
}
function buildMatchGraphInternal(node) {
  if (typeof node === "function") {
    return {
      type: "Generic",
      fn: node
    };
  }
  switch (node.type) {
    case "Group": {
      let result = buildGroupMatchGraph(
        node.combinator,
        node.terms.map(buildMatchGraphInternal),
        false
      );
      if (node.disallowEmpty) {
        result = createCondition(
          result,
          DISALLOW_EMPTY,
          MISMATCH
        );
      }
      return result;
    }
    case "Multiplier":
      return buildMultiplierMatchGraph(node);
    case "Type":
    case "Property":
      return {
        type: node.type,
        name: node.name,
        syntax: node
      };
    case "Keyword":
      return {
        type: node.type,
        name: node.name.toLowerCase(),
        syntax: node
      };
    case "AtKeyword":
      return {
        type: node.type,
        name: "@" + node.name.toLowerCase(),
        syntax: node
      };
    case "Function":
      return {
        type: node.type,
        name: node.name.toLowerCase() + "(",
        syntax: node
      };
    case "String":
      if (node.value.length === 3) {
        return {
          type: "Token",
          value: node.value.charAt(1),
          syntax: node
        };
      }
      return {
        type: node.type,
        value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
        syntax: node
      };
    case "Token":
      return {
        type: node.type,
        value: node.value,
        syntax: node
      };
    case "Comma":
      return {
        type: node.type,
        syntax: node
      };
    default:
      throw new Error("Unknown node type:", node.type);
  }
}
function buildMatchGraph(syntaxTree, ref) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse(syntaxTree);
  }
  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal(syntaxTree),
    syntax: ref || null,
    source: syntaxTree
  };
}

// node_modules/css-tree/lib/lexer/match.js
var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;
var EXIT_REASON_MATCH = "Match";
var EXIT_REASON_MISMATCH = "Mismatch";
var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
var ITERATION_LIMIT = 15e3;
var totalIterationCount = 0;
function reverseList(list) {
  let prev = null;
  let next = null;
  let item = list;
  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }
  return prev;
}
function areStringsEqualCaseInsensitive(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }
  for (let i2 = 0; i2 < testStr.length; i2++) {
    const referenceCode = referenceStr.charCodeAt(i2);
    let testCode = testStr.charCodeAt(i2);
    if (testCode >= 65 && testCode <= 90) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function isContextEdgeDelim(token) {
  if (token.type !== Delim) {
    return false;
  }
  return token.value !== "?";
}
function isCommaContextStart(token) {
  if (token === null) {
    return true;
  }
  return token.type === Comma || token.type === Function || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
}
function isCommaContextEnd(token) {
  if (token === null) {
    return true;
  }
  return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim && token.value === "/";
}
function internalMatch(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (token !== null && (token.type === WhiteSpace || token.type === Comment));
  }
  function getNextToken(offset) {
    const nextIndex = tokenIndex + offset;
    return nextIndex < tokens.length ? tokens[nextIndex] : null;
  }
  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev
    };
  }
  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack
    };
  }
  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }
  function addTokenToMatch() {
    matchStack = {
      type: TOKEN,
      syntax: state.syntax,
      token,
      prev: matchStack
    };
    moveToNextToken();
    syntaxStash = null;
    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }
  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
      prev: syntaxStack
    };
    matchStack = {
      type: OPEN_SYNTAX,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack
    };
  }
  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    syntaxStack = syntaxStack.prev;
  }
  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;
  let syntaxStash = null;
  let iterationCount = 0;
  let exitReason = null;
  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB,
    syntax: null,
    token: null,
    prev: null
  };
  moveToNextToken();
  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          if (token !== null) {
            if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
              state = MISMATCH;
              break;
            }
          }
          exitReason = EXIT_REASON_MATCH;
          break;
        }
        state = thenStack.nextState;
        if (state === DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = MISMATCH;
            break;
          } else {
            state = MATCH;
          }
        }
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }
        thenStack = thenStack.prev;
        break;
      case "Mismatch":
        if (syntaxStash !== null && syntaxStash !== false) {
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            elseStack = syntaxStash;
            syntaxStash = false;
          }
        } else if (elseStack === null) {
          exitReason = EXIT_REASON_MISMATCH;
          break;
        }
        state = elseStack.nextState;
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        elseStack = elseStack.prev;
        break;
      case "MatchGraph":
        state = state.match;
        break;
      case "If":
        if (state.else !== MISMATCH) {
          pushElseStack(state.else);
        }
        if (state.then !== MATCH) {
          pushThenStack(state.then);
        }
        state = state.match;
        break;
      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0
        };
        break;
      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;
        if (state.index === terms.length) {
          if (state.mask === 0 || state.syntax.all) {
            state = MISMATCH;
            break;
          }
          state = MATCH;
          break;
        }
        if (state.mask === (1 << terms.length) - 1) {
          state = MATCH;
          break;
        }
        for (; state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;
          if ((state.mask & matchFlag) === 0) {
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag
            });
            state = terms[state.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask
        };
        break;
      case "Enum":
        if (token !== null) {
          let name41 = token.value.toLowerCase();
          if (name41.indexOf("\\") !== -1) {
            name41 = name41.replace(/\\[09].*$/, "");
          }
          if (hasOwnProperty3.call(state.map, name41)) {
            state = state.map[name41];
            break;
          }
        }
        state = MISMATCH;
        break;
      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
        if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
          while (tokenIndex < lastTokenIndex2) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      }
      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty3.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
        if (!dictSyntax || !dictSyntax.match) {
          throw new Error(
            "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
          );
        }
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching = (
            // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            state.name === "custom-ident" && token.type === Ident || // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            state.name === "length" && token.value === "0"
          );
          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }
            state = MISMATCH;
            break;
          }
        }
        openSyntax();
        state = dictSyntax.match;
        break;
      }
      case "Keyword": {
        const name41 = state.name;
        if (token !== null) {
          let keywordName = token.value;
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }
          if (areStringsEqualCaseInsensitive(keywordName, name41)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
        }
        state = MISMATCH;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Comma":
        if (token !== null && token.type === Comma) {
          if (isCommaContextStart(matchStack.token)) {
            state = MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd(token) ? MISMATCH : MATCH;
          }
        } else {
          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
        }
        break;
      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;
        for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
          string += tokens[lastTokenIndex].value;
        }
        if (areStringsEqualCaseInsensitive(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }
  totalIterationCount += iterationCount;
  switch (exitReason) {
    case null:
      console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
      exitReason = EXIT_REASON_ITERATION_LIMIT;
      matchStack = null;
      break;
    case EXIT_REASON_MATCH:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;
    default:
      matchStack = null;
  }
  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch
  };
}
function matchAsTree(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
  if (matchResult.match === null) {
    return matchResult;
  }
  let item = matchResult.match;
  let host = matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: []
  };
  const hostStack = [host];
  item = reverseList(item).prev;
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX:
        host.match.push(host = {
          syntax: item.syntax,
          match: []
        });
        hostStack.push(host);
        break;
      case CLOSE_SYNTAX:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;
      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node
        });
    }
    item = item.prev;
  }
  return matchResult;
}

// node_modules/css-tree/lib/lexer/trace.js
var trace_exports = {};
__export(trace_exports, {
  getTrace: () => getTrace,
  isKeyword: () => isKeyword,
  isProperty: () => isProperty,
  isType: () => isType
});
function getTrace(node) {
  function shouldPutToTrace(syntax) {
    if (syntax === null) {
      return false;
    }
    return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
  }
  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      for (let i2 = 0; i2 < matchNode.match.length; i2++) {
        if (hasMatch(matchNode.match[i2])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }
          return true;
        }
      }
    } else if (matchNode.node === node) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
      return true;
    }
    return false;
  }
  let result = null;
  if (this.matched !== null) {
    hasMatch(this.matched);
  }
  return result;
}
function isType(node, type) {
  return testNode(this, node, (match) => match.type === "Type" && match.name === type);
}
function isProperty(node, property2) {
  return testNode(this, node, (match) => match.type === "Property" && match.name === property2);
}
function isKeyword(node) {
  return testNode(this, node, (match) => match.type === "Keyword");
}
function testNode(match, node, fn) {
  const trace = getTrace.call(match, node);
  if (trace === null) {
    return false;
  }
  return trace.some(fn);
}

// node_modules/css-tree/lib/lexer/search.js
function getFirstMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getFirstMatchNode(matchNode.match[0]);
}
function getLastMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}
function matchFragments(lexer3, ast, match, type, name41) {
  function findFragments(matchNode) {
    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name41) {
      const start = getFirstMatchNode(matchNode);
      const end = getLastMatchNode(matchNode);
      lexer3.syntax.walk(ast, function(node, item, list) {
        if (node === start) {
          const nodes = new List();
          do {
            nodes.appendData(item.data);
            if (item.data === end) {
              break;
            }
            item = item.next;
          } while (item !== null);
          fragments.push({
            parent: list,
            nodes
          });
        }
      });
    }
    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }
  const fragments = [];
  if (match.matched !== null) {
    findFragments(match.matched);
  }
  return fragments;
}

// node_modules/css-tree/lib/lexer/structure.js
var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
function isValidNumber(value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
}
function isValidLocation(loc) {
  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
}
function createNodeStructureChecker(type, fields) {
  return function checkNode(node, warn) {
    if (!node || node.constructor !== Object) {
      return warn(node, "Type of node should be an Object");
    }
    for (let key in node) {
      let valid = true;
      if (hasOwnProperty4.call(node, key) === false) {
        continue;
      }
      if (key === "type") {
        if (node.type !== type) {
          warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
        }
      } else if (key === "loc") {
        if (node.loc === null) {
          continue;
        } else if (node.loc && node.loc.constructor === Object) {
          if (typeof node.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation(node.loc.start)) {
            key += ".start";
          } else if (!isValidLocation(node.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }
        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;
        for (let i2 = 0; !valid && i2 < fields[key].length; i2++) {
          const fieldType = fields[key][i2];
          switch (fieldType) {
            case String:
              valid = typeof node[key] === "string";
              break;
            case Boolean:
              valid = typeof node[key] === "boolean";
              break;
            case null:
              valid = node[key] === null;
              break;
            default:
              if (typeof fieldType === "string") {
                valid = node[key] && node[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node[key] instanceof List;
              }
          }
        }
      } else {
        warn(node, "Unknown field `" + key + "` for " + type + " node type");
      }
      if (!valid) {
        warn(node, "Bad value for `" + type + "." + key + "`");
      }
    }
    for (const key in fields) {
      if (hasOwnProperty4.call(fields, key) && hasOwnProperty4.call(node, key) === false) {
        warn(node, "Field `" + type + "." + key + "` is missed");
      }
    }
  };
}
function processStructure(name41, nodeType) {
  const structure41 = nodeType.structure;
  const fields = {
    type: String,
    loc: true
  };
  const docs = {
    type: '"' + name41 + '"'
  };
  for (const key in structure41) {
    if (hasOwnProperty4.call(structure41, key) === false) {
      continue;
    }
    const docsTypes = [];
    const fieldTypes = fields[key] = Array.isArray(structure41[key]) ? structure41[key].slice() : [structure41[key]];
    for (let i2 = 0; i2 < fieldTypes.length; i2++) {
      const fieldType = fieldTypes[i2];
      if (fieldType === String || fieldType === Boolean) {
        docsTypes.push(fieldType.name);
      } else if (fieldType === null) {
        docsTypes.push("null");
      } else if (typeof fieldType === "string") {
        docsTypes.push("<" + fieldType + ">");
      } else if (Array.isArray(fieldType)) {
        docsTypes.push("List");
      } else {
        throw new Error("Wrong value `" + fieldType + "` in `" + name41 + "." + key + "` structure definition");
      }
    }
    docs[key] = docsTypes.join(" | ");
  }
  return {
    docs,
    check: createNodeStructureChecker(name41, fields)
  };
}
function getStructureFromConfig(config) {
  const structure41 = {};
  if (config.node) {
    for (const name41 in config.node) {
      if (hasOwnProperty4.call(config.node, name41)) {
        const nodeType = config.node[name41];
        if (nodeType.structure) {
          structure41[name41] = processStructure(name41, nodeType);
        } else {
          throw new Error("Missed `structure` field in `" + name41 + "` node type definition");
        }
      }
    }
  }
  return structure41;
}

// node_modules/css-tree/lib/lexer/Lexer.js
var cssWideKeywordsSyntax = buildMatchGraph(cssWideKeywords.join(" | "));
function dumpMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const name41 in map) {
    if (map[name41].syntax) {
      result[name41] = syntaxAsAst ? map[name41].syntax : generate(map[name41].syntax, { compact });
    }
  }
  return result;
}
function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const [name41, atrule] of Object.entries(map)) {
    result[name41] = {
      prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, { compact })),
      descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
    };
  }
  return result;
}
function valueHasVar(tokens) {
  for (let i2 = 0; i2 < tokens.length; i2++) {
    if (tokens[i2].value.toLowerCase() === "var(") {
      return true;
    }
  }
  return false;
}
function buildMatchResult(matched, error, iterations) {
  return {
    matched,
    iterations,
    error,
    ...trace_exports
  };
}
function matchSyntax(lexer3, syntax, value, useCssWideKeywords) {
  const tokens = prepare_tokens_default(value, lexer3.syntax);
  let result;
  if (valueHasVar(tokens)) {
    return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
  }
  if (useCssWideKeywords) {
    result = matchAsTree(tokens, lexer3.cssWideKeywordsSyntax, lexer3);
  }
  if (!useCssWideKeywords || !result.match) {
    result = matchAsTree(tokens, syntax.match, lexer3);
    if (!result.match) {
      return buildMatchResult(
        null,
        new SyntaxMatchError(result.reason, syntax.syntax, value, result),
        result.iterations
      );
    }
  }
  return buildMatchResult(result.match, null, result.iterations);
}
var Lexer = class {
  constructor(config, syntax, structure41) {
    this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
    this.syntax = syntax;
    this.generic = false;
    this.atrules = /* @__PURE__ */ Object.create(null);
    this.properties = /* @__PURE__ */ Object.create(null);
    this.types = /* @__PURE__ */ Object.create(null);
    this.structure = structure41 || getStructureFromConfig(config);
    if (config) {
      if (config.types) {
        for (const name41 in config.types) {
          this.addType_(name41, config.types[name41]);
        }
      }
      if (config.generic) {
        this.generic = true;
        for (const name41 in generic_default) {
          this.addType_(name41, generic_default[name41]);
        }
      }
      if (config.atrules) {
        for (const name41 in config.atrules) {
          this.addAtrule_(name41, config.atrules[name41]);
        }
      }
      if (config.properties) {
        for (const name41 in config.properties) {
          this.addProperty_(name41, config.properties[name41]);
        }
      }
    }
  }
  checkStructure(ast) {
    function collectWarning(node, message) {
      warns.push({ node, message });
    }
    const structure41 = this.structure;
    const warns = [];
    this.syntax.walk(ast, function(node) {
      if (structure41.hasOwnProperty(node.type)) {
        structure41[node.type].check(node, collectWarning);
      } else {
        collectWarning(node, "Unknown node type `" + node.type + "`");
      }
    });
    return warns.length ? warns : false;
  }
  createDescriptor(syntax, type, name41, parent = null) {
    const ref = {
      type,
      name: name41
    };
    const descriptor = {
      type,
      name: name41,
      parent,
      serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
      syntax: null,
      match: null
    };
    if (typeof syntax === "function") {
      descriptor.match = buildMatchGraph(syntax, ref);
    } else {
      if (typeof syntax === "string") {
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse(syntax)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax;
      }
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: buildMatchGraph(descriptor.syntax, ref)
          });
          return descriptor.match;
        }
      });
    }
    return descriptor;
  }
  addAtrule_(name41, syntax) {
    if (!syntax) {
      return;
    }
    this.atrules[name41] = {
      type: "Atrule",
      name: name41,
      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name41) : null,
      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(
        (map, descName) => {
          map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name41);
          return map;
        },
        /* @__PURE__ */ Object.create(null)
      ) : null
    };
  }
  addProperty_(name41, syntax) {
    if (!syntax) {
      return;
    }
    this.properties[name41] = this.createDescriptor(syntax, "Property", name41);
  }
  addType_(name41, syntax) {
    if (!syntax) {
      return;
    }
    this.types[name41] = this.createDescriptor(syntax, "Type", name41);
  }
  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtruleName(atruleName);
    if (error) {
      return error;
    }
    const atrule = this.getAtrule(atruleName);
    if (!atrule.prelude && prelude) {
      return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
    }
    if (atrule.prelude && !prelude) {
      if (!matchSyntax(this, atrule.prelude, "", false).matched) {
        return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error = this.checkAtruleName(atruleName);
    if (error) {
      return error;
    }
    const atrule = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    if (!atrule.descriptors) {
      return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
    }
    if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
      return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new SyntaxReferenceError("Unknown property", propertyName);
    }
  }
  matchAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtrulePrelude(atruleName, prelude);
    if (error) {
      return buildMatchResult(null, error);
    }
    const atrule = this.getAtrule(atruleName);
    if (!atrule.prelude) {
      return buildMatchResult(null, null);
    }
    return matchSyntax(this, atrule.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value) {
    const error = this.checkAtruleDescriptorName(atruleName, descriptorName);
    if (error) {
      return buildMatchResult(null, error);
    }
    const atrule = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
  }
  matchDeclaration(node) {
    if (node.type !== "Declaration") {
      return buildMatchResult(null, new Error("Not a Declaration node"));
    }
    return this.matchProperty(node.property, node.value);
  }
  matchProperty(propertyName, value) {
    if (property(propertyName).custom) {
      return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
    }
    const error = this.checkPropertyName(propertyName);
    if (error) {
      return buildMatchResult(null, error);
    }
    return matchSyntax(this, this.getProperty(propertyName), value, true);
  }
  matchType(typeName, value) {
    const typeSyntax = this.getType(typeName);
    if (!typeSyntax) {
      return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
    }
    return matchSyntax(this, typeSyntax, value, false);
  }
  match(syntax, value) {
    if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
      return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
    }
    if (typeof syntax === "string" || !syntax.match) {
      syntax = this.createDescriptor(syntax, "Type", "anonymous");
    }
    return matchSyntax(this, syntax, value, false);
  }
  findValueFragments(propertyName, value, type, name41) {
    return matchFragments(this, value, this.matchProperty(propertyName, value), type, name41);
  }
  findDeclarationValueFragments(declaration, type, name41) {
    return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name41);
  }
  findAllFragments(ast, type, name41) {
    const result = [];
    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name41));
      }
    });
    return result;
  }
  getAtrule(atruleName, fallbackBasename = true) {
    const atrule = keyword(atruleName);
    const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule = this.getAtrule(atruleName, fallbackBasename);
    return atrule && atrule.prelude || null;
  }
  getAtruleDescriptor(atruleName, name41) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name41] || null : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property2 = property(propertyName);
    const propertyEntry = property2.vendor && fallbackBasename ? this.properties[property2.name] || this.properties[property2.basename] : this.properties[property2.name];
    return propertyEntry || null;
  }
  getType(name41) {
    return hasOwnProperty.call(this.types, name41) ? this.types[name41] : null;
  }
  validate() {
    function validate(syntax, name41, broken, descriptor) {
      if (broken.has(name41)) {
        return broken.get(name41);
      }
      broken.set(name41, false);
      if (descriptor.syntax !== null) {
        walk(descriptor.syntax, function(node) {
          if (node.type !== "Type" && node.type !== "Property") {
            return;
          }
          const map = node.type === "Type" ? syntax.types : syntax.properties;
          const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
          if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
            broken.set(name41, true);
          }
        }, this);
      }
    }
    let brokenTypes = /* @__PURE__ */ new Map();
    let brokenProperties = /* @__PURE__ */ new Map();
    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }
    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }
    brokenTypes = [...brokenTypes.keys()].filter((name41) => brokenTypes.get(name41));
    brokenProperties = [...brokenProperties.keys()].filter((name41) => brokenProperties.get(name41));
    if (brokenTypes.length || brokenProperties.length) {
      return {
        types: brokenTypes,
        properties: brokenProperties
      };
    }
    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
};

// node_modules/css-tree/lib/syntax/config/mix.js
var { hasOwnProperty: hasOwnProperty5 } = Object.prototype;
var shape = {
  generic: true,
  types: appendOrAssign,
  atrules: {
    prelude: appendOrAssignOrNull,
    descriptors: appendOrAssignOrNull
  },
  properties: appendOrAssign,
  parseContext: assign,
  scope: deepAssign,
  atrule: ["parse"],
  pseudo: ["parse"],
  node: ["name", "structure", "parse", "generate", "walkContext"]
};
function isObject(value) {
  return value && value.constructor === Object;
}
function copy(value) {
  return isObject(value) ? { ...value } : value;
}
function assign(dest, src) {
  return Object.assign(dest, src);
}
function deepAssign(dest, src) {
  for (const key in src) {
    if (hasOwnProperty5.call(src, key)) {
      if (isObject(dest[key])) {
        deepAssign(dest[key], src[key]);
      } else {
        dest[key] = copy(src[key]);
      }
    }
  }
  return dest;
}
function append(a2, b) {
  if (typeof b === "string" && /^\s*\|/.test(b)) {
    return typeof a2 === "string" ? a2 + b : b.replace(/^\s*\|\s*/, "");
  }
  return b || null;
}
function appendOrAssign(a2, b) {
  if (typeof b === "string") {
    return append(a2, b);
  }
  const result = { ...a2 };
  for (let key in b) {
    if (hasOwnProperty5.call(b, key)) {
      result[key] = append(hasOwnProperty5.call(a2, key) ? a2[key] : void 0, b[key]);
    }
  }
  return result;
}
function appendOrAssignOrNull(a2, b) {
  const result = appendOrAssign(a2, b);
  return !isObject(result) || Object.keys(result).length ? result : null;
}
function mix(dest, src, shape2) {
  for (const key in shape2) {
    if (hasOwnProperty5.call(shape2, key) === false) {
      continue;
    }
    if (shape2[key] === true) {
      if (hasOwnProperty5.call(src, key)) {
        dest[key] = copy(src[key]);
      }
    } else if (shape2[key]) {
      if (typeof shape2[key] === "function") {
        const fn = shape2[key];
        dest[key] = fn({}, dest[key]);
        dest[key] = fn(dest[key] || {}, src[key]);
      } else if (isObject(shape2[key])) {
        const result = {};
        for (let name41 in dest[key]) {
          result[name41] = mix({}, dest[key][name41], shape2[key]);
        }
        for (let name41 in src[key]) {
          result[name41] = mix(result[name41] || {}, src[key][name41], shape2[key]);
        }
        dest[key] = result;
      } else if (Array.isArray(shape2[key])) {
        const res = {};
        const innerShape = shape2[key].reduce(function(s2, k) {
          s2[k] = true;
          return s2;
        }, {});
        for (const [name41, value] of Object.entries(dest[key] || {})) {
          res[name41] = {};
          if (value) {
            mix(res[name41], value, innerShape);
          }
        }
        for (const name41 in src[key]) {
          if (hasOwnProperty5.call(src[key], name41)) {
            if (!res[name41]) {
              res[name41] = {};
            }
            if (src[key] && src[key][name41]) {
              mix(res[name41], src[key][name41], innerShape);
            }
          }
        }
        dest[key] = res;
      }
    }
  }
  return dest;
}
var mix_default = (dest, src) => mix(dest, src, shape);

// node_modules/css-tree/lib/syntax/create.js
function createSyntax(config) {
  const parse45 = createParser(config);
  const walk4 = createWalker(config);
  const generate45 = createGenerator(config);
  const { fromPlainObject: fromPlainObject3, toPlainObject: toPlainObject3 } = createConvertor(walk4);
  const syntax = {
    lexer: null,
    createLexer: (config2) => new Lexer(config2, syntax, syntax.lexer.structure),
    tokenize,
    parse: parse45,
    generate: generate45,
    walk: walk4,
    find: walk4.find,
    findLast: walk4.findLast,
    findAll: walk4.findAll,
    fromPlainObject: fromPlainObject3,
    toPlainObject: toPlainObject3,
    fork(extension) {
      const base = mix_default({}, config);
      return createSyntax(
        typeof extension === "function" ? extension(base, Object.assign) : mix_default(base, extension)
      );
    }
  };
  syntax.lexer = new Lexer({
    generic: true,
    types: config.types,
    atrules: config.atrules,
    properties: config.properties,
    node: config.node
  }, syntax);
  return syntax;
}
var create_default = (config) => createSyntax(mix_default({}, config));

// node_modules/css-tree/dist/data.js
var data_default = {
  "generic": true,
  "types": {
    "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
    "alpha-value": "<number>|<percentage>",
    "angle-percentage": "<angle>|<percentage>",
    "angular-color-hint": "<angle-percentage>",
    "angular-color-stop": "<color>&&<color-stop-angle>?",
    "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
    "animateable-feature": "scroll-position|contents|<custom-ident>",
    "attachment": "scroll|fixed|local",
    "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
    "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
    "attr-modifier": "i|s",
    "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
    "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
    "baseline-position": "[first|last]? baseline",
    "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
    "bg-image": "none|<image>",
    "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
    "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
    "blur()": "blur( <length> )",
    "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
    "box": "border-box|padding-box|content-box",
    "brightness()": "brightness( <number-percentage> )",
    "calc()": "calc( <calc-sum> )",
    "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
    "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
    "calc-value": "<number>|<dimension>|<percentage>|( <calc-sum> )",
    "cf-final-image": "<image>|<color>",
    "cf-mixing-image": "<percentage>?&&<image>",
    "circle()": "circle( [<shape-radius>]? [at <position>]? )",
    "clamp()": "clamp( <calc-sum>#{3} )",
    "class-selector": "'.' <ident-token>",
    "clip-source": "<url>",
    "color": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>",
    "color-stop": "<color-stop-length>|<color-stop-angle>",
    "color-stop-angle": "<angle-percentage>{1,2}",
    "color-stop-length": "<length-percentage>{1,2}",
    "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
    "combinator": "'>'|'+'|'~'|['||']",
    "common-lig-values": "[common-ligatures|no-common-ligatures]",
    "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
    "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
    "compositing-operator": "add|subtract|intersect|exclude",
    "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!",
    "compound-selector-list": "<compound-selector>#",
    "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
    "complex-selector-list": "<complex-selector>#",
    "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "contextual-alt-values": "[contextual|no-contextual]",
    "content-distribution": "space-between|space-around|space-evenly|stretch",
    "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
    "content-position": "center|start|end|flex-start|flex-end",
    "content-replacement": "<image>",
    "contrast()": "contrast( [<number-percentage>] )",
    "counter": "<counter()>|<counters()>",
    "counter()": "counter( <counter-name> , <counter-style>? )",
    "counter-name": "<custom-ident>",
    "counter-style": "<counter-style-name>|symbols( )",
    "counter-style-name": "<custom-ident>",
    "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
    "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
    "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
    "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
    "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
    "display-box": "contents|none",
    "display-inside": "flow|flow-root|table|flex|grid|ruby",
    "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
    "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
    "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
    "display-outside": "block|inline|run-in",
    "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
    "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
    "east-asian-width-values": "[full-width|proportional-width]",
    "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
    "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
    "ending-shape": "circle|ellipse",
    "env()": "env( <custom-ident> , <declaration-value>? )",
    "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
    "family-name": "<string>|<custom-ident>+",
    "feature-tag-value": "<string> [<integer>|on|off]?",
    "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
    "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
    "feature-value-block-list": "<feature-value-block>+",
    "feature-value-declaration": "<custom-ident> : <integer>+ ;",
    "feature-value-declaration-list": "<feature-value-declaration>",
    "feature-value-name": "<custom-ident>",
    "fill-rule": "nonzero|evenodd",
    "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
    "filter-function-list": "[<filter-function>|<url>]+",
    "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "fit-content()": "fit-content( [<length>|<percentage>] )",
    "fixed-breadth": "<length-percentage>",
    "fixed-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
    "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
    "font-variant-css21": "[normal|small-caps]",
    "font-weight-absolute": "normal|bold|<number [1,1000]>",
    "frequency-percentage": "<frequency>|<percentage>",
    "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )",
    "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system",
    "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
    "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
    "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
    "grayscale()": "grayscale( <number-percentage> )",
    "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
    "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
    "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hue": "<number>|<angle>",
    "hue-rotate()": "hue-rotate( <angle> )",
    "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
    "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
    "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
    "image-set()": "image-set( <image-set-option># )",
    "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
    "image-src": "<url>|<string>",
    "image-tags": "ltr|rtl",
    "inflexible-breadth": "<length>|<percentage>|min-content|max-content|auto",
    "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
    "invert()": "invert( <number-percentage> )",
    "keyframes-name": "<custom-ident>|<string>",
    "keyframe-block": "<keyframe-selector># { <declaration-list> }",
    "keyframe-block-list": "<keyframe-block>+",
    "keyframe-selector": "from|to|<percentage>",
    "layer()": "layer( <layer-name> )",
    "layer-name": "<ident> ['.' <ident>]*",
    "leader()": "leader( <leader-type> )",
    "leader-type": "dotted|solid|space|<string>",
    "length-percentage": "<length>|<percentage>",
    "line-names": "'[' <custom-ident>* ']'",
    "line-name-list": "[<line-names>|<name-repeat>]+",
    "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
    "line-width": "<length>|thin|medium|thick",
    "linear-color-hint": "<length-percentage>",
    "linear-color-stop": "<color> <color-stop-length>?",
    "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
    "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
    "mask-reference": "none|<image>|<mask-source>",
    "mask-source": "<url>",
    "masking-mode": "alpha|luminance|match-source",
    "matrix()": "matrix( <number>#{6} )",
    "matrix3d()": "matrix3d( <number>#{16} )",
    "max()": "max( <calc-sum># )",
    "media-and": "<media-in-parens> [and <media-in-parens>]+",
    "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
    "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
    "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
    "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
    "media-not": "not <media-in-parens>",
    "media-or": "<media-in-parens> [or <media-in-parens>]+",
    "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
    "media-query-list": "<media-query>#",
    "media-type": "<ident>",
    "mf-boolean": "<mf-name>",
    "mf-name": "<ident>",
    "mf-plain": "<mf-name> : <mf-value>",
    "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
    "mf-value": "<number>|<dimension>|<ident>|<ratio>",
    "min()": "min( <calc-sum># )",
    "minmax()": "minmax( [<length>|<percentage>|min-content|max-content|auto] , [<length>|<percentage>|<flex>|min-content|max-content|auto] )",
    "name-repeat": "repeat( [<integer [1,\u221E]>|auto-fill] , <line-names>+ )",
    "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>",
    "namespace-prefix": "<ident>",
    "ns-prefix": "[<ident-token>|'*']? '|'",
    "number-percentage": "<number>|<percentage>",
    "numeric-figure-values": "[lining-nums|oldstyle-nums]",
    "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
    "numeric-spacing-values": "[proportional-nums|tabular-nums]",
    "nth": "<an-plus-b>|even|odd",
    "opacity()": "opacity( [<number-percentage>] )",
    "overflow-position": "unsafe|safe",
    "outline-radius": "<length>|<percentage>",
    "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
    "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
    "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
    "page-selector-list": "[<page-selector>#]?",
    "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
    "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
    "path()": "path( [<fill-rule> ,]? <string> )",
    "paint()": "paint( <ident> , <declaration-value>? )",
    "perspective()": "perspective( <length> )",
    "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
    "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
    "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
    "pseudo-element-selector": "':' <pseudo-class-selector>",
    "pseudo-page": ": [left|right|first|blank]",
    "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
    "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "relative-selector": "<combinator>? <complex-selector>",
    "relative-selector-list": "<relative-selector>#",
    "relative-size": "larger|smaller",
    "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
    "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
    "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
    "rotate()": "rotate( [<angle>|<zero>] )",
    "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
    "rotateX()": "rotateX( [<angle>|<zero>] )",
    "rotateY()": "rotateY( [<angle>|<zero>] )",
    "rotateZ()": "rotateZ( [<angle>|<zero>] )",
    "saturate()": "saturate( <number-percentage> )",
    "scale()": "scale( <number> , <number>? )",
    "scale3d()": "scale3d( <number> , <number> , <number> )",
    "scaleX()": "scaleX( <number> )",
    "scaleY()": "scaleY( <number> )",
    "scaleZ()": "scaleZ( <number> )",
    "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
    "shape-radius": "<length-percentage>|closest-side|farthest-side",
    "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
    "skewX()": "skewX( [<angle>|<zero>] )",
    "skewY()": "skewY( [<angle>|<zero>] )",
    "sepia()": "sepia( <number-percentage> )",
    "shadow": "inset?&&<length>{2,4}&&<color>?",
    "shadow-t": "[<length>{2,3}&&<color>?]",
    "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
    "shape-box": "<box>|margin-box",
    "side-or-corner": "[left|right]||[top|bottom]",
    "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]",
    "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
    "single-animation-fill-mode": "none|forwards|backwards|both",
    "single-animation-iteration-count": "infinite|<number>",
    "single-animation-play-state": "running|paused",
    "single-animation-timeline": "auto|none|<timeline-name>",
    "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>",
    "single-transition-property": "all|<custom-ident>",
    "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
    "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
    "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
    "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
    "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
    "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
    "supports-feature": "<supports-decl>|<supports-selector-fn>",
    "supports-decl": "( <declaration> )",
    "supports-selector-fn": "selector( <complex-selector> )",
    "symbol": "<string>|<image>|<custom-ident>",
    "target": "<target-counter()>|<target-counters()>|<target-text()>",
    "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
    "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
    "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
    "time-percentage": "<time>|<percentage>",
    "timeline-name": "<custom-ident>|<string>",
    "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
    "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
    "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
    "track-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <track-size>]+ <line-names>? )",
    "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( [<length>|<percentage>] )",
    "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
    "transform-list": "<transform-function>+",
    "translate()": "translate( <length-percentage> , <length-percentage>? )",
    "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
    "translateX()": "translateX( <length-percentage> )",
    "translateY()": "translateY( <length-percentage> )",
    "translateZ()": "translateZ( <length> )",
    "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
    "type-selector": "<wq-name>|<ns-prefix>? '*'",
    "var()": "var( <custom-property-name> , <declaration-value>? )",
    "viewport-length": "auto|<length-percentage>",
    "visual-box": "content-box|padding-box|border-box",
    "wq-name": "<ns-prefix>? <ident-token>",
    "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
    "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
    "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
    "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
    "-legacy-radial-gradient-shape": "circle|ellipse",
    "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
    "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
    "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
    "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
    "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content",
    "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
    "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
    "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
    "-webkit-gradient-radius": "<length>|<percentage>",
    "-webkit-gradient-type": "linear|radial",
    "-webkit-mask-box-repeat": "repeat|stretch|round",
    "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text",
    "-ms-filter-function-list": "<-ms-filter-function>+",
    "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
    "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
    "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
    "-ms-filter": "<string>",
    "age": "child|young|old",
    "attr-name": "<wq-name>",
    "attr-fallback": "<any-value>",
    "bg-clip": "<box>|border|text",
    "border-radius": "<length-percentage>{1,2}",
    "bottom": "<length>|auto",
    "generic-voice": "[<age>? <gender> <integer>?]",
    "gender": "male|female|neutral",
    "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "left": "<length>|auto",
    "mask-image": "<mask-reference>#",
    "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
    "ratio": "<number [0,\u221E]> [/ <number [0,\u221E]>]?",
    "reversed-counter-name": "reversed( <counter-name> )",
    "right": "<length>|auto",
    "svg-length": "<percentage>|<length>|<number>",
    "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
    "top": "<length>|auto",
    "track-group": "'(' [<string>* <track-minmax> <string>*]+ ')' ['[' <positive-integer> ']']?|<track-minmax>",
    "track-list-v0": "[<string>* <track-group> <string>*]+|none",
    "track-minmax": "minmax( <track-breadth> , <track-breadth> )|auto|<track-breadth>|fit-content",
    "x": "<number>",
    "y": "<number>",
    "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
    "declaration-list": "[<declaration>? ';']* <declaration>?",
    "url": "url( <string> <url-modifier>* )|<url-token>",
    "url-modifier": "<ident>|<function-token> <any-value> )",
    "number-zero-one": "<number [0,1]>",
    "number-one-or-greater": "<number [1,\u221E]>",
    "positive-integer": "<integer [0,\u221E]>",
    "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box"
  },
  "properties": {
    "--*": "<declaration-value>",
    "-ms-accelerator": "false|true",
    "-ms-block-progression": "tb|rl|bt|lr",
    "-ms-content-zoom-chaining": "none|chained",
    "-ms-content-zooming": "none|zoom",
    "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    "-ms-content-zoom-limit-max": "<percentage>",
    "-ms-content-zoom-limit-min": "<percentage>",
    "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
    "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
    "-ms-content-zoom-snap-type": "none|proximity|mandatory",
    "-ms-filter": "<string>",
    "-ms-flow-from": "[none|<custom-ident>]#",
    "-ms-flow-into": "[none|<custom-ident>]#",
    "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
    "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
    "-ms-high-contrast-adjust": "auto|none",
    "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
    "-ms-hyphenate-limit-lines": "no-limit|<integer>",
    "-ms-hyphenate-limit-zone": "<percentage>|<length>",
    "-ms-ime-align": "auto|after",
    "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
    "-ms-scrollbar-3dlight-color": "<color>",
    "-ms-scrollbar-arrow-color": "<color>",
    "-ms-scrollbar-base-color": "<color>",
    "-ms-scrollbar-darkshadow-color": "<color>",
    "-ms-scrollbar-face-color": "<color>",
    "-ms-scrollbar-highlight-color": "<color>",
    "-ms-scrollbar-shadow-color": "<color>",
    "-ms-scrollbar-track-color": "<color>",
    "-ms-scroll-chaining": "chained|none",
    "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    "-ms-scroll-limit-x-max": "auto|<length>",
    "-ms-scroll-limit-x-min": "<length>",
    "-ms-scroll-limit-y-max": "auto|<length>",
    "-ms-scroll-limit-y-min": "<length>",
    "-ms-scroll-rails": "none|railed",
    "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-type": "none|proximity|mandatory",
    "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    "-ms-scroll-translation": "none|vertical-to-horizontal",
    "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
    "-ms-touch-select": "grippers|none",
    "-ms-user-select": "none|element|text",
    "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
    "-ms-wrap-margin": "<length>",
    "-ms-wrap-through": "wrap|none",
    "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
    "-moz-binding": "<url>|none",
    "-moz-border-bottom-colors": "<color>+|none",
    "-moz-border-left-colors": "<color>+|none",
    "-moz-border-right-colors": "<color>+|none",
    "-moz-border-top-colors": "<color>+|none",
    "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
    "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
    "-moz-force-broken-image-icon": "0|1",
    "-moz-image-region": "<shape>|auto",
    "-moz-orient": "inline|block|horizontal|vertical",
    "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
    "-moz-outline-radius-bottomleft": "<outline-radius>",
    "-moz-outline-radius-bottomright": "<outline-radius>",
    "-moz-outline-radius-topleft": "<outline-radius>",
    "-moz-outline-radius-topright": "<outline-radius>",
    "-moz-stack-sizing": "ignore|stretch-to-fit",
    "-moz-text-blink": "none|blink",
    "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
    "-moz-user-input": "auto|none|enabled|disabled",
    "-moz-user-modify": "read-only|read-write|write-only",
    "-moz-window-dragging": "drag|no-drag",
    "-moz-window-shadow": "default|menu|tooltip|sheet|none",
    "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
    "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
    "-webkit-border-before-color": "<color>",
    "-webkit-border-before-style": "<'border-style'>",
    "-webkit-border-before-width": "<'border-width'>",
    "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
    "-webkit-line-clamp": "none|<integer>",
    "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
    "-webkit-mask-attachment": "<attachment>#",
    "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
    "-webkit-mask-composite": "<composite-style>#",
    "-webkit-mask-image": "<mask-reference>#",
    "-webkit-mask-origin": "[<box>|border|padding|content]#",
    "-webkit-mask-position": "<position>#",
    "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
    "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
    "-webkit-mask-repeat": "<repeat-style>#",
    "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
    "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
    "-webkit-mask-size": "<bg-size>#",
    "-webkit-overflow-scrolling": "auto|touch",
    "-webkit-tap-highlight-color": "<color>",
    "-webkit-text-fill-color": "<color>",
    "-webkit-text-stroke": "<length>||<color>",
    "-webkit-text-stroke-color": "<color>",
    "-webkit-text-stroke-width": "<length>",
    "-webkit-touch-callout": "default|none",
    "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
    "accent-color": "auto|<color>",
    "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
    "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
    "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
    "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
    "all": "initial|inherit|unset|revert|revert-layer",
    "animation": "<single-animation>#",
    "animation-delay": "<time>#",
    "animation-direction": "<single-animation-direction>#",
    "animation-duration": "<time>#",
    "animation-fill-mode": "<single-animation-fill-mode>#",
    "animation-iteration-count": "<single-animation-iteration-count>#",
    "animation-name": "[none|<keyframes-name>]#",
    "animation-play-state": "<single-animation-play-state>#",
    "animation-timing-function": "<easing-function>#",
    "animation-timeline": "<single-animation-timeline>#",
    "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
    "aspect-ratio": "auto|<ratio>",
    "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
    "backdrop-filter": "none|<filter-function-list>",
    "backface-visibility": "visible|hidden",
    "background": "[<bg-layer> ,]* <final-bg-layer>",
    "background-attachment": "<attachment>#",
    "background-blend-mode": "<blend-mode>#",
    "background-clip": "<bg-clip>#",
    "background-color": "<color>",
    "background-image": "<bg-image>#",
    "background-origin": "<box>#",
    "background-position": "<bg-position>#",
    "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
    "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
    "background-repeat": "<repeat-style>#",
    "background-size": "<bg-size>#",
    "block-overflow": "clip|ellipsis|<string>",
    "block-size": "<'width'>",
    "border": "<line-width>||<line-style>||<color>",
    "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-color": "<'border-top-color'>{1,2}",
    "border-block-style": "<'border-top-style'>",
    "border-block-width": "<'border-top-width'>",
    "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-end-color": "<'border-top-color'>",
    "border-block-end-style": "<'border-top-style'>",
    "border-block-end-width": "<'border-top-width'>",
    "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-start-color": "<'border-top-color'>",
    "border-block-start-style": "<'border-top-style'>",
    "border-block-start-width": "<'border-top-width'>",
    "border-bottom": "<line-width>||<line-style>||<color>",
    "border-bottom-color": "<'border-top-color'>",
    "border-bottom-left-radius": "<length-percentage>{1,2}",
    "border-bottom-right-radius": "<length-percentage>{1,2}",
    "border-bottom-style": "<line-style>",
    "border-bottom-width": "<line-width>",
    "border-collapse": "collapse|separate",
    "border-color": "<color>{1,4}",
    "border-end-end-radius": "<length-percentage>{1,2}",
    "border-end-start-radius": "<length-percentage>{1,2}",
    "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
    "border-image-outset": "[<length>|<number>]{1,4}",
    "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
    "border-image-slice": "<number-percentage>{1,4}&&fill?",
    "border-image-source": "none|<image>",
    "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
    "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-color": "<'border-top-color'>{1,2}",
    "border-inline-style": "<'border-top-style'>",
    "border-inline-width": "<'border-top-width'>",
    "border-inline-end-color": "<'border-top-color'>",
    "border-inline-end-style": "<'border-top-style'>",
    "border-inline-end-width": "<'border-top-width'>",
    "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-start-color": "<'border-top-color'>",
    "border-inline-start-style": "<'border-top-style'>",
    "border-inline-start-width": "<'border-top-width'>",
    "border-left": "<line-width>||<line-style>||<color>",
    "border-left-color": "<color>",
    "border-left-style": "<line-style>",
    "border-left-width": "<line-width>",
    "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
    "border-right": "<line-width>||<line-style>||<color>",
    "border-right-color": "<color>",
    "border-right-style": "<line-style>",
    "border-right-width": "<line-width>",
    "border-spacing": "<length> <length>?",
    "border-start-end-radius": "<length-percentage>{1,2}",
    "border-start-start-radius": "<length-percentage>{1,2}",
    "border-style": "<line-style>{1,4}",
    "border-top": "<line-width>||<line-style>||<color>",
    "border-top-color": "<color>",
    "border-top-left-radius": "<length-percentage>{1,2}",
    "border-top-right-radius": "<length-percentage>{1,2}",
    "border-top-style": "<line-style>",
    "border-top-width": "<line-width>",
    "border-width": "<line-width>{1,4}",
    "bottom": "<length>|<percentage>|auto",
    "box-align": "start|center|end|baseline|stretch",
    "box-decoration-break": "slice|clone",
    "box-direction": "normal|reverse|inherit",
    "box-flex": "<number>",
    "box-flex-group": "<integer>",
    "box-lines": "single|multiple",
    "box-ordinal-group": "<integer>",
    "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
    "box-pack": "start|center|end|justify",
    "box-shadow": "none|<shadow>#",
    "box-sizing": "content-box|border-box",
    "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
    "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
    "caret-color": "auto|<color>",
    "clear": "none|left|right|both|inline-start|inline-end",
    "clip": "<shape>|auto",
    "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
    "color": "<color>",
    "print-color-adjust": "economy|exact",
    "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
    "column-count": "<integer>|auto",
    "column-fill": "auto|balance|balance-all",
    "column-gap": "normal|<length-percentage>",
    "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
    "column-rule-color": "<color>",
    "column-rule-style": "<'border-style'>",
    "column-rule-width": "<'border-width'>",
    "column-span": "none|all",
    "column-width": "<length>|auto",
    "columns": "<'column-width'>||<'column-count'>",
    "contain": "none|strict|content|[size||layout||style||paint]",
    "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
    "content-visibility": "visible|auto|hidden",
    "counter-increment": "[<counter-name> <integer>?]+|none",
    "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
    "counter-set": "[<counter-name> <integer>?]+|none",
    "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
    "direction": "ltr|rtl",
    "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
    "empty-cells": "show|hide",
    "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
    "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
    "flex-basis": "content|<'width'>",
    "flex-direction": "row|row-reverse|column|column-reverse",
    "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
    "flex-grow": "<number>",
    "flex-shrink": "<number>",
    "flex-wrap": "nowrap|wrap|wrap-reverse",
    "float": "left|right|none|inline-start|inline-end",
    "font": "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar",
    "font-family": "[<family-name>|<generic-family>]#",
    "font-feature-settings": "normal|<feature-tag-value>#",
    "font-kerning": "auto|normal|none",
    "font-language-override": "normal|<string>",
    "font-optical-sizing": "auto|none",
    "font-variation-settings": "normal|[<string> <number>]#",
    "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
    "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
    "font-smooth": "auto|never|always|<absolute-size>|<length>",
    "font-stretch": "<font-stretch-absolute>",
    "font-style": "normal|italic|oblique <angle>?",
    "font-synthesis": "none|[weight||style||small-caps]",
    "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
    "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
    "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
    "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
    "font-variant-position": "normal|sub|super",
    "font-weight": "<font-weight-absolute>|bolder|lighter",
    "forced-color-adjust": "auto|none",
    "gap": "<'row-gap'> <'column-gap'>?",
    "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
    "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
    "grid-auto-columns": "<track-size>+",
    "grid-auto-flow": "[row|column]||dense",
    "grid-auto-rows": "<track-size>+",
    "grid-column": "<grid-line> [/ <grid-line>]?",
    "grid-column-end": "<grid-line>",
    "grid-column-gap": "<length-percentage>",
    "grid-column-start": "<grid-line>",
    "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
    "grid-row": "<grid-line> [/ <grid-line>]?",
    "grid-row-end": "<grid-line>",
    "grid-row-gap": "<length-percentage>",
    "grid-row-start": "<grid-line>",
    "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
    "grid-template-areas": "none|<string>+",
    "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
    "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "hyphenate-character": "auto|<string>",
    "hyphens": "none|manual|auto",
    "image-orientation": "from-image|<angle>|[<angle>? flip]",
    "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
    "image-resolution": "[from-image||<resolution>]&&snap?",
    "ime-mode": "auto|normal|active|inactive|disabled",
    "initial-letter": "normal|[<number> <integer>?]",
    "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
    "inline-size": "<'width'>",
    "input-security": "auto|none",
    "inset": "<'top'>{1,4}",
    "inset-block": "<'top'>{1,2}",
    "inset-block-end": "<'top'>",
    "inset-block-start": "<'top'>",
    "inset-inline": "<'top'>{1,2}",
    "inset-inline-end": "<'top'>",
    "inset-inline-start": "<'top'>",
    "isolation": "auto|isolate",
    "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
    "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
    "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
    "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
    "left": "<length>|<percentage>|auto",
    "letter-spacing": "normal|<length-percentage>",
    "line-break": "auto|loose|normal|strict|anywhere",
    "line-clamp": "none|<integer>",
    "line-height": "normal|<number>|<length>|<percentage>",
    "line-height-step": "<length>",
    "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
    "list-style-image": "<image>|none",
    "list-style-position": "inside|outside",
    "list-style-type": "<counter-style>|<string>|none",
    "margin": "[<length>|<percentage>|auto]{1,4}",
    "margin-block": "<'margin-left'>{1,2}",
    "margin-block-end": "<'margin-left'>",
    "margin-block-start": "<'margin-left'>",
    "margin-bottom": "<length>|<percentage>|auto",
    "margin-inline": "<'margin-left'>{1,2}",
    "margin-inline-end": "<'margin-left'>",
    "margin-inline-start": "<'margin-left'>",
    "margin-left": "<length>|<percentage>|auto",
    "margin-right": "<length>|<percentage>|auto",
    "margin-top": "<length>|<percentage>|auto",
    "margin-trim": "none|in-flow|all",
    "mask": "<mask-layer>#",
    "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
    "mask-border-mode": "luminance|alpha",
    "mask-border-outset": "[<length>|<number>]{1,4}",
    "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
    "mask-border-slice": "<number-percentage>{1,4} fill?",
    "mask-border-source": "none|<image>",
    "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
    "mask-clip": "[<geometry-box>|no-clip]#",
    "mask-composite": "<compositing-operator>#",
    "mask-image": "<mask-reference>#",
    "mask-mode": "<masking-mode>#",
    "mask-origin": "<geometry-box>#",
    "mask-position": "<position>#",
    "mask-repeat": "<repeat-style>#",
    "mask-size": "<bg-size>#",
    "mask-type": "luminance|alpha",
    "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
    "math-style": "normal|compact",
    "max-block-size": "<'max-width'>",
    "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "max-inline-size": "<'max-width'>",
    "max-lines": "none|<integer>",
    "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
    "min-block-size": "<'min-width'>",
    "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "min-inline-size": "<'min-width'>",
    "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
    "mix-blend-mode": "<blend-mode>|plus-lighter",
    "object-fit": "fill|contain|cover|none|scale-down",
    "object-position": "<position>",
    "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
    "offset-anchor": "auto|<position>",
    "offset-distance": "<length-percentage>",
    "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]",
    "offset-position": "auto|<position>",
    "offset-rotate": "[auto|reverse]||<angle>",
    "opacity": "<alpha-value>",
    "order": "<integer>",
    "orphans": "<integer>",
    "outline": "[<'outline-color'>||<'outline-style'>||<'outline-width'>]",
    "outline-color": "<color>|invert",
    "outline-offset": "<length>",
    "outline-style": "auto|<'border-style'>",
    "outline-width": "<line-width>",
    "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
    "overflow-anchor": "auto|none",
    "overflow-block": "visible|hidden|clip|scroll|auto",
    "overflow-clip-box": "padding-box|content-box",
    "overflow-clip-margin": "<visual-box>||<length [0,\u221E]>",
    "overflow-inline": "visible|hidden|clip|scroll|auto",
    "overflow-wrap": "normal|break-word|anywhere",
    "overflow-x": "visible|hidden|clip|scroll|auto",
    "overflow-y": "visible|hidden|clip|scroll|auto",
    "overscroll-behavior": "[contain|none|auto]{1,2}",
    "overscroll-behavior-block": "contain|none|auto",
    "overscroll-behavior-inline": "contain|none|auto",
    "overscroll-behavior-x": "contain|none|auto",
    "overscroll-behavior-y": "contain|none|auto",
    "padding": "[<length>|<percentage>]{1,4}",
    "padding-block": "<'padding-left'>{1,2}",
    "padding-block-end": "<'padding-left'>",
    "padding-block-start": "<'padding-left'>",
    "padding-bottom": "<length>|<percentage>",
    "padding-inline": "<'padding-left'>{1,2}",
    "padding-inline-end": "<'padding-left'>",
    "padding-inline-start": "<'padding-left'>",
    "padding-left": "<length>|<percentage>",
    "padding-right": "<length>|<percentage>",
    "padding-top": "<length>|<percentage>",
    "page-break-after": "auto|always|avoid|left|right|recto|verso",
    "page-break-before": "auto|always|avoid|left|right|recto|verso",
    "page-break-inside": "auto|avoid",
    "paint-order": "normal|[fill||stroke||markers]",
    "perspective": "none|<length>",
    "perspective-origin": "<position>",
    "place-content": "<'align-content'> <'justify-content'>?",
    "place-items": "<'align-items'> <'justify-items'>?",
    "place-self": "<'align-self'> <'justify-self'>?",
    "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
    "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
    "quotes": "none|auto|[<string> <string>]+",
    "resize": "none|both|horizontal|vertical|block|inline",
    "right": "<length>|<percentage>|auto",
    "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
    "row-gap": "normal|<length-percentage>",
    "ruby-align": "start|center|space-between|space-around",
    "ruby-merge": "separate|collapse|auto",
    "ruby-position": "[alternate||[over|under]]|inter-character",
    "scale": "none|<number>{1,3}",
    "scrollbar-color": "auto|<color>{2}",
    "scrollbar-gutter": "auto|stable&&both-edges?",
    "scrollbar-width": "auto|thin|none",
    "scroll-behavior": "auto|smooth",
    "scroll-margin": "<length>{1,4}",
    "scroll-margin-block": "<length>{1,2}",
    "scroll-margin-block-start": "<length>",
    "scroll-margin-block-end": "<length>",
    "scroll-margin-bottom": "<length>",
    "scroll-margin-inline": "<length>{1,2}",
    "scroll-margin-inline-start": "<length>",
    "scroll-margin-inline-end": "<length>",
    "scroll-margin-left": "<length>",
    "scroll-margin-right": "<length>",
    "scroll-margin-top": "<length>",
    "scroll-padding": "[auto|<length-percentage>]{1,4}",
    "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-block-start": "auto|<length-percentage>",
    "scroll-padding-block-end": "auto|<length-percentage>",
    "scroll-padding-bottom": "auto|<length-percentage>",
    "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-inline-start": "auto|<length-percentage>",
    "scroll-padding-inline-end": "auto|<length-percentage>",
    "scroll-padding-left": "auto|<length-percentage>",
    "scroll-padding-right": "auto|<length-percentage>",
    "scroll-padding-top": "auto|<length-percentage>",
    "scroll-snap-align": "[none|start|end|center]{1,2}",
    "scroll-snap-coordinate": "none|<position>#",
    "scroll-snap-destination": "<position>",
    "scroll-snap-points-x": "none|repeat( <length-percentage> )",
    "scroll-snap-points-y": "none|repeat( <length-percentage> )",
    "scroll-snap-stop": "normal|always",
    "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
    "scroll-snap-type-x": "none|mandatory|proximity",
    "scroll-snap-type-y": "none|mandatory|proximity",
    "shape-image-threshold": "<alpha-value>",
    "shape-margin": "<length-percentage>",
    "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
    "tab-size": "<integer>|<length>",
    "table-layout": "auto|fixed",
    "text-align": "start|end|left|right|center|justify|match-parent",
    "text-align-last": "auto|start|end|left|right|center|justify",
    "text-combine-upright": "none|all|[digits <integer>?]",
    "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
    "text-decoration-color": "<color>",
    "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
    "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
    "text-decoration-skip-ink": "auto|all|none",
    "text-decoration-style": "solid|double|dotted|dashed|wavy",
    "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
    "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
    "text-emphasis-color": "<color>",
    "text-emphasis-position": "[over|under]&&[right|left]",
    "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
    "text-indent": "<length-percentage>&&hanging?&&each-line?",
    "text-justify": "auto|inter-character|inter-word|none",
    "text-orientation": "mixed|upright|sideways",
    "text-overflow": "[clip|ellipsis|<string>]{1,2}",
    "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
    "text-shadow": "none|<shadow-t>#",
    "text-size-adjust": "none|auto|<percentage>",
    "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
    "text-underline-offset": "auto|<length>|<percentage>",
    "text-underline-position": "auto|from-font|[under||[left|right]]",
    "top": "<length>|<percentage>|auto",
    "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
    "transform": "none|<transform-list>",
    "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
    "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
    "transform-style": "flat|preserve-3d",
    "transition": "<single-transition>#",
    "transition-delay": "<time>#",
    "transition-duration": "<time>#",
    "transition-property": "none|<single-transition-property>#",
    "transition-timing-function": "<easing-function>#",
    "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
    "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
    "user-select": "auto|text|none|contain|all",
    "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
    "visibility": "visible|hidden|collapse",
    "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces",
    "widows": "<integer>",
    "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fill|stretch|intrinsic|-moz-max-content|-webkit-max-content|-moz-fit-content|-webkit-fit-content",
    "will-change": "auto|<animateable-feature>#",
    "word-break": "normal|break-all|keep-all|break-word",
    "word-spacing": "normal|<length>",
    "word-wrap": "normal|break-word",
    "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
    "z-index": "auto|<integer>",
    "zoom": "normal|reset|<number>|<percentage>",
    "-moz-background-clip": "padding|border",
    "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
    "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
    "-moz-border-radius-topleft": "<'border-top-left-radius'>",
    "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
    "-moz-control-character-visibility": "visible|hidden",
    "-moz-osx-font-smoothing": "auto|grayscale",
    "-moz-user-select": "none|text|all|-moz-none",
    "-ms-flex-align": "start|end|center|baseline|stretch",
    "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
    "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
    "-ms-flex-negative": "<'flex-shrink'>",
    "-ms-flex-pack": "start|end|center|justify|distribute",
    "-ms-flex-order": "<integer>",
    "-ms-flex-positive": "<'flex-grow'>",
    "-ms-flex-preferred-size": "<'flex-basis'>",
    "-ms-interpolation-mode": "nearest-neighbor|bicubic",
    "-ms-grid-column-align": "start|end|center|stretch",
    "-ms-grid-row-align": "start|end|center|stretch",
    "-ms-hyphenate-limit-last": "none|always|column|page|spread",
    "-webkit-background-clip": "[<box>|border|padding|content|text]#",
    "-webkit-column-break-after": "always|auto|avoid",
    "-webkit-column-break-before": "always|auto|avoid",
    "-webkit-column-break-inside": "always|auto|avoid",
    "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
    "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
    "-webkit-print-color-adjust": "economy|exact",
    "-webkit-text-security": "none|circle|disc|square",
    "-webkit-user-drag": "none|element|auto",
    "-webkit-user-select": "auto|none|text|all",
    "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
    "baseline-shift": "baseline|sub|super|<svg-length>",
    "behavior": "<url>+",
    "clip-rule": "nonzero|evenodd",
    "cue": "<'cue-before'> <'cue-after'>?",
    "cue-after": "<url> <decibel>?|none",
    "cue-before": "<url> <decibel>?|none",
    "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
    "fill": "<paint>",
    "fill-opacity": "<number-zero-one>",
    "fill-rule": "nonzero|evenodd",
    "glyph-orientation-horizontal": "<angle>",
    "glyph-orientation-vertical": "<angle>",
    "kerning": "auto|<svg-length>",
    "marker": "none|<url>",
    "marker-end": "none|<url>",
    "marker-mid": "none|<url>",
    "marker-start": "none|<url>",
    "pause": "<'pause-before'> <'pause-after'>?",
    "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest": "<'rest-before'> <'rest-after'>?",
    "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
    "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
    "speak": "auto|none|normal",
    "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
    "stroke": "<paint>",
    "stroke-dasharray": "none|[<svg-length>+]#",
    "stroke-dashoffset": "<svg-length>",
    "stroke-linecap": "butt|round|square",
    "stroke-linejoin": "miter|round|bevel",
    "stroke-miterlimit": "<number-one-or-greater>",
    "stroke-opacity": "<number-zero-one>",
    "stroke-width": "<svg-length>",
    "text-anchor": "start|middle|end",
    "unicode-range": "<urange>#",
    "voice-balance": "<number>|left|center|right|leftwards|rightwards",
    "voice-duration": "auto|<time>",
    "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
    "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
    "voice-stress": "normal|strong|moderate|none|reduced",
    "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]"
  },
  "atrules": {
    "charset": {
      "prelude": "<string>",
      "descriptors": null
    },
    "counter-style": {
      "prelude": "<counter-style-name>",
      "descriptors": {
        "additive-symbols": "[<integer>&&<symbol>]#",
        "fallback": "<counter-style-name>",
        "negative": "<symbol> <symbol>?",
        "pad": "<integer>&&<symbol>",
        "prefix": "<symbol>",
        "range": "[[<integer>|infinite]{2}]#|auto",
        "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
        "suffix": "<symbol>",
        "symbols": "<symbol>+",
        "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
      }
    },
    "document": {
      "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
      "descriptors": null
    },
    "font-face": {
      "prelude": null,
      "descriptors": {
        "ascent-override": "normal|<percentage>",
        "descent-override": "normal|<percentage>",
        "font-display": "[auto|block|swap|fallback|optional]",
        "font-family": "<family-name>",
        "font-feature-settings": "normal|<feature-tag-value>#",
        "font-variation-settings": "normal|[<string> <number>]#",
        "font-stretch": "<font-stretch-absolute>{1,2}",
        "font-style": "normal|italic|oblique <angle>{0,2}",
        "font-weight": "<font-weight-absolute>{1,2}",
        "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
        "line-gap-override": "normal|<percentage>",
        "size-adjust": "<percentage>",
        "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
        "unicode-range": "<urange>#"
      }
    },
    "font-feature-values": {
      "prelude": "<family-name>#",
      "descriptors": null
    },
    "import": {
      "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
      "descriptors": null
    },
    "keyframes": {
      "prelude": "<keyframes-name>",
      "descriptors": null
    },
    "layer": {
      "prelude": "[<layer-name>#|<layer-name>?]",
      "descriptors": null
    },
    "media": {
      "prelude": "<media-query-list>",
      "descriptors": null
    },
    "namespace": {
      "prelude": "<namespace-prefix>? [<string>|<url>]",
      "descriptors": null
    },
    "page": {
      "prelude": "<page-selector-list>",
      "descriptors": {
        "bleed": "auto|<length>",
        "marks": "none|[crop||cross]",
        "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
      }
    },
    "property": {
      "prelude": "<custom-property-name>",
      "descriptors": {
        "syntax": "<string>",
        "inherits": "true|false",
        "initial-value": "<string>"
      }
    },
    "scroll-timeline": {
      "prelude": "<timeline-name>",
      "descriptors": null
    },
    "supports": {
      "prelude": "<supports-condition>",
      "descriptors": null
    },
    "viewport": {
      "prelude": null,
      "descriptors": {
        "height": "<viewport-length>{1,2}",
        "max-height": "<viewport-length>",
        "max-width": "<viewport-length>",
        "max-zoom": "auto|<number>|<percentage>",
        "min-height": "<viewport-length>",
        "min-width": "<viewport-length>",
        "min-zoom": "auto|<number>|<percentage>",
        "orientation": "auto|portrait|landscape",
        "user-zoom": "zoom|fixed",
        "viewport-fit": "auto|contain|cover",
        "width": "<viewport-length>{1,2}",
        "zoom": "auto|<number>|<percentage>"
      }
    }
  }
};

// node_modules/css-tree/lib/syntax/node/index.js
var node_exports = {};
__export(node_exports, {
  AnPlusB: () => AnPlusB_exports,
  Atrule: () => Atrule_exports,
  AtrulePrelude: () => AtrulePrelude_exports,
  AttributeSelector: () => AttributeSelector_exports,
  Block: () => Block_exports,
  Brackets: () => Brackets_exports,
  CDC: () => CDC_exports,
  CDO: () => CDO_exports,
  ClassSelector: () => ClassSelector_exports,
  Combinator: () => Combinator_exports,
  Comment: () => Comment_exports,
  Declaration: () => Declaration_exports,
  DeclarationList: () => DeclarationList_exports,
  Dimension: () => Dimension_exports,
  Function: () => Function_exports,
  Hash: () => Hash_exports,
  IdSelector: () => IdSelector_exports,
  Identifier: () => Identifier_exports,
  MediaFeature: () => MediaFeature_exports,
  MediaQuery: () => MediaQuery_exports,
  MediaQueryList: () => MediaQueryList_exports,
  Nth: () => Nth_exports,
  Number: () => Number_exports,
  Operator: () => Operator_exports,
  Parentheses: () => Parentheses_exports,
  Percentage: () => Percentage_exports,
  PseudoClassSelector: () => PseudoClassSelector_exports,
  PseudoElementSelector: () => PseudoElementSelector_exports,
  Ratio: () => Ratio_exports,
  Raw: () => Raw_exports,
  Rule: () => Rule_exports,
  Selector: () => Selector_exports,
  SelectorList: () => SelectorList_exports,
  String: () => String_exports,
  StyleSheet: () => StyleSheet_exports,
  TypeSelector: () => TypeSelector_exports,
  UnicodeRange: () => UnicodeRange_exports,
  Url: () => Url_exports,
  Value: () => Value_exports,
  WhiteSpace: () => WhiteSpace_exports
});

// node_modules/css-tree/lib/syntax/node/AnPlusB.js
var AnPlusB_exports = {};
__export(AnPlusB_exports, {
  generate: () => generate2,
  name: () => name,
  parse: () => parse2,
  structure: () => structure
});
var PLUSSIGN5 = 43;
var HYPHENMINUS5 = 45;
var N5 = 110;
var DISALLOW_SIGN2 = true;
var ALLOW_SIGN2 = false;
function checkInteger2(offset, disallowSign) {
  let pos = this.tokenStart + offset;
  const code2 = this.charCodeAt(pos);
  if (code2 === PLUSSIGN5 || code2 === HYPHENMINUS5) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }
  for (; pos < this.tokenEnd; pos++) {
    if (!isDigit(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}
function checkTokenIsInteger(disallowSign) {
  return checkInteger2.call(this, 0, disallowSign);
}
function expectCharCode(offset, code2) {
  if (!this.cmpChar(this.tokenStart + offset, code2)) {
    let msg = "";
    switch (code2) {
      case N5:
        msg = "N is expected";
        break;
      case HYPHENMINUS5:
        msg = "HyphenMinus is expected";
        break;
    }
    this.error(msg, this.tokenStart + offset);
  }
}
function consumeB2() {
  let offset = 0;
  let sign = 0;
  let type = this.tokenType;
  while (type === WhiteSpace || type === Comment) {
    type = this.lookupType(++offset);
  }
  if (type !== Number2) {
    if (this.isDelim(PLUSSIGN5, offset) || this.isDelim(HYPHENMINUS5, offset)) {
      sign = this.isDelim(PLUSSIGN5, offset) ? PLUSSIGN5 : HYPHENMINUS5;
      do {
        type = this.lookupType(++offset);
      } while (type === WhiteSpace || type === Comment);
      if (type !== Number2) {
        this.skip(offset);
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
      }
    } else {
      return null;
    }
  }
  if (offset > 0) {
    this.skip(offset);
  }
  if (sign === 0) {
    type = this.charCodeAt(this.tokenStart);
    if (type !== PLUSSIGN5 && type !== HYPHENMINUS5) {
      this.error("Number sign is expected");
    }
  }
  checkTokenIsInteger.call(this, sign !== 0);
  return sign === HYPHENMINUS5 ? "-" + this.consume(Number2) : this.consume(Number2);
}
var name = "AnPlusB";
var structure = {
  a: [String, null],
  b: [String, null]
};
function parse2() {
  const start = this.tokenStart;
  let a2 = null;
  let b = null;
  if (this.tokenType === Number2) {
    checkTokenIsInteger.call(this, ALLOW_SIGN2);
    b = this.consume(Number2);
  } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS5)) {
    a2 = "-1";
    expectCharCode.call(this, 1, N5);
    switch (this.tokenEnd - this.tokenStart) {
      case 2:
        this.next();
        b = consumeB2.call(this);
        break;
      case 3:
        expectCharCode.call(this, 2, HYPHENMINUS5);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b = "-" + this.consume(Number2);
        break;
      default:
        expectCharCode.call(this, 2, HYPHENMINUS5);
        checkInteger2.call(this, 3, DISALLOW_SIGN2);
        this.next();
        b = this.substrToCursor(start + 2);
    }
  } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN5) && this.lookupType(1) === Ident) {
    let sign = 0;
    a2 = "1";
    if (this.isDelim(PLUSSIGN5)) {
      sign = 1;
      this.next();
    }
    expectCharCode.call(this, 0, N5);
    switch (this.tokenEnd - this.tokenStart) {
      case 1:
        this.next();
        b = consumeB2.call(this);
        break;
      case 2:
        expectCharCode.call(this, 1, HYPHENMINUS5);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b = "-" + this.consume(Number2);
        break;
      default:
        expectCharCode.call(this, 1, HYPHENMINUS5);
        checkInteger2.call(this, 2, DISALLOW_SIGN2);
        this.next();
        b = this.substrToCursor(start + sign + 1);
    }
  } else if (this.tokenType === Dimension) {
    const code2 = this.charCodeAt(this.tokenStart);
    const sign = code2 === PLUSSIGN5 || code2 === HYPHENMINUS5;
    let i2 = this.tokenStart + sign;
    for (; i2 < this.tokenEnd; i2++) {
      if (!isDigit(this.charCodeAt(i2))) {
        break;
      }
    }
    if (i2 === this.tokenStart + sign) {
      this.error("Integer is expected", this.tokenStart + sign);
    }
    expectCharCode.call(this, i2 - this.tokenStart, N5);
    a2 = this.substring(start, i2);
    if (i2 + 1 === this.tokenEnd) {
      this.next();
      b = consumeB2.call(this);
    } else {
      expectCharCode.call(this, i2 - this.tokenStart + 1, HYPHENMINUS5);
      if (i2 + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b = "-" + this.consume(Number2);
      } else {
        checkInteger2.call(this, i2 - this.tokenStart + 2, DISALLOW_SIGN2);
        this.next();
        b = this.substrToCursor(i2 + 1);
      }
    }
  } else {
    this.error();
  }
  if (a2 !== null && a2.charCodeAt(0) === PLUSSIGN5) {
    a2 = a2.substr(1);
  }
  if (b !== null && b.charCodeAt(0) === PLUSSIGN5) {
    b = b.substr(1);
  }
  return {
    type: "AnPlusB",
    loc: this.getLocation(start, this.tokenStart),
    a: a2,
    b
  };
}
function generate2(node) {
  if (node.a) {
    const a2 = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
    if (node.b) {
      const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
      this.tokenize(a2 + b);
    } else {
      this.tokenize(a2);
    }
  } else {
    this.tokenize(node.b);
  }
}

// node_modules/css-tree/lib/syntax/node/Atrule.js
var Atrule_exports = {};
__export(Atrule_exports, {
  generate: () => generate3,
  name: () => name2,
  parse: () => parse3,
  structure: () => structure2,
  walkContext: () => walkContext
});
function consumeRaw(startToken) {
  return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function isDeclarationBlockAtrule() {
  for (let offset = 1, type; type = this.lookupType(offset); offset++) {
    if (type === RightCurlyBracket) {
      return true;
    }
    if (type === LeftCurlyBracket || type === AtKeyword) {
      return false;
    }
  }
  return false;
}
var name2 = "Atrule";
var walkContext = "atrule";
var structure2 = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null]
};
function parse3() {
  const start = this.tokenStart;
  let name41;
  let nameLowerCase;
  let prelude = null;
  let block = null;
  this.eat(AtKeyword);
  name41 = this.substrToCursor(start + 1);
  nameLowerCase = name41.toLowerCase();
  this.skipSC();
  if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name41), consumeRaw);
    } else {
      prelude = consumeRaw.call(this, this.tokenIndex);
    }
    this.skipSC();
  }
  switch (this.tokenType) {
    case Semicolon:
      this.next();
      break;
    case LeftCurlyBracket:
      if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
        block = this.atrule[nameLowerCase].block.call(this);
      } else {
        block = this.Block(isDeclarationBlockAtrule.call(this));
      }
      break;
  }
  return {
    type: "Atrule",
    loc: this.getLocation(start, this.tokenStart),
    name: name41,
    prelude,
    block
  };
}
function generate3(node) {
  this.token(AtKeyword, "@" + node.name);
  if (node.prelude !== null) {
    this.node(node.prelude);
  }
  if (node.block) {
    this.node(node.block);
  } else {
    this.token(Semicolon, ";");
  }
}

// node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
var AtrulePrelude_exports = {};
__export(AtrulePrelude_exports, {
  generate: () => generate4,
  name: () => name3,
  parse: () => parse4,
  structure: () => structure3,
  walkContext: () => walkContext2
});
var name3 = "AtrulePrelude";
var walkContext2 = "atrulePrelude";
var structure3 = {
  children: [[]]
};
function parse4(name41) {
  let children = null;
  if (name41 !== null) {
    name41 = name41.toLowerCase();
  }
  this.skipSC();
  if (hasOwnProperty.call(this.atrule, name41) && typeof this.atrule[name41].prelude === "function") {
    children = this.atrule[name41].prelude.call(this);
  } else {
    children = this.readSequence(this.scope.AtrulePrelude);
  }
  this.skipSC();
  if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    this.error("Semicolon or block is expected");
  }
  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate4(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/AttributeSelector.js
var AttributeSelector_exports = {};
__export(AttributeSelector_exports, {
  generate: () => generate5,
  name: () => name4,
  parse: () => parse5,
  structure: () => structure4
});
var DOLLARSIGN = 36;
var ASTERISK2 = 42;
var EQUALSSIGN = 61;
var CIRCUMFLEXACCENT = 94;
var VERTICALLINE2 = 124;
var TILDE = 126;
function getAttributeName() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }
  const start = this.tokenStart;
  let expectIdent = false;
  if (this.isDelim(ASTERISK2)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE2)) {
    this.eat(Ident);
  }
  if (this.isDelim(VERTICALLINE2)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
      this.next();
      this.eat(Ident);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }
  return {
    type: "Identifier",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function getOperator() {
  const start = this.tokenStart;
  const code2 = this.charCodeAt(start);
  if (code2 !== EQUALSSIGN && // =
  code2 !== TILDE && // ~=
  code2 !== CIRCUMFLEXACCENT && // ^=
  code2 !== DOLLARSIGN && // $=
  code2 !== ASTERISK2 && // *=
  code2 !== VERTICALLINE2) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }
  this.next();
  if (code2 !== EQUALSSIGN) {
    if (!this.isDelim(EQUALSSIGN)) {
      this.error("Equal sign is expected");
    }
    this.next();
  }
  return this.substrToCursor(start);
}
var name4 = "AttributeSelector";
var structure4 = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null]
};
function parse5() {
  const start = this.tokenStart;
  let name41;
  let matcher = null;
  let value = null;
  let flags = null;
  this.eat(LeftSquareBracket);
  this.skipSC();
  name41 = getAttributeName.call(this);
  this.skipSC();
  if (this.tokenType !== RightSquareBracket) {
    if (this.tokenType !== Ident) {
      matcher = getOperator.call(this);
      this.skipSC();
      value = this.tokenType === String2 ? this.String() : this.Identifier();
      this.skipSC();
    }
    if (this.tokenType === Ident) {
      flags = this.consume(Ident);
      this.skipSC();
    }
  }
  this.eat(RightSquareBracket);
  return {
    type: "AttributeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name41,
    matcher,
    value,
    flags
  };
}
function generate5(node) {
  this.token(Delim, "[");
  this.node(node.name);
  if (node.matcher !== null) {
    this.tokenize(node.matcher);
    this.node(node.value);
  }
  if (node.flags !== null) {
    this.token(Ident, node.flags);
  }
  this.token(Delim, "]");
}

// node_modules/css-tree/lib/syntax/node/Block.js
var Block_exports = {};
__export(Block_exports, {
  generate: () => generate6,
  name: () => name5,
  parse: () => parse6,
  structure: () => structure5,
  walkContext: () => walkContext3
});
function consumeRaw2(startToken) {
  return this.Raw(startToken, null, true);
}
function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw2);
}
function consumeRawDeclaration(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
  if (this.tokenType === Semicolon) {
    return consumeRawDeclaration.call(this, this.tokenIndex);
  }
  const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
  if (this.tokenType === Semicolon) {
    this.next();
  }
  return node;
}
var name5 = "Block";
var walkContext3 = "block";
var structure5 = {
  children: [[
    "Atrule",
    "Rule",
    "Declaration"
  ]]
};
function parse6(isDeclaration) {
  const consumer = isDeclaration ? consumeDeclaration : consumeRule;
  const start = this.tokenStart;
  let children = this.createList();
  this.eat(LeftCurlyBracket);
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case RightCurlyBracket:
          break scan;
        case WhiteSpace:
        case Comment:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule, consumeRaw2));
          break;
        default:
          children.push(consumer.call(this));
      }
    }
  if (!this.eof) {
    this.eat(RightCurlyBracket);
  }
  return {
    type: "Block",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate6(node) {
  this.token(LeftCurlyBracket, "{");
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
  this.token(RightCurlyBracket, "}");
}

// node_modules/css-tree/lib/syntax/node/Brackets.js
var Brackets_exports = {};
__export(Brackets_exports, {
  generate: () => generate7,
  name: () => name6,
  parse: () => parse7,
  structure: () => structure6
});
var name6 = "Brackets";
var structure6 = {
  children: [[]]
};
function parse7(readSequence3, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftSquareBracket);
  children = readSequence3.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightSquareBracket);
  }
  return {
    type: "Brackets",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate7(node) {
  this.token(Delim, "[");
  this.children(node);
  this.token(Delim, "]");
}

// node_modules/css-tree/lib/syntax/node/CDC.js
var CDC_exports = {};
__export(CDC_exports, {
  generate: () => generate8,
  name: () => name7,
  parse: () => parse8,
  structure: () => structure7
});
var name7 = "CDC";
var structure7 = [];
function parse8() {
  const start = this.tokenStart;
  this.eat(CDC);
  return {
    type: "CDC",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate8() {
  this.token(CDC, "-->");
}

// node_modules/css-tree/lib/syntax/node/CDO.js
var CDO_exports = {};
__export(CDO_exports, {
  generate: () => generate9,
  name: () => name8,
  parse: () => parse9,
  structure: () => structure8
});
var name8 = "CDO";
var structure8 = [];
function parse9() {
  const start = this.tokenStart;
  this.eat(CDO);
  return {
    type: "CDO",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate9() {
  this.token(CDO, "<!--");
}

// node_modules/css-tree/lib/syntax/node/ClassSelector.js
var ClassSelector_exports = {};
__export(ClassSelector_exports, {
  generate: () => generate10,
  name: () => name9,
  parse: () => parse10,
  structure: () => structure9
});
var FULLSTOP = 46;
var name9 = "ClassSelector";
var structure9 = {
  name: String
};
function parse10() {
  this.eatDelim(FULLSTOP);
  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate10(node) {
  this.token(Delim, ".");
  this.token(Ident, node.name);
}

// node_modules/css-tree/lib/syntax/node/Combinator.js
var Combinator_exports = {};
__export(Combinator_exports, {
  generate: () => generate11,
  name: () => name10,
  parse: () => parse11,
  structure: () => structure10
});
var PLUSSIGN6 = 43;
var SOLIDUS = 47;
var GREATERTHANSIGN2 = 62;
var TILDE2 = 126;
var name10 = "Combinator";
var structure10 = {
  name: String
};
function parse11() {
  const start = this.tokenStart;
  let name41;
  switch (this.tokenType) {
    case WhiteSpace:
      name41 = " ";
      break;
    case Delim:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN2:
        case PLUSSIGN6:
        case TILDE2:
          this.next();
          break;
        case SOLIDUS:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS);
          break;
        default:
          this.error("Combinator is expected");
      }
      name41 = this.substrToCursor(start);
      break;
  }
  return {
    type: "Combinator",
    loc: this.getLocation(start, this.tokenStart),
    name: name41
  };
}
function generate11(node) {
  this.tokenize(node.name);
}

// node_modules/css-tree/lib/syntax/node/Comment.js
var Comment_exports = {};
__export(Comment_exports, {
  generate: () => generate12,
  name: () => name11,
  parse: () => parse12,
  structure: () => structure11
});
var ASTERISK3 = 42;
var SOLIDUS2 = 47;
var name11 = "Comment";
var structure11 = {
  value: String
};
function parse12() {
  const start = this.tokenStart;
  let end = this.tokenEnd;
  this.eat(Comment);
  if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK3 && this.charCodeAt(end - 1) === SOLIDUS2) {
    end -= 2;
  }
  return {
    type: "Comment",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substring(start + 2, end)
  };
}
function generate12(node) {
  this.token(Comment, "/*" + node.value + "*/");
}

// node_modules/css-tree/lib/syntax/node/Declaration.js
var Declaration_exports = {};
__export(Declaration_exports, {
  generate: () => generate13,
  name: () => name12,
  parse: () => parse13,
  structure: () => structure12,
  walkContext: () => walkContext4
});
var EXCLAMATIONMARK3 = 33;
var NUMBERSIGN3 = 35;
var DOLLARSIGN2 = 36;
var AMPERSAND2 = 38;
var ASTERISK4 = 42;
var PLUSSIGN7 = 43;
var SOLIDUS3 = 47;
function consumeValueRaw(startToken) {
  return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
}
function consumeCustomPropertyRaw(startToken) {
  return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
}
function consumeValue() {
  const startValueToken = this.tokenIndex;
  const value = this.Value();
  if (value.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK3) === false && this.isBalanceEdge(startValueToken) === false) {
    this.error();
  }
  return value;
}
var name12 = "Declaration";
var walkContext4 = "declaration";
var structure12 = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"]
};
function parse13() {
  const start = this.tokenStart;
  const startToken = this.tokenIndex;
  const property2 = readProperty2.call(this);
  const customProperty = isCustomProperty(property2);
  const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
  const consumeRaw7 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
  let important = false;
  let value;
  this.skipSC();
  this.eat(Colon);
  const valueStart = this.tokenIndex;
  if (!customProperty) {
    this.skipSC();
  }
  if (parseValue) {
    value = this.parseWithFallback(consumeValue, consumeRaw7);
  } else {
    value = consumeRaw7.call(this, this.tokenIndex);
  }
  if (customProperty && value.type === "Value" && value.children.isEmpty) {
    for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
      if (this.lookupType(offset) === WhiteSpace) {
        value.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " "
        });
        break;
      }
    }
  }
  if (this.isDelim(EXCLAMATIONMARK3)) {
    important = getImportant.call(this);
    this.skipSC();
  }
  if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
    this.error();
  }
  return {
    type: "Declaration",
    loc: this.getLocation(start, this.tokenStart),
    important,
    property: property2,
    value
  };
}
function generate13(node) {
  this.token(Ident, node.property);
  this.token(Colon, ":");
  this.node(node.value);
  if (node.important) {
    this.token(Delim, "!");
    this.token(Ident, node.important === true ? "important" : node.important);
  }
}
function readProperty2() {
  const start = this.tokenStart;
  if (this.tokenType === Delim) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK4:
      case DOLLARSIGN2:
      case PLUSSIGN7:
      case NUMBERSIGN3:
      case AMPERSAND2:
        this.next();
        break;
      case SOLIDUS3:
        this.next();
        if (this.isDelim(SOLIDUS3)) {
          this.next();
        }
        break;
    }
  }
  if (this.tokenType === Hash) {
    this.eat(Hash);
  } else {
    this.eat(Ident);
  }
  return this.substrToCursor(start);
}
function getImportant() {
  this.eat(Delim);
  this.skipSC();
  const important = this.consume(Ident);
  return important === "important" ? true : important;
}

// node_modules/css-tree/lib/syntax/node/DeclarationList.js
var DeclarationList_exports = {};
__export(DeclarationList_exports, {
  generate: () => generate14,
  name: () => name13,
  parse: () => parse14,
  structure: () => structure13
});
function consumeRaw3(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
var name13 = "DeclarationList";
var structure13 = {
  children: [[
    "Declaration"
  ]]
};
function parse14() {
  const children = this.createList();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
        case Comment:
        case Semicolon:
          this.next();
          break;
        default:
          children.push(this.parseWithFallback(this.Declaration, consumeRaw3));
      }
    }
  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate14(node) {
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
}

// node_modules/css-tree/lib/syntax/node/Dimension.js
var Dimension_exports = {};
__export(Dimension_exports, {
  generate: () => generate15,
  name: () => name14,
  parse: () => parse15,
  structure: () => structure14
});
var name14 = "Dimension";
var structure14 = {
  value: String,
  unit: String
};
function parse15() {
  const start = this.tokenStart;
  const value = this.consumeNumber(Dimension);
  return {
    type: "Dimension",
    loc: this.getLocation(start, this.tokenStart),
    value,
    unit: this.substring(start + value.length, this.tokenStart)
  };
}
function generate15(node) {
  this.token(Dimension, node.value + node.unit);
}

// node_modules/css-tree/lib/syntax/node/Function.js
var Function_exports = {};
__export(Function_exports, {
  generate: () => generate16,
  name: () => name15,
  parse: () => parse16,
  structure: () => structure15,
  walkContext: () => walkContext5
});
var name15 = "Function";
var walkContext5 = "function";
var structure15 = {
  name: String,
  children: [[]]
};
function parse16(readSequence3, recognizer) {
  const start = this.tokenStart;
  const name41 = this.consumeFunctionName();
  const nameLowerCase = name41.toLowerCase();
  let children;
  children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence3.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Function",
    loc: this.getLocation(start, this.tokenStart),
    name: name41,
    children
  };
}
function generate16(node) {
  this.token(Function, node.name + "(");
  this.children(node);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  generate: () => generate17,
  name: () => name16,
  parse: () => parse17,
  structure: () => structure16,
  xxx: () => xxx
});
var xxx = "XXX";
var name16 = "Hash";
var structure16 = {
  value: String
};
function parse17() {
  const start = this.tokenStart;
  this.eat(Hash);
  return {
    type: "Hash",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start + 1)
  };
}
function generate17(node) {
  this.token(Hash, "#" + node.value);
}

// node_modules/css-tree/lib/syntax/node/Identifier.js
var Identifier_exports = {};
__export(Identifier_exports, {
  generate: () => generate18,
  name: () => name17,
  parse: () => parse18,
  structure: () => structure17
});
var name17 = "Identifier";
var structure17 = {
  name: String
};
function parse18() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate18(node) {
  this.token(Ident, node.name);
}

// node_modules/css-tree/lib/syntax/node/IdSelector.js
var IdSelector_exports = {};
__export(IdSelector_exports, {
  generate: () => generate19,
  name: () => name18,
  parse: () => parse19,
  structure: () => structure18
});
var name18 = "IdSelector";
var structure18 = {
  name: String
};
function parse19() {
  const start = this.tokenStart;
  this.eat(Hash);
  return {
    type: "IdSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start + 1)
  };
}
function generate19(node) {
  this.token(Delim, "#" + node.name);
}

// node_modules/css-tree/lib/syntax/node/MediaFeature.js
var MediaFeature_exports = {};
__export(MediaFeature_exports, {
  generate: () => generate20,
  name: () => name19,
  parse: () => parse20,
  structure: () => structure19
});
var name19 = "MediaFeature";
var structure19 = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", null]
};
function parse20() {
  const start = this.tokenStart;
  let name41;
  let value = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  name41 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Ident:
        value = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "MediaFeature",
    loc: this.getLocation(start, this.tokenStart),
    name: name41,
    value
  };
}
function generate20(node) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node.name);
  if (node.value !== null) {
    this.token(Colon, ":");
    this.node(node.value);
  }
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/MediaQuery.js
var MediaQuery_exports = {};
__export(MediaQuery_exports, {
  generate: () => generate21,
  name: () => name20,
  parse: () => parse21,
  structure: () => structure20
});
var name20 = "MediaQuery";
var structure20 = {
  children: [[
    "Identifier",
    "MediaFeature",
    "WhiteSpace"
  ]]
};
function parse21() {
  const children = this.createList();
  let child = null;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = this.MediaFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate21(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/MediaQueryList.js
var MediaQueryList_exports = {};
__export(MediaQueryList_exports, {
  generate: () => generate22,
  name: () => name21,
  parse: () => parse22,
  structure: () => structure21
});
var name21 = "MediaQueryList";
var structure21 = {
  children: [[
    "MediaQuery"
  ]]
};
function parse22() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.MediaQuery());
    if (this.tokenType !== Comma) {
      break;
    }
    this.next();
  }
  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate22(node) {
  this.children(node, () => this.token(Comma, ","));
}

// node_modules/css-tree/lib/syntax/node/Nth.js
var Nth_exports = {};
__export(Nth_exports, {
  generate: () => generate23,
  name: () => name22,
  parse: () => parse23,
  structure: () => structure22
});
var name22 = "Nth";
var structure22 = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null]
};
function parse23() {
  this.skipSC();
  const start = this.tokenStart;
  let end = start;
  let selector2 = null;
  let nth2;
  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth2 = this.Identifier();
  } else {
    nth2 = this.AnPlusB();
  }
  end = this.tokenStart;
  this.skipSC();
  if (this.lookupValue(0, "of")) {
    this.next();
    selector2 = this.SelectorList();
    end = this.tokenStart;
  }
  return {
    type: "Nth",
    loc: this.getLocation(start, end),
    nth: nth2,
    selector: selector2
  };
}
function generate23(node) {
  this.node(node.nth);
  if (node.selector !== null) {
    this.token(Ident, "of");
    this.node(node.selector);
  }
}

// node_modules/css-tree/lib/syntax/node/Number.js
var Number_exports = {};
__export(Number_exports, {
  generate: () => generate24,
  name: () => name23,
  parse: () => parse24,
  structure: () => structure23
});
var name23 = "Number";
var structure23 = {
  value: String
};
function parse24() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(Number2)
  };
}
function generate24(node) {
  this.token(Number2, node.value);
}

// node_modules/css-tree/lib/syntax/node/Operator.js
var Operator_exports = {};
__export(Operator_exports, {
  generate: () => generate25,
  name: () => name24,
  parse: () => parse25,
  structure: () => structure24
});
var name24 = "Operator";
var structure24 = {
  value: String
};
function parse25() {
  const start = this.tokenStart;
  this.next();
  return {
    type: "Operator",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate25(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Parentheses.js
var Parentheses_exports = {};
__export(Parentheses_exports, {
  generate: () => generate26,
  name: () => name25,
  parse: () => parse26,
  structure: () => structure25
});
var name25 = "Parentheses";
var structure25 = {
  children: [[]]
};
function parse26(readSequence3, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftParenthesis);
  children = readSequence3.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Parentheses",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate26(node) {
  this.token(LeftParenthesis, "(");
  this.children(node);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/Percentage.js
var Percentage_exports = {};
__export(Percentage_exports, {
  generate: () => generate27,
  name: () => name26,
  parse: () => parse27,
  structure: () => structure26
});
var name26 = "Percentage";
var structure26 = {
  value: String
};
function parse27() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(Percentage)
  };
}
function generate27(node) {
  this.token(Percentage, node.value + "%");
}

// node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
var PseudoClassSelector_exports = {};
__export(PseudoClassSelector_exports, {
  generate: () => generate28,
  name: () => name27,
  parse: () => parse28,
  structure: () => structure27,
  walkContext: () => walkContext6
});
var name27 = "PseudoClassSelector";
var walkContext6 = "function";
var structure27 = {
  name: String,
  children: [["Raw"], null]
};
function parse28() {
  const start = this.tokenStart;
  let children = null;
  let name41;
  let nameLowerCase;
  this.eat(Colon);
  if (this.tokenType === Function) {
    name41 = this.consumeFunctionName();
    nameLowerCase = name41.toLowerCase();
    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name41 = this.consume(Ident);
  }
  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name41,
    children
  };
}
function generate28(node) {
  this.token(Colon, ":");
  if (node.children === null) {
    this.token(Ident, node.name);
  } else {
    this.token(Function, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }
}

// node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
var PseudoElementSelector_exports = {};
__export(PseudoElementSelector_exports, {
  generate: () => generate29,
  name: () => name28,
  parse: () => parse29,
  structure: () => structure28,
  walkContext: () => walkContext7
});
var name28 = "PseudoElementSelector";
var walkContext7 = "function";
var structure28 = {
  name: String,
  children: [["Raw"], null]
};
function parse29() {
  const start = this.tokenStart;
  let children = null;
  let name41;
  let nameLowerCase;
  this.eat(Colon);
  this.eat(Colon);
  if (this.tokenType === Function) {
    name41 = this.consumeFunctionName();
    nameLowerCase = name41.toLowerCase();
    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name41 = this.consume(Ident);
  }
  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name41,
    children
  };
}
function generate29(node) {
  this.token(Colon, ":");
  this.token(Colon, ":");
  if (node.children === null) {
    this.token(Ident, node.name);
  } else {
    this.token(Function, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }
}

// node_modules/css-tree/lib/syntax/node/Ratio.js
var Ratio_exports = {};
__export(Ratio_exports, {
  generate: () => generate30,
  name: () => name29,
  parse: () => parse30,
  structure: () => structure29
});
var SOLIDUS4 = 47;
var FULLSTOP2 = 46;
function consumeNumber2() {
  this.skipSC();
  const value = this.consume(Number2);
  for (let i2 = 0; i2 < value.length; i2++) {
    const code2 = value.charCodeAt(i2);
    if (!isDigit(code2) && code2 !== FULLSTOP2) {
      this.error("Unsigned number is expected", this.tokenStart - value.length + i2);
    }
  }
  if (Number(value) === 0) {
    this.error("Zero number is not allowed", this.tokenStart - value.length);
  }
  return value;
}
var name29 = "Ratio";
var structure29 = {
  left: String,
  right: String
};
function parse30() {
  const start = this.tokenStart;
  const left = consumeNumber2.call(this);
  let right;
  this.skipSC();
  this.eatDelim(SOLIDUS4);
  right = consumeNumber2.call(this);
  return {
    type: "Ratio",
    loc: this.getLocation(start, this.tokenStart),
    left,
    right
  };
}
function generate30(node) {
  this.token(Number2, node.left);
  this.token(Delim, "/");
  this.token(Number2, node.right);
}

// node_modules/css-tree/lib/syntax/node/Raw.js
var Raw_exports = {};
__export(Raw_exports, {
  generate: () => generate31,
  name: () => name30,
  parse: () => parse31,
  structure: () => structure30
});
function getOffsetExcludeWS() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === WhiteSpace) {
      return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
    }
  }
  return this.tokenStart;
}
var name30 = "Raw";
var structure30 = {
  value: String
};
function parse31(startToken, consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(startToken);
  let endOffset;
  this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS.call(this);
  } else {
    endOffset = this.tokenStart;
  }
  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset)
  };
}
function generate31(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Rule.js
var Rule_exports = {};
__export(Rule_exports, {
  generate: () => generate32,
  name: () => name31,
  parse: () => parse32,
  structure: () => structure31,
  walkContext: () => walkContext8
});
function consumeRaw4(startToken) {
  return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
}
function consumePrelude() {
  const prelude = this.SelectorList();
  if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
    this.error();
  }
  return prelude;
}
var name31 = "Rule";
var walkContext8 = "rule";
var structure31 = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"]
};
function parse32() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;
  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude, consumeRaw4);
  } else {
    prelude = consumeRaw4.call(this, startToken);
  }
  block = this.Block(true);
  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block
  };
}
function generate32(node) {
  this.node(node.prelude);
  this.node(node.block);
}

// node_modules/css-tree/lib/syntax/node/Selector.js
var Selector_exports = {};
__export(Selector_exports, {
  generate: () => generate33,
  name: () => name32,
  parse: () => parse33,
  structure: () => structure32
});
var name32 = "Selector";
var structure32 = {
  children: [[
    "TypeSelector",
    "IdSelector",
    "ClassSelector",
    "AttributeSelector",
    "PseudoClassSelector",
    "PseudoElementSelector",
    "Combinator",
    "WhiteSpace"
  ]]
};
function parse33() {
  const children = this.readSequence(this.scope.Selector);
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }
  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate33(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/SelectorList.js
var SelectorList_exports = {};
__export(SelectorList_exports, {
  generate: () => generate34,
  name: () => name33,
  parse: () => parse34,
  structure: () => structure33,
  walkContext: () => walkContext9
});
var name33 = "SelectorList";
var walkContext9 = "selector";
var structure33 = {
  children: [[
    "Selector",
    "Raw"
  ]]
};
function parse34() {
  const children = this.createList();
  while (!this.eof) {
    children.push(this.Selector());
    if (this.tokenType === Comma) {
      this.next();
      continue;
    }
    break;
  }
  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate34(node) {
  this.children(node, () => this.token(Comma, ","));
}

// node_modules/css-tree/lib/syntax/node/String.js
var String_exports = {};
__export(String_exports, {
  generate: () => generate35,
  name: () => name34,
  parse: () => parse35,
  structure: () => structure34
});

// node_modules/css-tree/lib/utils/string.js
var string_exports = {};
__export(string_exports, {
  decode: () => decode,
  encode: () => encode
});
var REVERSE_SOLIDUS = 92;
var QUOTATION_MARK = 34;
var APOSTROPHE2 = 39;
function decode(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE2 ? 1 : 0;
  const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
  let decoded = "";
  for (let i2 = start; i2 <= end; i2++) {
    let code2 = str.charCodeAt(i2);
    if (code2 === REVERSE_SOLIDUS) {
      if (i2 === end) {
        if (i2 !== len - 1) {
          decoded = str.substr(i2 + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i2);
      if (isValidEscape(REVERSE_SOLIDUS, code2)) {
        const escapeStart = i2 - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i2 = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i2 + 1) === 10) {
          i2++;
        }
      }
    } else {
      decoded += str[i2];
    }
  }
  return decoded;
}
function encode(str, apostrophe) {
  const quote = apostrophe ? "'" : '"';
  const quoteCode = apostrophe ? APOSTROPHE2 : QUOTATION_MARK;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i2 = 0; i2 < str.length; i2++) {
    const code2 = str.charCodeAt(i2);
    if (code2 === 0) {
      encoded += "\uFFFD";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === quoteCode || code2 === REVERSE_SOLIDUS) {
      encoded += "\\" + str.charAt(i2);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && (isHexDigit(code2) || isWhiteSpace(code2))) {
        encoded += " ";
      }
      encoded += str.charAt(i2);
      wsBeforeHexIsNeeded = false;
    }
  }
  return quote + encoded + quote;
}

// node_modules/css-tree/lib/syntax/node/String.js
var name34 = "String";
var structure34 = {
  value: String
};
function parse35() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: decode(this.consume(String2))
  };
}
function generate35(node) {
  this.token(String2, encode(node.value));
}

// node_modules/css-tree/lib/syntax/node/StyleSheet.js
var StyleSheet_exports = {};
__export(StyleSheet_exports, {
  generate: () => generate36,
  name: () => name35,
  parse: () => parse36,
  structure: () => structure35,
  walkContext: () => walkContext10
});
var EXCLAMATIONMARK4 = 33;
function consumeRaw5(startToken) {
  return this.Raw(startToken, null, false);
}
var name35 = "StyleSheet";
var walkContext10 = "stylesheet";
var structure35 = {
  children: [[
    "Comment",
    "CDO",
    "CDC",
    "Atrule",
    "Rule",
    "Raw"
  ]]
};
function parse36() {
  const start = this.tokenStart;
  const children = this.createList();
  let child;
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
          this.next();
          continue;
        case Comment:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK4) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case CDO:
          child = this.CDO();
          break;
        case CDC:
          child = this.CDC();
          break;
        case AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw5);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw5);
      }
      children.push(child);
    }
  return {
    type: "StyleSheet",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate36(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/TypeSelector.js
var TypeSelector_exports = {};
__export(TypeSelector_exports, {
  generate: () => generate37,
  name: () => name36,
  parse: () => parse37,
  structure: () => structure36
});
var ASTERISK5 = 42;
var VERTICALLINE3 = 124;
function eatIdentifierOrAsterisk() {
  if (this.tokenType !== Ident && this.isDelim(ASTERISK5) === false) {
    this.error("Identifier or asterisk is expected");
  }
  this.next();
}
var name36 = "TypeSelector";
var structure36 = {
  name: String
};
function parse37() {
  const start = this.tokenStart;
  if (this.isDelim(VERTICALLINE3)) {
    this.next();
    eatIdentifierOrAsterisk.call(this);
  } else {
    eatIdentifierOrAsterisk.call(this);
    if (this.isDelim(VERTICALLINE3)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    }
  }
  return {
    type: "TypeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function generate37(node) {
  this.tokenize(node.name);
}

// node_modules/css-tree/lib/syntax/node/UnicodeRange.js
var UnicodeRange_exports = {};
__export(UnicodeRange_exports, {
  generate: () => generate38,
  name: () => name37,
  parse: () => parse38,
  structure: () => structure37
});
var PLUSSIGN8 = 43;
var HYPHENMINUS6 = 45;
var QUESTIONMARK3 = 63;
function eatHexSequence(offset, allowDash) {
  let len = 0;
  for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
    const code2 = this.charCodeAt(pos);
    if (code2 === HYPHENMINUS6 && allowDash && len !== 0) {
      eatHexSequence.call(this, offset + len + 1, false);
      return -1;
    }
    if (!isHexDigit(code2)) {
      this.error(
        allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
        pos
      );
    }
    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
    ;
  }
  this.next();
  return len;
}
function eatQuestionMarkSequence(max) {
  let count = 0;
  while (this.isDelim(QUESTIONMARK3)) {
    if (++count > max) {
      this.error("Too many question marks");
    }
    this.next();
  }
}
function startsWith2(code2) {
  if (this.charCodeAt(this.tokenStart) !== code2) {
    this.error((code2 === PLUSSIGN8 ? "Plus sign" : "Hyphen minus") + " is expected");
  }
}
function scanUnicodeRange() {
  let hexLength = 0;
  switch (this.tokenType) {
    case Number2:
      hexLength = eatHexSequence.call(this, 1, true);
      if (this.isDelim(QUESTIONMARK3)) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
        break;
      }
      if (this.tokenType === Dimension || this.tokenType === Number2) {
        startsWith2.call(this, HYPHENMINUS6);
        eatHexSequence.call(this, 1, false);
        break;
      }
      break;
    case Dimension:
      hexLength = eatHexSequence.call(this, 1, true);
      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }
      break;
    default:
      this.eatDelim(PLUSSIGN8);
      if (this.tokenType === Ident) {
        hexLength = eatHexSequence.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      }
      if (this.isDelim(QUESTIONMARK3)) {
        this.next();
        eatQuestionMarkSequence.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
var name37 = "UnicodeRange";
var structure37 = {
  value: String
};
function parse38() {
  const start = this.tokenStart;
  this.eatIdent("u");
  scanUnicodeRange.call(this);
  return {
    type: "UnicodeRange",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate38(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Url.js
var Url_exports = {};
__export(Url_exports, {
  generate: () => generate39,
  name: () => name38,
  parse: () => parse39,
  structure: () => structure38
});

// node_modules/css-tree/lib/utils/url.js
var url_exports = {};
__export(url_exports, {
  decode: () => decode2,
  encode: () => encode2
});
var SPACE3 = 32;
var REVERSE_SOLIDUS2 = 92;
var QUOTATION_MARK2 = 34;
var APOSTROPHE3 = 39;
var LEFTPARENTHESIS3 = 40;
var RIGHTPARENTHESIS3 = 41;
function decode2(str) {
  const len = str.length;
  let start = 4;
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS3 ? len - 2 : len - 1;
  let decoded = "";
  while (start < end && isWhiteSpace(str.charCodeAt(start))) {
    start++;
  }
  while (start < end && isWhiteSpace(str.charCodeAt(end))) {
    end--;
  }
  for (let i2 = start; i2 <= end; i2++) {
    let code2 = str.charCodeAt(i2);
    if (code2 === REVERSE_SOLIDUS2) {
      if (i2 === end) {
        if (i2 !== len - 1) {
          decoded = str.substr(i2 + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i2);
      if (isValidEscape(REVERSE_SOLIDUS2, code2)) {
        const escapeStart = i2 - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i2 = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i2 + 1) === 10) {
          i2++;
        }
      }
    } else {
      decoded += str[i2];
    }
  }
  return decoded;
}
function encode2(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i2 = 0; i2 < str.length; i2++) {
    const code2 = str.charCodeAt(i2);
    if (code2 === 0) {
      encoded += "\uFFFD";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === SPACE3 || code2 === REVERSE_SOLIDUS2 || code2 === QUOTATION_MARK2 || code2 === APOSTROPHE3 || code2 === LEFTPARENTHESIS3 || code2 === RIGHTPARENTHESIS3) {
      encoded += "\\" + str.charAt(i2);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && isHexDigit(code2)) {
        encoded += " ";
      }
      encoded += str.charAt(i2);
      wsBeforeHexIsNeeded = false;
    }
  }
  return "url(" + encoded + ")";
}

// node_modules/css-tree/lib/syntax/node/Url.js
var name38 = "Url";
var structure38 = {
  value: String
};
function parse39() {
  const start = this.tokenStart;
  let value;
  switch (this.tokenType) {
    case Url:
      value = decode2(this.consume(Url));
      break;
    case Function:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }
      this.eat(Function);
      this.skipSC();
      value = decode(this.consume(String2));
      this.skipSC();
      if (!this.eof) {
        this.eat(RightParenthesis);
      }
      break;
    default:
      this.error("Url or Function is expected");
  }
  return {
    type: "Url",
    loc: this.getLocation(start, this.tokenStart),
    value
  };
}
function generate39(node) {
  this.token(Url, encode2(node.value));
}

// node_modules/css-tree/lib/syntax/node/Value.js
var Value_exports = {};
__export(Value_exports, {
  generate: () => generate40,
  name: () => name39,
  parse: () => parse40,
  structure: () => structure39
});
var name39 = "Value";
var structure39 = {
  children: [[]]
};
function parse40() {
  const start = this.tokenStart;
  const children = this.readSequence(this.scope.Value);
  return {
    type: "Value",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate40(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/WhiteSpace.js
var WhiteSpace_exports = {};
__export(WhiteSpace_exports, {
  generate: () => generate41,
  name: () => name40,
  parse: () => parse41,
  structure: () => structure40
});
var SPACE4 = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " "
});
var name40 = "WhiteSpace";
var structure40 = {
  value: String
};
function parse41() {
  this.eat(WhiteSpace);
  return SPACE4;
}
function generate41(node) {
  this.token(WhiteSpace, node.value);
}

// node_modules/css-tree/lib/syntax/config/lexer.js
var lexer_default = {
  generic: true,
  ...data_default,
  node: node_exports
};

// node_modules/css-tree/lib/syntax/scope/index.js
var scope_exports = {};
__export(scope_exports, {
  AtrulePrelude: () => atrulePrelude_default,
  Selector: () => selector_default,
  Value: () => value_default
});

// node_modules/css-tree/lib/syntax/scope/default.js
var NUMBERSIGN4 = 35;
var ASTERISK6 = 42;
var PLUSSIGN9 = 43;
var HYPHENMINUS7 = 45;
var SOLIDUS5 = 47;
var U2 = 117;
function defaultRecognizer(context) {
  switch (this.tokenType) {
    case Hash:
      return this.Hash();
    case Comma:
      return this.Operator();
    case LeftParenthesis:
      return this.Parentheses(this.readSequence, context.recognizer);
    case LeftSquareBracket:
      return this.Brackets(this.readSequence, context.recognizer);
    case String2:
      return this.String();
    case Dimension:
      return this.Dimension();
    case Percentage:
      return this.Percentage();
    case Number2:
      return this.Number();
    case Function:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
    case Url:
      return this.Url();
    case Ident:
      if (this.cmpChar(this.tokenStart, U2) && this.cmpChar(this.tokenStart + 1, PLUSSIGN9)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      if (code2 === SOLIDUS5 || code2 === ASTERISK6 || code2 === PLUSSIGN9 || code2 === HYPHENMINUS7) {
        return this.Operator();
      }
      if (code2 === NUMBERSIGN4) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }
      break;
    }
  }
}

// node_modules/css-tree/lib/syntax/scope/atrulePrelude.js
var atrulePrelude_default = {
  getNode: defaultRecognizer
};

// node_modules/css-tree/lib/syntax/scope/selector.js
var NUMBERSIGN5 = 35;
var ASTERISK7 = 42;
var PLUSSIGN10 = 43;
var SOLIDUS6 = 47;
var FULLSTOP3 = 46;
var GREATERTHANSIGN3 = 62;
var VERTICALLINE4 = 124;
var TILDE3 = 126;
function onWhiteSpace(next, children) {
  if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
    children.push({
      // FIXME: this.Combinator() should be used instead
      type: "Combinator",
      loc: null,
      name: " "
    });
  }
}
function getNode() {
  switch (this.tokenType) {
    case LeftSquareBracket:
      return this.AttributeSelector();
    case Hash:
      return this.IdSelector();
    case Colon:
      if (this.lookupType(1) === Colon) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }
    case Ident:
      return this.TypeSelector();
    case Number2:
    case Percentage:
      return this.Percentage();
    case Dimension:
      if (this.charCodeAt(this.tokenStart) === FULLSTOP3) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      switch (code2) {
        case PLUSSIGN10:
        case GREATERTHANSIGN3:
        case TILDE3:
        case SOLIDUS6:
          return this.Combinator();
        case FULLSTOP3:
          return this.ClassSelector();
        case ASTERISK7:
        case VERTICALLINE4:
          return this.TypeSelector();
        case NUMBERSIGN5:
          return this.IdSelector();
      }
      break;
    }
  }
}
var selector_default = {
  onWhiteSpace,
  getNode
};

// node_modules/css-tree/lib/syntax/function/expression.js
function expression_default() {
  return this.createSingleNodeList(
    this.Raw(this.tokenIndex, null, false)
  );
}

// node_modules/css-tree/lib/syntax/function/var.js
function var_default() {
  const children = this.createList();
  this.skipSC();
  children.push(this.Identifier());
  this.skipSC();
  if (this.tokenType === Comma) {
    children.push(this.Operator());
    const startIndex = this.tokenIndex;
    const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
    if (value.type === "Value" && value.children.isEmpty) {
      for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    children.push(value);
  }
  return children;
}

// node_modules/css-tree/lib/syntax/scope/value.js
function isPlusMinusOperator(node) {
  return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
}
var value_default = {
  getNode: defaultRecognizer,
  onWhiteSpace(next, children) {
    if (isPlusMinusOperator(next)) {
      next.value = " " + next.value;
    }
    if (isPlusMinusOperator(children.last)) {
      children.last.value += " ";
    }
  },
  "expression": expression_default,
  "var": var_default
};

// node_modules/css-tree/lib/syntax/atrule/font-face.js
var font_face_default = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/import.js
var import_default3 = {
  parse: {
    prelude() {
      const children = this.createList();
      this.skipSC();
      switch (this.tokenType) {
        case String2:
          children.push(this.String());
          break;
        case Url:
        case Function:
          children.push(this.Url());
          break;
        default:
          this.error("String or url() is expected");
      }
      if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
        children.push(this.MediaQueryList());
      }
      return children;
    },
    block: null
  }
};

// node_modules/css-tree/lib/syntax/atrule/media.js
var media_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.MediaQueryList()
      );
    },
    block() {
      return this.Block(false);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/page.js
var page_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/supports.js
function consumeRaw6() {
  return this.createSingleNodeList(
    this.Raw(this.tokenIndex, null, false)
  );
}
function parentheses() {
  this.skipSC();
  if (this.tokenType === Ident && this.lookupNonWSType(1) === Colon) {
    return this.createSingleNodeList(
      this.Declaration()
    );
  }
  return readSequence2.call(this);
}
function readSequence2() {
  const children = this.createList();
  let child;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Function:
          child = this.Function(consumeRaw6, this.scope.AtrulePrelude);
          break;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  return children;
}
var supports_default = {
  parse: {
    prelude() {
      const children = readSequence2.call(this);
      if (this.getFirstListNode(children) === null) {
        this.error("Condition is expected");
      }
      return children;
    },
    block() {
      return this.Block(false);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/index.js
var atrule_default = {
  "font-face": font_face_default,
  "import": import_default3,
  media: media_default,
  page: page_default,
  supports: supports_default
};

// node_modules/css-tree/lib/syntax/pseudo/index.js
var selectorList = {
  parse() {
    return this.createSingleNodeList(
      this.SelectorList()
    );
  }
};
var selector = {
  parse() {
    return this.createSingleNodeList(
      this.Selector()
    );
  }
};
var identList = {
  parse() {
    return this.createSingleNodeList(
      this.Identifier()
    );
  }
};
var nth = {
  parse() {
    return this.createSingleNodeList(
      this.Nth()
    );
  }
};
var pseudo_default = {
  "dir": identList,
  "has": selectorList,
  "lang": identList,
  "matches": selectorList,
  "is": selectorList,
  "-moz-any": selectorList,
  "-webkit-any": selectorList,
  "where": selectorList,
  "not": selectorList,
  "nth-child": nth,
  "nth-last-child": nth,
  "nth-last-of-type": nth,
  "nth-of-type": nth,
  "slotted": selector
};

// node_modules/css-tree/lib/syntax/node/index-parse.js
var index_parse_exports = {};
__export(index_parse_exports, {
  AnPlusB: () => parse2,
  Atrule: () => parse3,
  AtrulePrelude: () => parse4,
  AttributeSelector: () => parse5,
  Block: () => parse6,
  Brackets: () => parse7,
  CDC: () => parse8,
  CDO: () => parse9,
  ClassSelector: () => parse10,
  Combinator: () => parse11,
  Comment: () => parse12,
  Declaration: () => parse13,
  DeclarationList: () => parse14,
  Dimension: () => parse15,
  Function: () => parse16,
  Hash: () => parse17,
  IdSelector: () => parse19,
  Identifier: () => parse18,
  MediaFeature: () => parse20,
  MediaQuery: () => parse21,
  MediaQueryList: () => parse22,
  Nth: () => parse23,
  Number: () => parse24,
  Operator: () => parse25,
  Parentheses: () => parse26,
  Percentage: () => parse27,
  PseudoClassSelector: () => parse28,
  PseudoElementSelector: () => parse29,
  Ratio: () => parse30,
  Raw: () => parse31,
  Rule: () => parse32,
  Selector: () => parse33,
  SelectorList: () => parse34,
  String: () => parse35,
  StyleSheet: () => parse36,
  TypeSelector: () => parse37,
  UnicodeRange: () => parse38,
  Url: () => parse39,
  Value: () => parse40,
  WhiteSpace: () => parse41
});

// node_modules/css-tree/lib/syntax/config/parser.js
var parser_default = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value"
  },
  scope: scope_exports,
  atrule: atrule_default,
  pseudo: pseudo_default,
  node: index_parse_exports
};

// node_modules/css-tree/lib/syntax/config/walker.js
var walker_default = {
  node: node_exports
};

// node_modules/css-tree/lib/syntax/index.js
var syntax_default = create_default({
  ...lexer_default,
  ...parser_default,
  ...walker_default
});

// node_modules/css-tree/lib/utils/clone.js
function clone(node) {
  const result = {};
  for (const key in node) {
    let value = node[key];
    if (value) {
      if (Array.isArray(value) || value instanceof List) {
        value = value.map(clone);
      } else if (value.constructor === Object) {
        value = clone(value);
      }
    }
    result[key] = value;
  }
  return result;
}

// node_modules/css-tree/lib/utils/ident.js
var ident_exports = {};
__export(ident_exports, {
  decode: () => decode3,
  encode: () => encode3
});
var REVERSE_SOLIDUS3 = 92;
function decode3(str) {
  const end = str.length - 1;
  let decoded = "";
  for (let i2 = 0; i2 < str.length; i2++) {
    let code2 = str.charCodeAt(i2);
    if (code2 === REVERSE_SOLIDUS3) {
      if (i2 === end) {
        break;
      }
      code2 = str.charCodeAt(++i2);
      if (isValidEscape(REVERSE_SOLIDUS3, code2)) {
        const escapeStart = i2 - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i2 = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i2 + 1) === 10) {
          i2++;
        }
      }
    } else {
      decoded += str[i2];
    }
  }
  return decoded;
}
function encode3(str) {
  let encoded = "";
  if (str.length === 1 && str.charCodeAt(0) === 45) {
    return "\\-";
  }
  for (let i2 = 0; i2 < str.length; i2++) {
    const code2 = str.charCodeAt(i2);
    if (code2 === 0) {
      encoded += "\uFFFD";
      continue;
    }
    if (
      // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
      // Note: Do not compare with 0x0001 since 0x0000 is precessed before
      code2 <= 31 || code2 === 127 || // [or] ... is in the range [0-9] (U+0030 to U+0039),
      code2 >= 48 && code2 <= 57 && // If the character is the first character ...
      (i2 === 0 || // If the character is the second character ... and the first character is a "-" (U+002D)
      i2 === 1 && str.charCodeAt(0) === 45)
    ) {
      encoded += "\\" + code2.toString(16) + " ";
      continue;
    }
    if (isName(code2)) {
      encoded += str.charAt(i2);
    } else {
      encoded += "\\" + str.charAt(i2);
    }
  }
  return encoded;
}

// node_modules/css-tree/lib/index.js
var {
  tokenize: tokenize2,
  parse: parse42,
  generate: generate42,
  lexer,
  createLexer,
  walk: walk2,
  find,
  findLast,
  findAll,
  toPlainObject,
  fromPlainObject,
  fork
} = syntax_default;

// node_modules/csso/lib/usage.js
var { hasOwnProperty: hasOwnProperty6 } = Object.prototype;
function buildMap(list, caseInsensitive) {
  const map = /* @__PURE__ */ Object.create(null);
  if (!Array.isArray(list)) {
    return null;
  }
  for (let name41 of list) {
    if (caseInsensitive) {
      name41 = name41.toLowerCase();
    }
    map[name41] = true;
  }
  return map;
}
function buildList(data) {
  if (!data) {
    return null;
  }
  const tags = buildMap(data.tags, true);
  const ids = buildMap(data.ids);
  const classes = buildMap(data.classes);
  if (tags === null && ids === null && classes === null) {
    return null;
  }
  return {
    tags,
    ids,
    classes
  };
}
function buildIndex(data) {
  let scopes = false;
  if (data.scopes && Array.isArray(data.scopes)) {
    scopes = /* @__PURE__ */ Object.create(null);
    for (let i2 = 0; i2 < data.scopes.length; i2++) {
      const list = data.scopes[i2];
      if (!list || !Array.isArray(list)) {
        throw new Error("Wrong usage format");
      }
      for (const name41 of list) {
        if (hasOwnProperty6.call(scopes, name41)) {
          throw new Error(`Class can't be used for several scopes: ${name41}`);
        }
        scopes[name41] = i2 + 1;
      }
    }
  }
  return {
    whitelist: buildList(data),
    blacklist: buildList(data.blacklist),
    scopes
  };
}

// node_modules/csso/lib/clean/utils.js
function hasNoChildren(node) {
  return !node || !node.children || node.children.isEmpty;
}
function isNodeChildrenList(node, list) {
  return node !== null && node.children === list;
}

// node_modules/csso/lib/clean/Atrule.js
function cleanAtrule(node, item, list) {
  if (node.block) {
    if (this.stylesheet !== null) {
      this.stylesheet.firstAtrulesAllowed = false;
    }
    if (hasNoChildren(node.block)) {
      list.remove(item);
      return;
    }
  }
  switch (node.name) {
    case "charset":
      if (hasNoChildren(node.prelude)) {
        list.remove(item);
        return;
      }
      if (item.prev) {
        list.remove(item);
        return;
      }
      break;
    case "import":
      if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
        list.remove(item);
        return;
      }
      list.prevUntil(item.prev, function(rule) {
        if (rule.type === "Atrule") {
          if (rule.name === "import" || rule.name === "charset") {
            return;
          }
        }
        this.root.firstAtrulesAllowed = false;
        list.remove(item);
        return true;
      }, this);
      break;
    default: {
      const name41 = keyword(node.name).basename;
      if (name41 === "keyframes" || name41 === "media" || name41 === "supports") {
        if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
          list.remove(item);
        }
      }
    }
  }
}

// node_modules/csso/lib/clean/Comment.js
function cleanComment(data, item, list) {
  list.remove(item);
}

// node_modules/csso/lib/clean/Declaration.js
function cleanDeclartion(node, item, list) {
  if (node.value.children && node.value.children.isEmpty) {
    list.remove(item);
    return;
  }
  if (property(node.property).custom) {
    if (/\S/.test(node.value.value)) {
      node.value.value = node.value.value.trim();
    }
  }
}

// node_modules/csso/lib/clean/Raw.js
function cleanRaw(node, item, list) {
  if (isNodeChildrenList(this.stylesheet, list) || isNodeChildrenList(this.block, list)) {
    list.remove(item);
  }
}

// node_modules/csso/lib/clean/Rule.js
var { hasOwnProperty: hasOwnProperty7 } = Object.prototype;
var skipUsageFilteringAtrule = /* @__PURE__ */ new Set(["keyframes"]);
function cleanUnused(selectorList2, usageData) {
  selectorList2.children.forEach((selector2, item, list) => {
    let shouldRemove = false;
    walk2(selector2, function(node) {
      if (this.selector === null || this.selector === selectorList2) {
        switch (node.type) {
          case "SelectorList":
            if (this.function === null || this.function.name.toLowerCase() !== "not") {
              if (cleanUnused(node, usageData)) {
                shouldRemove = true;
              }
            }
            break;
          case "ClassSelector":
            if (usageData.whitelist !== null && usageData.whitelist.classes !== null && !hasOwnProperty7.call(usageData.whitelist.classes, node.name)) {
              shouldRemove = true;
            }
            if (usageData.blacklist !== null && usageData.blacklist.classes !== null && hasOwnProperty7.call(usageData.blacklist.classes, node.name)) {
              shouldRemove = true;
            }
            break;
          case "IdSelector":
            if (usageData.whitelist !== null && usageData.whitelist.ids !== null && !hasOwnProperty7.call(usageData.whitelist.ids, node.name)) {
              shouldRemove = true;
            }
            if (usageData.blacklist !== null && usageData.blacklist.ids !== null && hasOwnProperty7.call(usageData.blacklist.ids, node.name)) {
              shouldRemove = true;
            }
            break;
          case "TypeSelector":
            if (node.name.charAt(node.name.length - 1) !== "*") {
              if (usageData.whitelist !== null && usageData.whitelist.tags !== null && !hasOwnProperty7.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                shouldRemove = true;
              }
              if (usageData.blacklist !== null && usageData.blacklist.tags !== null && hasOwnProperty7.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                shouldRemove = true;
              }
            }
            break;
        }
      }
    });
    if (shouldRemove) {
      list.remove(item);
    }
  });
  return selectorList2.children.isEmpty;
}
function cleanRule(node, item, list, options) {
  if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
    list.remove(item);
    return;
  }
  if (this.atrule && skipUsageFilteringAtrule.has(keyword(this.atrule.name).basename)) {
    return;
  }
  const { usage } = options;
  if (usage && (usage.whitelist !== null || usage.blacklist !== null)) {
    cleanUnused(node.prelude, usage);
    if (hasNoChildren(node.prelude)) {
      list.remove(item);
      return;
    }
  }
}

// node_modules/csso/lib/clean/TypeSelector.js
function cleanTypeSelector(node, item, list) {
  const name41 = item.data.name;
  if (name41 !== "*") {
    return;
  }
  const nextType = item.next && item.next.data.type;
  if (nextType === "IdSelector" || nextType === "ClassSelector" || nextType === "AttributeSelector" || nextType === "PseudoClassSelector" || nextType === "PseudoElementSelector") {
    list.remove(item);
  }
}

// node_modules/csso/lib/clean/WhiteSpace.js
function cleanWhitespace(node, item, list) {
  list.remove(item);
}

// node_modules/csso/lib/clean/index.js
var handlers = {
  Atrule: cleanAtrule,
  Comment: cleanComment,
  Declaration: cleanDeclartion,
  Raw: cleanRaw,
  Rule: cleanRule,
  TypeSelector: cleanTypeSelector,
  WhiteSpace: cleanWhitespace
};
function clean_default(ast, options) {
  walk2(ast, {
    leave(node, item, list) {
      if (handlers.hasOwnProperty(node.type)) {
        handlers[node.type].call(this, node, item, list, options);
      }
    }
  });
}

// node_modules/csso/lib/replace/atrule/keyframes.js
function keyframes_default(node) {
  node.block.children.forEach((rule) => {
    rule.prelude.children.forEach((simpleselector) => {
      simpleselector.children.forEach((data, item) => {
        if (data.type === "Percentage" && data.value === "100") {
          item.data = {
            type: "TypeSelector",
            loc: data.loc,
            name: "to"
          };
        } else if (data.type === "TypeSelector" && data.name === "from") {
          item.data = {
            type: "Percentage",
            loc: data.loc,
            value: "0"
          };
        }
      });
    });
  });
}

// node_modules/csso/lib/replace/Atrule.js
function Atrule_default(node) {
  if (keyword(node.name).basename === "keyframes") {
    keyframes_default(node);
  }
}

// node_modules/csso/lib/replace/AttributeSelector.js
var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
function canUnquote(value) {
  if (value === "" || value === "-") {
    return false;
  }
  return !blockUnquoteRx.test(value);
}
function AttributeSelector_default(node) {
  const attrValue = node.value;
  if (!attrValue || attrValue.type !== "String") {
    return;
  }
  if (canUnquote(attrValue.value)) {
    node.value = {
      type: "Identifier",
      loc: attrValue.loc,
      name: attrValue.value
    };
  }
}

// node_modules/csso/lib/replace/property/font.js
function compressFont(node) {
  const list = node.children;
  list.forEachRight(function(node2, item) {
    if (node2.type === "Identifier") {
      if (node2.name === "bold") {
        item.data = {
          type: "Number",
          loc: node2.loc,
          value: "700"
        };
      } else if (node2.name === "normal") {
        const prev = item.prev;
        if (prev && prev.data.type === "Operator" && prev.data.value === "/") {
          this.remove(prev);
        }
        this.remove(item);
      }
    }
  });
  if (list.isEmpty) {
    list.insert(list.createItem({
      type: "Identifier",
      name: "normal"
    }));
  }
}

// node_modules/csso/lib/replace/property/font-weight.js
function compressFontWeight(node) {
  const value = node.children.head.data;
  if (value.type === "Identifier") {
    switch (value.name) {
      case "normal":
        node.children.head.data = {
          type: "Number",
          loc: value.loc,
          value: "400"
        };
        break;
      case "bold":
        node.children.head.data = {
          type: "Number",
          loc: value.loc,
          value: "700"
        };
        break;
    }
  }
}

// node_modules/csso/lib/replace/property/background.js
function compressBackground(node) {
  function flush() {
    if (!buffer.length) {
      buffer.unshift(
        {
          type: "Number",
          loc: null,
          value: "0"
        },
        {
          type: "Number",
          loc: null,
          value: "0"
        }
      );
    }
    newValue.push.apply(newValue, buffer);
    buffer = [];
  }
  let newValue = [];
  let buffer = [];
  node.children.forEach((node2) => {
    if (node2.type === "Operator" && node2.value === ",") {
      flush();
      newValue.push(node2);
      return;
    }
    if (node2.type === "Identifier") {
      if (node2.name === "transparent" || node2.name === "none" || node2.name === "repeat" || node2.name === "scroll") {
        return;
      }
    }
    buffer.push(node2);
  });
  flush();
  node.children = new List().fromArray(newValue);
}

// node_modules/csso/lib/replace/property/border.js
function compressBorder(node) {
  node.children.forEach((node2, item, list) => {
    if (node2.type === "Identifier" && node2.name.toLowerCase() === "none") {
      if (list.head === list.tail) {
        item.data = {
          type: "Number",
          loc: node2.loc,
          value: "0"
        };
      } else {
        list.remove(item);
      }
    }
  });
}

// node_modules/csso/lib/replace/Value.js
var handlers2 = {
  "font": compressFont,
  "font-weight": compressFontWeight,
  "background": compressBackground,
  "border": compressBorder,
  "outline": compressBorder
};
function compressValue(node) {
  if (!this.declaration) {
    return;
  }
  const property2 = property(this.declaration.property);
  if (handlers2.hasOwnProperty(property2.basename)) {
    handlers2[property2.basename](node);
  }
}

// node_modules/csso/lib/replace/Number.js
var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var unsafeToRemovePlusSignAfter = /* @__PURE__ */ new Set([
  "Dimension",
  "Hash",
  "Identifier",
  "Number",
  "Raw",
  "UnicodeRange"
]);
function packNumber(value, item) {
  const regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.has(item.prev.data.type) ? KEEP_PLUSSIGN : OMIT_PLUSSIGN;
  value = String(value).replace(regexp, "$1$2$3");
  if (value === "" || value === "-") {
    value = "0";
  }
  return value;
}
function Number3(node) {
  node.value = packNumber(node.value);
}

// node_modules/csso/lib/replace/Dimension.js
var MATH_FUNCTIONS = /* @__PURE__ */ new Set([
  "calc",
  "min",
  "max",
  "clamp"
]);
var LENGTH_UNIT = /* @__PURE__ */ new Set([
  // absolute length units
  "px",
  "mm",
  "cm",
  "in",
  "pt",
  "pc",
  // relative length units
  "em",
  "ex",
  "ch",
  "rem",
  // viewport-percentage lengths
  "vh",
  "vw",
  "vmin",
  "vmax",
  "vm"
]);
function compressDimension(node, item) {
  const value = packNumber(node.value);
  node.value = value;
  if (value === "0" && this.declaration !== null && this.atrulePrelude === null) {
    const unit = node.unit.toLowerCase();
    if (!LENGTH_UNIT.has(unit)) {
      return;
    }
    if (this.declaration.property === "-ms-flex" || this.declaration.property === "flex") {
      return;
    }
    if (this.function && MATH_FUNCTIONS.has(this.function.name)) {
      return;
    }
    item.data = {
      type: "Number",
      loc: node.loc,
      value
    };
  }
}

// node_modules/csso/lib/replace/Percentage.js
var blacklist = /* @__PURE__ */ new Set([
  // see https://github.com/jakubpawlowicz/clean-css/issues/957
  "width",
  "min-width",
  "max-width",
  "height",
  "min-height",
  "max-height",
  // issue #410: Don’t remove units in flex-basis value for (-ms-)flex shorthand
  // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
  // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
  "flex",
  "-ms-flex"
]);
function compressPercentage(node, item) {
  node.value = packNumber(node.value);
  if (node.value === "0" && this.declaration && !blacklist.has(this.declaration.property)) {
    item.data = {
      type: "Number",
      loc: node.loc,
      value: node.value
    };
    if (!lexer.matchDeclaration(this.declaration).isType(item.data, "length")) {
      item.data = node;
    }
  }
}

// node_modules/csso/lib/replace/Url.js
function Url_default(node) {
  node.value = node.value.replace(/\\/g, "/");
}

// node_modules/csso/lib/replace/color.js
var NAME_TO_HEX = {
  "aliceblue": "f0f8ff",
  "antiquewhite": "faebd7",
  "aqua": "0ff",
  "aquamarine": "7fffd4",
  "azure": "f0ffff",
  "beige": "f5f5dc",
  "bisque": "ffe4c4",
  "black": "000",
  "blanchedalmond": "ffebcd",
  "blue": "00f",
  "blueviolet": "8a2be2",
  "brown": "a52a2a",
  "burlywood": "deb887",
  "cadetblue": "5f9ea0",
  "chartreuse": "7fff00",
  "chocolate": "d2691e",
  "coral": "ff7f50",
  "cornflowerblue": "6495ed",
  "cornsilk": "fff8dc",
  "crimson": "dc143c",
  "cyan": "0ff",
  "darkblue": "00008b",
  "darkcyan": "008b8b",
  "darkgoldenrod": "b8860b",
  "darkgray": "a9a9a9",
  "darkgrey": "a9a9a9",
  "darkgreen": "006400",
  "darkkhaki": "bdb76b",
  "darkmagenta": "8b008b",
  "darkolivegreen": "556b2f",
  "darkorange": "ff8c00",
  "darkorchid": "9932cc",
  "darkred": "8b0000",
  "darksalmon": "e9967a",
  "darkseagreen": "8fbc8f",
  "darkslateblue": "483d8b",
  "darkslategray": "2f4f4f",
  "darkslategrey": "2f4f4f",
  "darkturquoise": "00ced1",
  "darkviolet": "9400d3",
  "deeppink": "ff1493",
  "deepskyblue": "00bfff",
  "dimgray": "696969",
  "dimgrey": "696969",
  "dodgerblue": "1e90ff",
  "firebrick": "b22222",
  "floralwhite": "fffaf0",
  "forestgreen": "228b22",
  "fuchsia": "f0f",
  "gainsboro": "dcdcdc",
  "ghostwhite": "f8f8ff",
  "gold": "ffd700",
  "goldenrod": "daa520",
  "gray": "808080",
  "grey": "808080",
  "green": "008000",
  "greenyellow": "adff2f",
  "honeydew": "f0fff0",
  "hotpink": "ff69b4",
  "indianred": "cd5c5c",
  "indigo": "4b0082",
  "ivory": "fffff0",
  "khaki": "f0e68c",
  "lavender": "e6e6fa",
  "lavenderblush": "fff0f5",
  "lawngreen": "7cfc00",
  "lemonchiffon": "fffacd",
  "lightblue": "add8e6",
  "lightcoral": "f08080",
  "lightcyan": "e0ffff",
  "lightgoldenrodyellow": "fafad2",
  "lightgray": "d3d3d3",
  "lightgrey": "d3d3d3",
  "lightgreen": "90ee90",
  "lightpink": "ffb6c1",
  "lightsalmon": "ffa07a",
  "lightseagreen": "20b2aa",
  "lightskyblue": "87cefa",
  "lightslategray": "789",
  "lightslategrey": "789",
  "lightsteelblue": "b0c4de",
  "lightyellow": "ffffe0",
  "lime": "0f0",
  "limegreen": "32cd32",
  "linen": "faf0e6",
  "magenta": "f0f",
  "maroon": "800000",
  "mediumaquamarine": "66cdaa",
  "mediumblue": "0000cd",
  "mediumorchid": "ba55d3",
  "mediumpurple": "9370db",
  "mediumseagreen": "3cb371",
  "mediumslateblue": "7b68ee",
  "mediumspringgreen": "00fa9a",
  "mediumturquoise": "48d1cc",
  "mediumvioletred": "c71585",
  "midnightblue": "191970",
  "mintcream": "f5fffa",
  "mistyrose": "ffe4e1",
  "moccasin": "ffe4b5",
  "navajowhite": "ffdead",
  "navy": "000080",
  "oldlace": "fdf5e6",
  "olive": "808000",
  "olivedrab": "6b8e23",
  "orange": "ffa500",
  "orangered": "ff4500",
  "orchid": "da70d6",
  "palegoldenrod": "eee8aa",
  "palegreen": "98fb98",
  "paleturquoise": "afeeee",
  "palevioletred": "db7093",
  "papayawhip": "ffefd5",
  "peachpuff": "ffdab9",
  "peru": "cd853f",
  "pink": "ffc0cb",
  "plum": "dda0dd",
  "powderblue": "b0e0e6",
  "purple": "800080",
  "rebeccapurple": "639",
  "red": "f00",
  "rosybrown": "bc8f8f",
  "royalblue": "4169e1",
  "saddlebrown": "8b4513",
  "salmon": "fa8072",
  "sandybrown": "f4a460",
  "seagreen": "2e8b57",
  "seashell": "fff5ee",
  "sienna": "a0522d",
  "silver": "c0c0c0",
  "skyblue": "87ceeb",
  "slateblue": "6a5acd",
  "slategray": "708090",
  "slategrey": "708090",
  "snow": "fffafa",
  "springgreen": "00ff7f",
  "steelblue": "4682b4",
  "tan": "d2b48c",
  "teal": "008080",
  "thistle": "d8bfd8",
  "tomato": "ff6347",
  "turquoise": "40e0d0",
  "violet": "ee82ee",
  "wheat": "f5deb3",
  "white": "fff",
  "whitesmoke": "f5f5f5",
  "yellow": "ff0",
  "yellowgreen": "9acd32"
};
var HEX_TO_NAME = {
  "800000": "maroon",
  "800080": "purple",
  "808000": "olive",
  "808080": "gray",
  "00ffff": "cyan",
  "f0ffff": "azure",
  "f5f5dc": "beige",
  "ffe4c4": "bisque",
  "000000": "black",
  "0000ff": "blue",
  "a52a2a": "brown",
  "ff7f50": "coral",
  "ffd700": "gold",
  "008000": "green",
  "4b0082": "indigo",
  "fffff0": "ivory",
  "f0e68c": "khaki",
  "00ff00": "lime",
  "faf0e6": "linen",
  "000080": "navy",
  "ffa500": "orange",
  "da70d6": "orchid",
  "cd853f": "peru",
  "ffc0cb": "pink",
  "dda0dd": "plum",
  "f00": "red",
  "ff0000": "red",
  "fa8072": "salmon",
  "a0522d": "sienna",
  "c0c0c0": "silver",
  "fffafa": "snow",
  "d2b48c": "tan",
  "008080": "teal",
  "ff6347": "tomato",
  "ee82ee": "violet",
  "f5deb3": "wheat",
  "ffffff": "white",
  "ffff00": "yellow"
};
function hueToRgb(p, q, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p + (q - p) * 6 * t2;
  }
  if (t2 < 1 / 2) {
    return q;
  }
  if (t2 < 2 / 3) {
    return p + (q - p) * (2 / 3 - t2) * 6;
  }
  return p;
}
function hslToRgb(h, s2, l2, a2) {
  let r2;
  let g;
  let b;
  if (s2 === 0) {
    r2 = g = b = l2;
  } else {
    const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const p = 2 * l2 - q;
    r2 = hueToRgb(p, q, h + 1 / 3);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1 / 3);
  }
  return [
    Math.round(r2 * 255),
    Math.round(g * 255),
    Math.round(b * 255),
    a2
  ];
}
function toHex(value) {
  value = value.toString(16);
  return value.length === 1 ? "0" + value : value;
}
function parseFunctionArgs(functionArgs, count, rgb) {
  let cursor = functionArgs.head;
  let args = [];
  let wasValue = false;
  while (cursor !== null) {
    const { type, value } = cursor.data;
    switch (type) {
      case "Number":
      case "Percentage":
        if (wasValue) {
          return;
        }
        wasValue = true;
        args.push({
          type,
          value: Number(value)
        });
        break;
      case "Operator":
        if (value === ",") {
          if (!wasValue) {
            return;
          }
          wasValue = false;
        } else if (wasValue || value !== "+") {
          return;
        }
        break;
      default:
        return;
    }
    cursor = cursor.next;
  }
  if (args.length !== count) {
    return;
  }
  if (args.length === 4) {
    if (args[3].type !== "Number") {
      return;
    }
    args[3].type = "Alpha";
  }
  if (rgb) {
    if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
      return;
    }
  } else {
    if (args[0].type !== "Number" || args[1].type !== "Percentage" || args[2].type !== "Percentage") {
      return;
    }
    args[0].type = "Angle";
  }
  return args.map(function(arg) {
    let value = Math.max(0, arg.value);
    switch (arg.type) {
      case "Number":
        value = Math.min(value, 255);
        break;
      case "Percentage":
        value = Math.min(value, 100) / 100;
        if (!rgb) {
          return value;
        }
        value = 255 * value;
        break;
      case "Angle":
        return (value % 360 + 360) % 360 / 360;
      case "Alpha":
        return Math.min(value, 1);
    }
    return Math.round(value);
  });
}
function compressFunction(node, item) {
  let functionName = node.name;
  let args;
  if (functionName === "rgba" || functionName === "hsla") {
    args = parseFunctionArgs(node.children, 4, functionName === "rgba");
    if (!args) {
      return;
    }
    if (functionName === "hsla") {
      args = hslToRgb(...args);
      node.name = "rgba";
    }
    if (args[3] === 0) {
      const scopeFunctionName = this.function && this.function.name;
      if (args[0] === 0 && args[1] === 0 && args[2] === 0 || !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {
        item.data = {
          type: "Identifier",
          loc: node.loc,
          name: "transparent"
        };
        return;
      }
    }
    if (args[3] !== 1) {
      node.children.forEach((node2, item2, list) => {
        if (node2.type === "Operator") {
          if (node2.value !== ",") {
            list.remove(item2);
          }
          return;
        }
        item2.data = {
          type: "Number",
          loc: node2.loc,
          value: packNumber(args.shift())
        };
      });
      return;
    }
    functionName = "rgb";
  }
  if (functionName === "hsl") {
    args = args || parseFunctionArgs(node.children, 3, false);
    if (!args) {
      return;
    }
    args = hslToRgb(...args);
    functionName = "rgb";
  }
  if (functionName === "rgb") {
    args = args || parseFunctionArgs(node.children, 3, true);
    if (!args) {
      return;
    }
    item.data = {
      type: "Hash",
      loc: node.loc,
      value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
    };
    compressHex(item.data, item);
  }
}
function compressIdent(node, item) {
  if (this.declaration === null) {
    return;
  }
  let color = node.name.toLowerCase();
  if (NAME_TO_HEX.hasOwnProperty(color) && lexer.matchDeclaration(this.declaration).isType(node, "color")) {
    const hex = NAME_TO_HEX[color];
    if (hex.length + 1 <= color.length) {
      item.data = {
        type: "Hash",
        loc: node.loc,
        value: hex
      };
    } else {
      if (color === "grey") {
        color = "gray";
      }
      node.name = color;
    }
  }
}
function compressHex(node, item) {
  let color = node.value.toLowerCase();
  if (color.length === 6 && color[0] === color[1] && color[2] === color[3] && color[4] === color[5]) {
    color = color[0] + color[2] + color[4];
  }
  if (HEX_TO_NAME[color]) {
    item.data = {
      type: "Identifier",
      loc: node.loc,
      name: HEX_TO_NAME[color]
    };
  } else {
    node.value = color;
  }
}

// node_modules/csso/lib/replace/index.js
var handlers3 = {
  Atrule: Atrule_default,
  AttributeSelector: AttributeSelector_default,
  Value: compressValue,
  Dimension: compressDimension,
  Percentage: compressPercentage,
  Number: Number3,
  Url: Url_default,
  Hash: compressHex,
  Identifier: compressIdent,
  Function: compressFunction
};
function replace_default(ast) {
  walk2(ast, {
    leave(node, item, list) {
      if (handlers3.hasOwnProperty(node.type)) {
        handlers3[node.type].call(this, node, item, list);
      }
    }
  });
}

// node_modules/csso/lib/restructure/prepare/createDeclarationIndexer.js
var Index = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  resolve(str) {
    let index = this.map.get(str);
    if (index === void 0) {
      index = this.map.size + 1;
      this.map.set(str, index);
    }
    return index;
  }
};
function createDeclarationIndexer() {
  const ids = new Index();
  return function markDeclaration(node) {
    const id = generate42(node);
    node.id = ids.resolve(id);
    node.length = id.length;
    node.fingerprint = null;
    return node;
  };
}

// node_modules/csso/lib/restructure/prepare/specificity.js
function ensureSelectorList(node) {
  if (node.type === "Raw") {
    return parse42(node.value, { context: "selectorList" });
  }
  return node;
}
function maxSpecificity(a2, b) {
  for (let i2 = 0; i2 < 3; i2++) {
    if (a2[i2] !== b[i2]) {
      return a2[i2] > b[i2] ? a2 : b;
    }
  }
  return a2;
}
function maxSelectorListSpecificity(selectorList2) {
  return ensureSelectorList(selectorList2).children.reduce(
    (result, node) => maxSpecificity(specificity(node), result),
    [0, 0, 0]
  );
}
function specificity(simpleSelector) {
  let A = 0;
  let B = 0;
  let C = 0;
  simpleSelector.children.forEach((node) => {
    switch (node.type) {
      case "IdSelector":
        A++;
        break;
      case "ClassSelector":
      case "AttributeSelector":
        B++;
        break;
      case "PseudoClassSelector":
        switch (node.name.toLowerCase()) {
          case "not":
          case "has":
          case "is":
          case "matches":
          case "-webkit-any":
          case "-moz-any": {
            const [a2, b, c2] = maxSelectorListSpecificity(node.children.first);
            A += a2;
            B += b;
            C += c2;
            break;
          }
          case "nth-child":
          case "nth-last-child": {
            const arg = node.children.first;
            if (arg.type === "Nth" && arg.selector) {
              const [a2, b, c2] = maxSelectorListSpecificity(arg.selector);
              A += a2;
              B += b + 1;
              C += c2;
            } else {
              B++;
            }
            break;
          }
          case "where":
            break;
          case "before":
          case "after":
          case "first-line":
          case "first-letter":
            C++;
            break;
          default:
            B++;
        }
        break;
      case "TypeSelector":
        if (!node.name.endsWith("*")) {
          C++;
        }
        break;
      case "PseudoElementSelector":
        C++;
        break;
    }
  });
  return [A, B, C];
}
var specificity_default = specificity;

// node_modules/csso/lib/restructure/prepare/processSelector.js
var nonFreezePseudoElements = /* @__PURE__ */ new Set([
  "first-letter",
  "first-line",
  "after",
  "before"
]);
var nonFreezePseudoClasses = /* @__PURE__ */ new Set([
  "link",
  "visited",
  "hover",
  "active",
  "first-letter",
  "first-line",
  "after",
  "before"
]);
function processSelector(node, usageData) {
  const pseudos = /* @__PURE__ */ new Set();
  node.prelude.children.forEach(function(simpleSelector) {
    let tagName = "*";
    let scope = 0;
    simpleSelector.children.forEach(function(node2) {
      switch (node2.type) {
        case "ClassSelector":
          if (usageData && usageData.scopes) {
            const classScope = usageData.scopes[node2.name] || 0;
            if (scope !== 0 && classScope !== scope) {
              throw new Error("Selector can't has classes from different scopes: " + generate42(simpleSelector));
            }
            scope = classScope;
          }
          break;
        case "PseudoClassSelector": {
          const name41 = node2.name.toLowerCase();
          if (!nonFreezePseudoClasses.has(name41)) {
            pseudos.add(`:${name41}`);
          }
          break;
        }
        case "PseudoElementSelector": {
          const name41 = node2.name.toLowerCase();
          if (!nonFreezePseudoElements.has(name41)) {
            pseudos.add(`::${name41}`);
          }
          break;
        }
        case "TypeSelector":
          tagName = node2.name.toLowerCase();
          break;
        case "AttributeSelector":
          if (node2.flags) {
            pseudos.add(`[${node2.flags.toLowerCase()}]`);
          }
          break;
        case "Combinator":
          tagName = "*";
          break;
      }
    });
    simpleSelector.compareMarker = specificity_default(simpleSelector).toString();
    simpleSelector.id = null;
    simpleSelector.id = generate42(simpleSelector);
    if (scope) {
      simpleSelector.compareMarker += ":" + scope;
    }
    if (tagName !== "*") {
      simpleSelector.compareMarker += "," + tagName;
    }
  });
  node.pseudoSignature = pseudos.size > 0 ? [...pseudos].sort().join(",") : false;
}

// node_modules/csso/lib/restructure/prepare/index.js
function prepare(ast, options) {
  const markDeclaration = createDeclarationIndexer();
  walk2(ast, {
    visit: "Rule",
    enter(node) {
      node.block.children.forEach(markDeclaration);
      processSelector(node, options.usage);
    }
  });
  walk2(ast, {
    visit: "Atrule",
    enter(node) {
      if (node.prelude) {
        node.prelude.id = null;
        node.prelude.id = generate42(node.prelude);
      }
      if (keyword(node.name).basename === "keyframes") {
        node.block.avoidRulesMerge = true;
        node.block.children.forEach(function(rule) {
          rule.prelude.children.forEach(function(simpleselector) {
            simpleselector.compareMarker = simpleselector.id;
          });
        });
      }
    }
  });
  return {
    declaration: markDeclaration
  };
}

// node_modules/csso/lib/restructure/1-mergeAtrule.js
var { hasOwnProperty: hasOwnProperty8 } = Object.prototype;
function addRuleToMap(map, item, list, single) {
  const node = item.data;
  const name41 = keyword(node.name).basename;
  const id = node.name.toLowerCase() + "/" + (node.prelude ? node.prelude.id : null);
  if (!hasOwnProperty8.call(map, name41)) {
    map[name41] = /* @__PURE__ */ Object.create(null);
  }
  if (single) {
    delete map[name41][id];
  }
  if (!hasOwnProperty8.call(map[name41], id)) {
    map[name41][id] = new List();
  }
  map[name41][id].append(list.remove(item));
}
function relocateAtrules(ast, options) {
  const collected = /* @__PURE__ */ Object.create(null);
  let topInjectPoint = null;
  ast.children.forEach(function(node, item, list) {
    if (node.type === "Atrule") {
      const name41 = keyword(node.name).basename;
      switch (name41) {
        case "keyframes":
          addRuleToMap(collected, item, list, true);
          return;
        case "media":
          if (options.forceMediaMerge) {
            addRuleToMap(collected, item, list, false);
            return;
          }
          break;
      }
      if (topInjectPoint === null && name41 !== "charset" && name41 !== "import") {
        topInjectPoint = item;
      }
    } else {
      if (topInjectPoint === null) {
        topInjectPoint = item;
      }
    }
  });
  for (const atrule in collected) {
    for (const id in collected[atrule]) {
      ast.children.insertList(
        collected[atrule][id],
        atrule === "media" ? null : topInjectPoint
      );
    }
  }
}
function isMediaRule(node) {
  return node.type === "Atrule" && node.name === "media";
}
function processAtrule(node, item, list) {
  if (!isMediaRule(node)) {
    return;
  }
  const prev = item.prev && item.prev.data;
  if (!prev || !isMediaRule(prev)) {
    return;
  }
  if (node.prelude && prev.prelude && node.prelude.id === prev.prelude.id) {
    prev.block.children.appendList(node.block.children);
    list.remove(item);
  }
}
function rejoinAtrule(ast, options) {
  relocateAtrules(ast, options);
  walk2(ast, {
    visit: "Atrule",
    reverse: true,
    enter: processAtrule
  });
}

// node_modules/csso/lib/restructure/utils.js
var { hasOwnProperty: hasOwnProperty9 } = Object.prototype;
function isEqualSelectors(a2, b) {
  let cursor1 = a2.head;
  let cursor2 = b.head;
  while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
    cursor1 = cursor1.next;
    cursor2 = cursor2.next;
  }
  return cursor1 === null && cursor2 === null;
}
function isEqualDeclarations(a2, b) {
  let cursor1 = a2.head;
  let cursor2 = b.head;
  while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
    cursor1 = cursor1.next;
    cursor2 = cursor2.next;
  }
  return cursor1 === null && cursor2 === null;
}
function compareDeclarations(declarations1, declarations2) {
  const result = {
    eq: [],
    ne1: [],
    ne2: [],
    ne2overrided: []
  };
  const fingerprints = /* @__PURE__ */ Object.create(null);
  const declarations2hash = /* @__PURE__ */ Object.create(null);
  for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
    declarations2hash[cursor.data.id] = true;
  }
  for (let cursor = declarations1.head; cursor; cursor = cursor.next) {
    const data = cursor.data;
    if (data.fingerprint) {
      fingerprints[data.fingerprint] = data.important;
    }
    if (declarations2hash[data.id]) {
      declarations2hash[data.id] = false;
      result.eq.push(data);
    } else {
      result.ne1.push(data);
    }
  }
  for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
    const data = cursor.data;
    if (declarations2hash[data.id]) {
      if (!hasOwnProperty9.call(fingerprints, data.fingerprint) || !fingerprints[data.fingerprint] && data.important) {
        result.ne2.push(data);
      }
      result.ne2overrided.push(data);
    }
  }
  return result;
}
function addSelectors(dest, source) {
  source.forEach((sourceData) => {
    const newStr = sourceData.id;
    let cursor = dest.head;
    while (cursor) {
      const nextStr = cursor.data.id;
      if (nextStr === newStr) {
        return;
      }
      if (nextStr > newStr) {
        break;
      }
      cursor = cursor.next;
    }
    dest.insert(dest.createItem(sourceData), cursor);
  });
  return dest;
}
function hasSimilarSelectors(selectors1, selectors2) {
  let cursor1 = selectors1.head;
  while (cursor1 !== null) {
    let cursor2 = selectors2.head;
    while (cursor2 !== null) {
      if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
        return true;
      }
      cursor2 = cursor2.next;
    }
    cursor1 = cursor1.next;
  }
  return false;
}
function unsafeToSkipNode(node) {
  switch (node.type) {
    case "Rule":
      return hasSimilarSelectors(node.prelude.children, this);
    case "Atrule":
      if (node.block) {
        return node.block.children.some(unsafeToSkipNode, this);
      }
      break;
    case "Declaration":
      return false;
  }
  return true;
}

// node_modules/csso/lib/restructure/2-initialMergeRuleset.js
function processRule(node, item, list) {
  const selectors = node.prelude.children;
  const declarations = node.block.children;
  list.prevUntil(item.prev, function(prev) {
    if (prev.type !== "Rule") {
      return unsafeToSkipNode.call(selectors, prev);
    }
    const prevSelectors = prev.prelude.children;
    const prevDeclarations = prev.block.children;
    if (node.pseudoSignature === prev.pseudoSignature) {
      if (isEqualSelectors(prevSelectors, selectors)) {
        prevDeclarations.appendList(declarations);
        list.remove(item);
        return true;
      }
      if (isEqualDeclarations(declarations, prevDeclarations)) {
        addSelectors(prevSelectors, selectors);
        list.remove(item);
        return true;
      }
    }
    return hasSimilarSelectors(selectors, prevSelectors);
  });
}
function initialMergeRule(ast) {
  walk2(ast, {
    visit: "Rule",
    enter: processRule
  });
}

// node_modules/csso/lib/restructure/3-disjoinRuleset.js
function processRule2(node, item, list) {
  const selectors = node.prelude.children;
  while (selectors.head !== selectors.tail) {
    const newSelectors = new List();
    newSelectors.insert(selectors.remove(selectors.head));
    list.insert(list.createItem({
      type: "Rule",
      loc: node.loc,
      prelude: {
        type: "SelectorList",
        loc: node.prelude.loc,
        children: newSelectors
      },
      block: {
        type: "Block",
        loc: node.block.loc,
        children: node.block.children.copy()
      },
      pseudoSignature: node.pseudoSignature
    }), item);
  }
}
function disjoinRule(ast) {
  walk2(ast, {
    visit: "Rule",
    reverse: true,
    enter: processRule2
  });
}

// node_modules/csso/lib/restructure/4-restructShorthand.js
var REPLACE = 1;
var REMOVE = 2;
var TOP = 0;
var RIGHT = 1;
var BOTTOM = 2;
var LEFT = 3;
var SIDES = ["top", "right", "bottom", "left"];
var SIDE = {
  "margin-top": "top",
  "margin-right": "right",
  "margin-bottom": "bottom",
  "margin-left": "left",
  "padding-top": "top",
  "padding-right": "right",
  "padding-bottom": "bottom",
  "padding-left": "left",
  "border-top-color": "top",
  "border-right-color": "right",
  "border-bottom-color": "bottom",
  "border-left-color": "left",
  "border-top-width": "top",
  "border-right-width": "right",
  "border-bottom-width": "bottom",
  "border-left-width": "left",
  "border-top-style": "top",
  "border-right-style": "right",
  "border-bottom-style": "bottom",
  "border-left-style": "left"
};
var MAIN_PROPERTY = {
  "margin": "margin",
  "margin-top": "margin",
  "margin-right": "margin",
  "margin-bottom": "margin",
  "margin-left": "margin",
  "padding": "padding",
  "padding-top": "padding",
  "padding-right": "padding",
  "padding-bottom": "padding",
  "padding-left": "padding",
  "border-color": "border-color",
  "border-top-color": "border-color",
  "border-right-color": "border-color",
  "border-bottom-color": "border-color",
  "border-left-color": "border-color",
  "border-width": "border-width",
  "border-top-width": "border-width",
  "border-right-width": "border-width",
  "border-bottom-width": "border-width",
  "border-left-width": "border-width",
  "border-style": "border-style",
  "border-top-style": "border-style",
  "border-right-style": "border-style",
  "border-bottom-style": "border-style",
  "border-left-style": "border-style"
};
var TRBL = class {
  constructor(name41) {
    this.name = name41;
    this.loc = null;
    this.iehack = void 0;
    this.sides = {
      "top": null,
      "right": null,
      "bottom": null,
      "left": null
    };
  }
  getValueSequence(declaration, count) {
    const values = [];
    let iehack = "";
    const hasBadValues = declaration.value.type !== "Value" || declaration.value.children.some(function(child) {
      let special = false;
      switch (child.type) {
        case "Identifier":
          switch (child.name) {
            case "\\0":
            case "\\9":
              iehack = child.name;
              return;
            case "inherit":
            case "initial":
            case "unset":
            case "revert":
              special = child.name;
              break;
          }
          break;
        case "Dimension":
          switch (child.unit) {
            case "rem":
            case "vw":
            case "vh":
            case "vmin":
            case "vmax":
            case "vm":
              special = child.unit;
              break;
          }
          break;
        case "Hash":
        case "Number":
        case "Percentage":
          break;
        case "Function":
          if (child.name === "var") {
            return true;
          }
          special = child.name;
          break;
        default:
          return true;
      }
      values.push({
        node: child,
        special,
        important: declaration.important
      });
    });
    if (hasBadValues || values.length > count) {
      return false;
    }
    if (typeof this.iehack === "string" && this.iehack !== iehack) {
      return false;
    }
    this.iehack = iehack;
    return values;
  }
  canOverride(side, value) {
    const currentValue = this.sides[side];
    return !currentValue || value.important && !currentValue.important;
  }
  add(name41, declaration) {
    function attemptToAdd() {
      const sides = this.sides;
      const side = SIDE[name41];
      if (side) {
        if (side in sides === false) {
          return false;
        }
        const values = this.getValueSequence(declaration, 1);
        if (!values || !values.length) {
          return false;
        }
        for (const key in sides) {
          if (sides[key] !== null && sides[key].special !== values[0].special) {
            return false;
          }
        }
        if (!this.canOverride(side, values[0])) {
          return true;
        }
        sides[side] = values[0];
        return true;
      } else if (name41 === this.name) {
        const values = this.getValueSequence(declaration, 4);
        if (!values || !values.length) {
          return false;
        }
        switch (values.length) {
          case 1:
            values[RIGHT] = values[TOP];
            values[BOTTOM] = values[TOP];
            values[LEFT] = values[TOP];
            break;
          case 2:
            values[BOTTOM] = values[TOP];
            values[LEFT] = values[RIGHT];
            break;
          case 3:
            values[LEFT] = values[RIGHT];
            break;
        }
        for (let i2 = 0; i2 < 4; i2++) {
          for (const key in sides) {
            if (sides[key] !== null && sides[key].special !== values[i2].special) {
              return false;
            }
          }
        }
        for (let i2 = 0; i2 < 4; i2++) {
          if (this.canOverride(SIDES[i2], values[i2])) {
            sides[SIDES[i2]] = values[i2];
          }
        }
        return true;
      }
    }
    if (!attemptToAdd.call(this)) {
      return false;
    }
    if (!this.loc) {
      this.loc = declaration.loc;
    }
    return true;
  }
  isOkToMinimize() {
    const top = this.sides.top;
    const right = this.sides.right;
    const bottom = this.sides.bottom;
    const left = this.sides.left;
    if (top && right && bottom && left) {
      const important = top.important + right.important + bottom.important + left.important;
      return important === 0 || important === 4;
    }
    return false;
  }
  getValue() {
    const result = new List();
    const sides = this.sides;
    const values = [
      sides.top,
      sides.right,
      sides.bottom,
      sides.left
    ];
    const stringValues = [
      generate42(sides.top.node),
      generate42(sides.right.node),
      generate42(sides.bottom.node),
      generate42(sides.left.node)
    ];
    if (stringValues[LEFT] === stringValues[RIGHT]) {
      values.pop();
      if (stringValues[BOTTOM] === stringValues[TOP]) {
        values.pop();
        if (stringValues[RIGHT] === stringValues[TOP]) {
          values.pop();
        }
      }
    }
    for (let i2 = 0; i2 < values.length; i2++) {
      result.appendData(values[i2].node);
    }
    if (this.iehack) {
      result.appendData({
        type: "Identifier",
        loc: null,
        name: this.iehack
      });
    }
    return {
      type: "Value",
      loc: null,
      children: result
    };
  }
  getDeclaration() {
    return {
      type: "Declaration",
      loc: this.loc,
      important: this.sides.top.important,
      property: this.name,
      value: this.getValue()
    };
  }
};
function processRule3(rule, shorts, shortDeclarations, lastShortSelector) {
  const declarations = rule.block.children;
  const selector2 = rule.prelude.children.first.id;
  rule.block.children.forEachRight(function(declaration, item) {
    const property2 = declaration.property;
    if (!MAIN_PROPERTY.hasOwnProperty(property2)) {
      return;
    }
    const key = MAIN_PROPERTY[property2];
    let shorthand;
    let operation;
    if (!lastShortSelector || selector2 === lastShortSelector) {
      if (key in shorts) {
        operation = REMOVE;
        shorthand = shorts[key];
      }
    }
    if (!shorthand || !shorthand.add(property2, declaration)) {
      operation = REPLACE;
      shorthand = new TRBL(key);
      if (!shorthand.add(property2, declaration)) {
        lastShortSelector = null;
        return;
      }
    }
    shorts[key] = shorthand;
    shortDeclarations.push({
      operation,
      block: declarations,
      item,
      shorthand
    });
    lastShortSelector = selector2;
  });
  return lastShortSelector;
}
function processShorthands(shortDeclarations, markDeclaration) {
  shortDeclarations.forEach(function(item) {
    const shorthand = item.shorthand;
    if (!shorthand.isOkToMinimize()) {
      return;
    }
    if (item.operation === REPLACE) {
      item.item.data = markDeclaration(shorthand.getDeclaration());
    } else {
      item.block.remove(item.item);
    }
  });
}
function restructBlock(ast, indexer) {
  const stylesheetMap = {};
  const shortDeclarations = [];
  walk2(ast, {
    visit: "Rule",
    reverse: true,
    enter(node) {
      const stylesheet = this.block || this.stylesheet;
      const ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first.id;
      let ruleMap;
      let shorts;
      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
        ruleMap = {
          lastShortSelector: null
        };
        stylesheetMap[stylesheet.id] = ruleMap;
      } else {
        ruleMap = stylesheetMap[stylesheet.id];
      }
      if (ruleMap.hasOwnProperty(ruleId)) {
        shorts = ruleMap[ruleId];
      } else {
        shorts = {};
        ruleMap[ruleId] = shorts;
      }
      ruleMap.lastShortSelector = processRule3.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
    }
  });
  processShorthands(shortDeclarations, indexer.declaration);
}

// node_modules/csso/lib/restructure/6-restructBlock.js
var fingerprintId = 1;
var dontRestructure = /* @__PURE__ */ new Set([
  "src"
  // https://github.com/afelix/csso/issues/50
]);
var DONT_MIX_VALUE = {
  // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
  "display": /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
  // https://developer.mozilla.org/en/docs/Web/CSS/text-align
  "text-align": /^(start|end|match-parent|justify-all)$/i
};
var SAFE_VALUES = {
  cursor: [
    "auto",
    "crosshair",
    "default",
    "move",
    "text",
    "wait",
    "help",
    "n-resize",
    "e-resize",
    "s-resize",
    "w-resize",
    "ne-resize",
    "nw-resize",
    "se-resize",
    "sw-resize",
    "pointer",
    "progress",
    "not-allowed",
    "no-drop",
    "vertical-text",
    "all-scroll",
    "col-resize",
    "row-resize"
  ],
  overflow: [
    "hidden",
    "visible",
    "scroll",
    "auto"
  ],
  position: [
    "static",
    "relative",
    "absolute",
    "fixed"
  ]
};
var NEEDLESS_TABLE = {
  "border-width": ["border"],
  "border-style": ["border"],
  "border-color": ["border"],
  "border-top": ["border"],
  "border-right": ["border"],
  "border-bottom": ["border"],
  "border-left": ["border"],
  "border-top-width": ["border-top", "border-width", "border"],
  "border-right-width": ["border-right", "border-width", "border"],
  "border-bottom-width": ["border-bottom", "border-width", "border"],
  "border-left-width": ["border-left", "border-width", "border"],
  "border-top-style": ["border-top", "border-style", "border"],
  "border-right-style": ["border-right", "border-style", "border"],
  "border-bottom-style": ["border-bottom", "border-style", "border"],
  "border-left-style": ["border-left", "border-style", "border"],
  "border-top-color": ["border-top", "border-color", "border"],
  "border-right-color": ["border-right", "border-color", "border"],
  "border-bottom-color": ["border-bottom", "border-color", "border"],
  "border-left-color": ["border-left", "border-color", "border"],
  "margin-top": ["margin"],
  "margin-right": ["margin"],
  "margin-bottom": ["margin"],
  "margin-left": ["margin"],
  "padding-top": ["padding"],
  "padding-right": ["padding"],
  "padding-bottom": ["padding"],
  "padding-left": ["padding"],
  "font-style": ["font"],
  "font-variant": ["font"],
  "font-weight": ["font"],
  "font-size": ["font"],
  "font-family": ["font"],
  "list-style-type": ["list-style"],
  "list-style-position": ["list-style"],
  "list-style-image": ["list-style"]
};
function getPropertyFingerprint(propertyName, declaration, fingerprints) {
  const realName = property(propertyName).basename;
  if (realName === "background") {
    return propertyName + ":" + generate42(declaration.value);
  }
  const declarationId = declaration.id;
  let fingerprint = fingerprints[declarationId];
  if (!fingerprint) {
    switch (declaration.value.type) {
      case "Value":
        const special = {};
        let vendorId = "";
        let iehack = "";
        let raw = false;
        declaration.value.children.forEach(function walk4(node) {
          switch (node.type) {
            case "Value":
            case "Brackets":
            case "Parentheses":
              node.children.forEach(walk4);
              break;
            case "Raw":
              raw = true;
              break;
            case "Identifier": {
              const { name: name41 } = node;
              if (!vendorId) {
                vendorId = keyword(name41).vendor;
              }
              if (/\\[09]/.test(name41)) {
                iehack = RegExp.lastMatch;
              }
              if (SAFE_VALUES.hasOwnProperty(realName)) {
                if (SAFE_VALUES[realName].indexOf(name41) === -1) {
                  special[name41] = true;
                }
              } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                if (DONT_MIX_VALUE[realName].test(name41)) {
                  special[name41] = true;
                }
              }
              break;
            }
            case "Function": {
              let { name: name41 } = node;
              if (!vendorId) {
                vendorId = keyword(name41).vendor;
              }
              if (name41 === "rect") {
                const hasComma = node.children.some(
                  (node2) => node2.type === "Operator" && node2.value === ","
                );
                if (!hasComma) {
                  name41 = "rect-backward";
                }
              }
              special[name41 + "()"] = true;
              node.children.forEach(walk4);
              break;
            }
            case "Dimension": {
              const { unit } = node;
              if (/\\[09]/.test(unit)) {
                iehack = RegExp.lastMatch;
              }
              switch (unit) {
                case "rem":
                case "vw":
                case "vh":
                case "vmin":
                case "vmax":
                case "vm":
                  special[unit] = true;
                  break;
              }
              break;
            }
          }
        });
        fingerprint = raw ? "!" + fingerprintId++ : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
        break;
      case "Raw":
        fingerprint = "!" + declaration.value.value;
        break;
      default:
        fingerprint = generate42(declaration.value);
    }
    fingerprints[declarationId] = fingerprint;
  }
  return propertyName + fingerprint;
}
function needless(props, declaration, fingerprints) {
  const property2 = property(declaration.property);
  if (NEEDLESS_TABLE.hasOwnProperty(property2.basename)) {
    const table = NEEDLESS_TABLE[property2.basename];
    for (const entry of table) {
      const ppre = getPropertyFingerprint(property2.prefix + entry, declaration, fingerprints);
      const prev = props.hasOwnProperty(ppre) ? props[ppre] : null;
      if (prev && (!declaration.important || prev.item.data.important)) {
        return prev;
      }
    }
  }
}
function processRule4(rule, item, list, props, fingerprints) {
  const declarations = rule.block.children;
  declarations.forEachRight(function(declaration, declarationItem) {
    const { property: property2 } = declaration;
    const fingerprint = getPropertyFingerprint(property2, declaration, fingerprints);
    const prev = props[fingerprint];
    if (prev && !dontRestructure.has(property2)) {
      if (declaration.important && !prev.item.data.important) {
        props[fingerprint] = {
          block: declarations,
          item: declarationItem
        };
        prev.block.remove(prev.item);
      } else {
        declarations.remove(declarationItem);
      }
    } else {
      const prev2 = needless(props, declaration, fingerprints);
      if (prev2) {
        declarations.remove(declarationItem);
      } else {
        declaration.fingerprint = fingerprint;
        props[fingerprint] = {
          block: declarations,
          item: declarationItem
        };
      }
    }
  });
  if (declarations.isEmpty) {
    list.remove(item);
  }
}
function restructBlock2(ast) {
  const stylesheetMap = {};
  const fingerprints = /* @__PURE__ */ Object.create(null);
  walk2(ast, {
    visit: "Rule",
    reverse: true,
    enter(node, item, list) {
      const stylesheet = this.block || this.stylesheet;
      const ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first.id;
      let ruleMap;
      let props;
      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
        ruleMap = {};
        stylesheetMap[stylesheet.id] = ruleMap;
      } else {
        ruleMap = stylesheetMap[stylesheet.id];
      }
      if (ruleMap.hasOwnProperty(ruleId)) {
        props = ruleMap[ruleId];
      } else {
        props = {};
        ruleMap[ruleId] = props;
      }
      processRule4.call(this, node, item, list, props, fingerprints);
    }
  });
}

// node_modules/csso/lib/restructure/7-mergeRuleset.js
function processRule5(node, item, list) {
  const selectors = node.prelude.children;
  const declarations = node.block.children;
  const nodeCompareMarker = selectors.first.compareMarker;
  const skippedCompareMarkers = {};
  list.nextUntil(item.next, function(next, nextItem) {
    if (next.type !== "Rule") {
      return unsafeToSkipNode.call(selectors, next);
    }
    if (node.pseudoSignature !== next.pseudoSignature) {
      return true;
    }
    const nextFirstSelector = next.prelude.children.head;
    const nextDeclarations = next.block.children;
    const nextCompareMarker = nextFirstSelector.data.compareMarker;
    if (nextCompareMarker in skippedCompareMarkers) {
      return true;
    }
    if (selectors.head === selectors.tail) {
      if (selectors.first.id === nextFirstSelector.data.id) {
        declarations.appendList(nextDeclarations);
        list.remove(nextItem);
        return;
      }
    }
    if (isEqualDeclarations(declarations, nextDeclarations)) {
      const nextStr = nextFirstSelector.data.id;
      selectors.some((data, item2) => {
        const curStr = data.id;
        if (nextStr < curStr) {
          selectors.insert(nextFirstSelector, item2);
          return true;
        }
        if (!item2.next) {
          selectors.insert(nextFirstSelector);
          return true;
        }
      });
      list.remove(nextItem);
      return;
    }
    if (nextCompareMarker === nodeCompareMarker) {
      return true;
    }
    skippedCompareMarkers[nextCompareMarker] = true;
  });
}
function mergeRule(ast) {
  walk2(ast, {
    visit: "Rule",
    enter: processRule5
  });
}

// node_modules/csso/lib/restructure/8-restructRuleset.js
function calcSelectorLength(list) {
  return list.reduce((res, data) => res + data.id.length + 1, 0) - 1;
}
function calcDeclarationsLength(tokens) {
  let length = 0;
  for (const token of tokens) {
    length += token.length;
  }
  return length + // declarations
  tokens.length - 1;
}
function processRule6(node, item, list) {
  const avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
  const selectors = node.prelude.children;
  const block = node.block;
  const disallowDownMarkers = /* @__PURE__ */ Object.create(null);
  let allowMergeUp = true;
  let allowMergeDown = true;
  list.prevUntil(item.prev, function(prev, prevItem) {
    const prevBlock = prev.block;
    const prevType = prev.type;
    if (prevType !== "Rule") {
      const unsafe = unsafeToSkipNode.call(selectors, prev);
      if (!unsafe && prevType === "Atrule" && prevBlock) {
        walk2(prevBlock, {
          visit: "Rule",
          enter(node2) {
            node2.prelude.children.forEach((data) => {
              disallowDownMarkers[data.compareMarker] = true;
            });
          }
        });
      }
      return unsafe;
    }
    if (node.pseudoSignature !== prev.pseudoSignature) {
      return true;
    }
    const prevSelectors = prev.prelude.children;
    allowMergeDown = !prevSelectors.some(
      (selector2) => selector2.compareMarker in disallowDownMarkers
    );
    if (!allowMergeDown && !allowMergeUp) {
      return true;
    }
    if (allowMergeUp && isEqualSelectors(prevSelectors, selectors)) {
      prevBlock.children.appendList(block.children);
      list.remove(item);
      return true;
    }
    const diff = compareDeclarations(block.children, prevBlock.children);
    if (diff.eq.length) {
      if (!diff.ne1.length && !diff.ne2.length) {
        if (allowMergeDown) {
          addSelectors(selectors, prevSelectors);
          list.remove(prevItem);
        }
        return true;
      } else if (!avoidRulesMerge) {
        if (diff.ne1.length && !diff.ne2.length) {
          const selectorLength = calcSelectorLength(selectors);
          const blockLength = calcDeclarationsLength(diff.eq);
          if (allowMergeUp && selectorLength < blockLength) {
            addSelectors(prevSelectors, selectors);
            block.children.fromArray(diff.ne1);
          }
        } else if (!diff.ne1.length && diff.ne2.length) {
          const selectorLength = calcSelectorLength(prevSelectors);
          const blockLength = calcDeclarationsLength(diff.eq);
          if (allowMergeDown && selectorLength < blockLength) {
            addSelectors(selectors, prevSelectors);
            prevBlock.children.fromArray(diff.ne2);
          }
        } else {
          const newSelector = {
            type: "SelectorList",
            loc: null,
            children: addSelectors(prevSelectors.copy(), selectors)
          };
          const newBlockLength = calcSelectorLength(newSelector.children) + 2;
          const blockLength = calcDeclarationsLength(diff.eq);
          if (blockLength >= newBlockLength) {
            const newItem = list.createItem({
              type: "Rule",
              loc: null,
              prelude: newSelector,
              block: {
                type: "Block",
                loc: null,
                children: new List().fromArray(diff.eq)
              },
              pseudoSignature: node.pseudoSignature
            });
            block.children.fromArray(diff.ne1);
            prevBlock.children.fromArray(diff.ne2overrided);
            if (allowMergeUp) {
              list.insert(newItem, prevItem);
            } else {
              list.insert(newItem, item);
            }
            return true;
          }
        }
      }
    }
    if (allowMergeUp) {
      allowMergeUp = !prevSelectors.some(
        (prevSelector) => selectors.some(
          (selector2) => selector2.compareMarker === prevSelector.compareMarker
        )
      );
    }
    prevSelectors.forEach((data) => {
      disallowDownMarkers[data.compareMarker] = true;
    });
  });
}
function restructRule(ast) {
  walk2(ast, {
    visit: "Rule",
    reverse: true,
    enter: processRule6
  });
}

// node_modules/csso/lib/restructure/index.js
function restructure_default(ast, options) {
  const indexer = prepare(ast, options);
  options.logger("prepare", ast);
  rejoinAtrule(ast, options);
  options.logger("mergeAtrule", ast);
  initialMergeRule(ast);
  options.logger("initialMergeRuleset", ast);
  disjoinRule(ast);
  options.logger("disjoinRuleset", ast);
  restructBlock(ast, indexer);
  options.logger("restructShorthand", ast);
  restructBlock2(ast);
  options.logger("restructBlock", ast);
  mergeRule(ast);
  options.logger("mergeRuleset", ast);
  restructRule(ast);
  options.logger("restructRuleset", ast);
}

// node_modules/csso/lib/compress.js
function readChunk(input, specialComments) {
  const children = new List();
  let nonSpaceTokenInBuffer = false;
  let protectedComment;
  input.nextUntil(input.head, (node, item, list) => {
    if (node.type === "Comment") {
      if (!specialComments || node.value.charAt(0) !== "!") {
        list.remove(item);
        return;
      }
      if (nonSpaceTokenInBuffer || protectedComment) {
        return true;
      }
      list.remove(item);
      protectedComment = node;
      return;
    }
    if (node.type !== "WhiteSpace") {
      nonSpaceTokenInBuffer = true;
    }
    children.insert(list.remove(item));
  });
  return {
    comment: protectedComment,
    stylesheet: {
      type: "StyleSheet",
      loc: null,
      children
    }
  };
}
function compressChunk(ast, firstAtrulesAllowed, num, options) {
  options.logger(`Compress block #${num}`, null, true);
  let seed = 1;
  if (ast.type === "StyleSheet") {
    ast.firstAtrulesAllowed = firstAtrulesAllowed;
    ast.id = seed++;
  }
  walk2(ast, {
    visit: "Atrule",
    enter(node) {
      if (node.block !== null) {
        node.block.id = seed++;
      }
    }
  });
  options.logger("init", ast);
  clean_default(ast, options);
  options.logger("clean", ast);
  replace_default(ast, options);
  options.logger("replace", ast);
  if (options.restructuring) {
    restructure_default(ast, options);
  }
  return ast;
}
function getCommentsOption(options) {
  let comments = "comments" in options ? options.comments : "exclamation";
  if (typeof comments === "boolean") {
    comments = comments ? "exclamation" : false;
  } else if (comments !== "exclamation" && comments !== "first-exclamation") {
    comments = false;
  }
  return comments;
}
function getRestructureOption(options) {
  if ("restructure" in options) {
    return options.restructure;
  }
  return "restructuring" in options ? options.restructuring : true;
}
function wrapBlock(block) {
  return new List().appendData({
    type: "Rule",
    loc: null,
    prelude: {
      type: "SelectorList",
      loc: null,
      children: new List().appendData({
        type: "Selector",
        loc: null,
        children: new List().appendData({
          type: "TypeSelector",
          loc: null,
          name: "x"
        })
      })
    },
    block
  });
}
function compress2(ast, options) {
  ast = ast || { type: "StyleSheet", loc: null, children: new List() };
  options = options || {};
  const compressOptions = {
    logger: typeof options.logger === "function" ? options.logger : function() {
    },
    restructuring: getRestructureOption(options),
    forceMediaMerge: Boolean(options.forceMediaMerge),
    usage: options.usage ? buildIndex(options.usage) : false
  };
  const output = new List();
  let specialComments = getCommentsOption(options);
  let firstAtrulesAllowed = true;
  let input;
  let chunk;
  let chunkNum = 1;
  let chunkChildren;
  if (options.clone) {
    ast = clone(ast);
  }
  if (ast.type === "StyleSheet") {
    input = ast.children;
    ast.children = output;
  } else {
    input = wrapBlock(ast);
  }
  do {
    chunk = readChunk(input, Boolean(specialComments));
    compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
    chunkChildren = chunk.stylesheet.children;
    if (chunk.comment) {
      if (!output.isEmpty) {
        output.insert(List.createItem({
          type: "Raw",
          value: "\n"
        }));
      }
      output.insert(List.createItem(chunk.comment));
      if (!chunkChildren.isEmpty) {
        output.insert(List.createItem({
          type: "Raw",
          value: "\n"
        }));
      }
    }
    if (firstAtrulesAllowed && !chunkChildren.isEmpty) {
      const lastRule = chunkChildren.last;
      if (lastRule.type !== "Atrule" || lastRule.name !== "import" && lastRule.name !== "charset") {
        firstAtrulesAllowed = false;
      }
    }
    if (specialComments !== "exclamation") {
      specialComments = false;
    }
    output.appendList(chunkChildren);
  } while (!input.isEmpty);
  return {
    ast
  };
}

// node_modules/csso/lib/syntax.js
function encodeString(value) {
  const stringApostrophe = string_exports.encode(value, true);
  const stringQuote = string_exports.encode(value);
  return stringApostrophe.length < stringQuote.length ? stringApostrophe : stringQuote;
}
var {
  lexer: lexer2,
  tokenize: tokenize3,
  parse: parse43,
  generate: generate43,
  walk: walk3,
  find: find2,
  findLast: findLast2,
  findAll: findAll2,
  fromPlainObject: fromPlainObject2,
  toPlainObject: toPlainObject2
} = fork({
  node: {
    String: {
      generate(node) {
        this.token(types_exports.String, encodeString(node.value));
      }
    },
    Url: {
      generate(node) {
        const encodedUrl = url_exports.encode(node.value);
        const string = encodeString(node.value);
        this.token(
          types_exports.Url,
          encodedUrl.length <= string.length + 5 ? encodedUrl : "url(" + string + ")"
        );
      }
    }
  }
});

// node_modules/csso/lib/index.js
var { parse: parse44, generate: generate44, compress: compress3 } = syntax_exports;
function debugOutput(name41, options, startTime, data) {
  if (options.debug) {
    console.error(`## ${name41} done in %d ms
`, Date.now() - startTime);
  }
  return data;
}
function createDefaultLogger(level) {
  let lastDebug;
  return function logger(title, ast) {
    let line = title;
    if (ast) {
      line = `[${((Date.now() - lastDebug) / 1e3).toFixed(3)}s] ${line}`;
    }
    if (level > 1 && ast) {
      let css = generate44(ast);
      if (level === 2 && css.length > 256) {
        css = css.substr(0, 256) + "...";
      }
      line += `
  ${css}
`;
    }
    console.error(line);
    lastDebug = Date.now();
  };
}
function buildCompressOptions(options) {
  options = { ...options };
  if (typeof options.logger !== "function" && options.debug) {
    options.logger = createDefaultLogger(options.debug);
  }
  return options;
}
function runHandler(ast, options, handlers4) {
  if (!Array.isArray(handlers4)) {
    handlers4 = [handlers4];
  }
  handlers4.forEach((fn) => fn(ast, options));
}
function minify(context, source, options) {
  options = options || {};
  const filename = options.filename || "<unknown>";
  let result;
  const ast = debugOutput(
    "parsing",
    options,
    Date.now(),
    parse44(source, {
      context,
      filename,
      positions: Boolean(options.sourceMap)
    })
  );
  if (options.beforeCompress) {
    debugOutput(
      "beforeCompress",
      options,
      Date.now(),
      runHandler(ast, options, options.beforeCompress)
    );
  }
  const compressResult = debugOutput(
    "compress",
    options,
    Date.now(),
    compress3(ast, buildCompressOptions(options))
  );
  if (options.afterCompress) {
    debugOutput(
      "afterCompress",
      options,
      Date.now(),
      runHandler(compressResult, options, options.afterCompress)
    );
  }
  if (options.sourceMap) {
    result = debugOutput("generate(sourceMap: true)", options, Date.now(), (() => {
      const tmp = generate44(compressResult.ast, { sourceMap: true });
      tmp.map._file = filename;
      tmp.map.setSourceContent(filename, source);
      return tmp;
    })());
  } else {
    result = debugOutput("generate", options, Date.now(), {
      css: generate44(compressResult.ast),
      map: null
    });
  }
  return result;
}
function minifyStylesheet(source, options) {
  return minify("stylesheet", source, options);
}

// src/note.ts
var cssAttachmentWhitelist = {
  ttf: ["font/ttf", "application/x-font-ttf", "application/x-font-truetype", "font/truetype"],
  otf: ["font/otf", "application/x-font-opentype"],
  woff: ["font/woff", "application/font-woff", "application/x-font-woff"],
  woff2: ["font/woff2", "application/font-woff2", "application/x-font-woff2"],
  svg: ["image/svg+xml"]
};
var Note = class {
  constructor(plugin) {
    this.isEncrypted = true;
    this.isForceUpload = false;
    this.isForceClipboard = false;
    var _a;
    this.plugin = plugin;
    this.leaf = (_a = this.plugin.app.workspace.getActiveFileView()) == null ? void 0 : _a.leaf;
    this.elements = [];
    this.template = new NoteTemplate();
  }
  /**
   * Return the name (key) of a frontmatter property, eg 'share_link'
   * @param key
   * @return {string} The name (key) of a frontmatter property
   */
  field(key) {
    return this.plugin.field(key);
  }
  async share() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    if (!this.plugin.settings.apiKey) {
      this.plugin.authRedirect("share").then();
      return;
    }
    this.status = new StatusMessage("If this message is showing, please do not change to another note as the current note data is still being parsed.", 0 /* Default */, 60 * 1e3);
    const startMode = this.leaf.getViewState();
    const previewMode = this.leaf.getViewState();
    previewMode.state.mode = "preview";
    await this.leaf.setViewState(previewMode);
    await new Promise((resolve) => setTimeout(resolve, 40));
    this.leaf.view.previewMode.applyScroll(0);
    await new Promise((resolve) => setTimeout(resolve, 40));
    try {
      const view = this.leaf.view;
      const renderer = view.modes.preview.renderer;
      this.elements.push(getElementStyle("html", document.documentElement));
      const bodyStyle = getElementStyle("body", document.body);
      bodyStyle.classes.push("share-note-plugin");
      this.elements.push(bodyStyle);
      this.elements.push(getElementStyle("preview", renderer.previewEl));
      this.elements.push(getElementStyle("pusher", renderer.pusherEl));
      this.contentDom = new DOMParser().parseFromString(await this.querySelectorAll(this.leaf.view), "text/html");
      this.cssRules = [];
      Array.from(document.styleSheets).forEach((x) => Array.from(x.cssRules).forEach((rule) => {
        this.cssRules.push(rule);
      }));
      this.css = this.cssRules.map((rule) => rule.cssText).join("").replace(/\n/g, "");
    } catch (e2) {
      console.log(e2);
      this.status.hide();
      new StatusMessage("Failed to parse current note, check console for details", 2 /* Error */);
      return;
    }
    setTimeout(() => {
      this.leaf.setViewState(startMode);
    }, 200);
    this.status.setStatus("Processing note...");
    const file = this.plugin.app.workspace.getActiveFile();
    if (!(file instanceof import_obsidian4.TFile)) {
      this.status.hide();
      new StatusMessage("There is no active file to share");
      return;
    }
    this.meta = this.plugin.app.metadataCache.getFileCache(file);
    if (this.plugin.settings.removeYaml) {
      (_a = this.contentDom.querySelector("div.metadata-container")) == null ? void 0 : _a.remove();
      (_b = this.contentDom.querySelector("pre.frontmatter")) == null ? void 0 : _b.remove();
      (_c = this.contentDom.querySelector("div.frontmatter-container")) == null ? void 0 : _c.remove();
    } else {
      this.contentDom.querySelectorAll("div.metadata-property").forEach((propertyContainerEl) => {
        var _a2, _b2;
        const propertyName = propertyContainerEl.getAttribute("data-property-key");
        if (propertyName) {
          const labelEl = propertyContainerEl.querySelector("input.metadata-property-key-input");
          labelEl == null ? void 0 : labelEl.setAttribute("value", propertyName);
          const valueEl = propertyContainerEl.querySelector("div.metadata-property-value > input");
          const value = ((_b2 = (_a2 = this.meta) == null ? void 0 : _a2.frontmatter) == null ? void 0 : _b2[propertyName]) || "";
          valueEl == null ? void 0 : valueEl.setAttribute("value", value);
          switch (valueEl == null ? void 0 : valueEl.getAttribute("type")) {
            case "checkbox":
              if (value)
                valueEl.setAttribute("checked", "checked");
              break;
          }
        }
      });
    }
    if (this.plugin.settings.removeBacklinksFooter) {
      (_d = this.contentDom.querySelector("div.embedded-backlinks")) == null ? void 0 : _d.remove();
    }
    const defaultCalloutType = this.getCalloutIcon((selectorText) => selectorText === ".callout") || "pencil";
    for (const el of this.contentDom.getElementsByClassName("callout")) {
      const type = el.getAttribute("data-callout");
      let icon = this.getCalloutIcon((selectorText) => selectorText.includes(`data-callout="${type}"`)) || defaultCalloutType;
      icon = icon.replace("lucide-", "");
      const iconEl = el.querySelector("div.callout-icon");
      const svgEl = iconEl == null ? void 0 : iconEl.querySelector("svg");
      if (svgEl) {
        svgEl.outerHTML = `<svg width="16" height="16" data-share-note-lucide="${icon}"></svg>`;
      }
    }
    for (const el of this.contentDom.querySelectorAll("a.internal-link, a.footnote-link")) {
      const href = el.getAttribute("href");
      const match = href ? href.match(/^([^#]+)/) : null;
      if (href == null ? void 0 : href.match(/^#/)) {
        const linkTypes = [
          `[data-heading="${href.slice(1)}"]`,
          // Links to a heading
          `[id="${href.slice(1)}"]`
          // Links to a footnote
        ];
        linkTypes.forEach((selector2) => {
          var _a2;
          if ((_a2 = this.contentDom.querySelectorAll(selector2)) == null ? void 0 : _a2[0]) {
            el.setAttribute("onclick", `document.querySelectorAll('${selector2}')[0].scrollIntoView(true)`);
          }
        });
        el.removeAttribute("target");
        el.removeAttribute("href");
        continue;
      } else if (match) {
        const linkedFile = this.plugin.app.metadataCache.getFirstLinkpathDest(match[1], "");
        if (linkedFile instanceof import_obsidian4.TFile) {
          const linkedMeta = this.plugin.app.metadataCache.getFileCache(linkedFile);
          if ((_e = linkedMeta == null ? void 0 : linkedMeta.frontmatter) == null ? void 0 : _e[this.field(0 /* link */)]) {
            el.setAttribute("href", (_f = linkedMeta == null ? void 0 : linkedMeta.frontmatter) == null ? void 0 : _f[this.field(0 /* link */)]);
            el.removeAttribute("target");
            continue;
          }
        }
      }
      el.replaceWith(el.innerHTML);
    }
    for (const el of this.contentDom.querySelectorAll("a.external-link")) {
      el.removeAttribute("target");
    }
    this.expiration = this.getExpiration();
    const uploadResult = await this.processMedia();
    this.cssResult = uploadResult.css;
    await this.processCss();
    let decryptionKey = "";
    if ((_h = (_g = this.meta) == null ? void 0 : _g.frontmatter) == null ? void 0 : _h[this.field(0 /* link */)]) {
      const match = parseExistingShareUrl((_j = (_i = this.meta) == null ? void 0 : _i.frontmatter) == null ? void 0 : _j[this.field(0 /* link */)]);
      if (match) {
        this.template.filename = match.filename;
        decryptionKey = match.decryptionKey;
      }
    }
    this.template.encrypted = this.isEncrypted;
    let title;
    switch (this.plugin.settings.titleSource) {
      case 1 /* First H1 */:
        title = (_l = (_k = this.contentDom.getElementsByTagName("h1")) == null ? void 0 : _k[0]) == null ? void 0 : _l.innerText;
        break;
      case 2 /* Frontmatter property */:
        title = (_n = (_m = this.meta) == null ? void 0 : _m.frontmatter) == null ? void 0 : _n[this.field(4 /* title */)];
        break;
    }
    if (!title) {
      title = file.basename;
    }
    if (this.isEncrypted) {
      this.status.setStatus("Encrypting note...");
      const plaintext = JSON.stringify({
        content: this.contentDom.body.innerHTML,
        basename: title
      });
      const encryptedData = await encryptString(plaintext, decryptionKey);
      this.template.content = JSON.stringify({
        ciphertext: encryptedData.ciphertext
      });
      decryptionKey = encryptedData.key;
    } else {
      this.template.content = this.contentDom.body.innerHTML;
      this.template.title = title;
      const desc = Array.from(this.contentDom.querySelectorAll("p")).map((x) => x.innerText).filter((x) => !!x).join(" ");
      this.template.description = desc.length > 200 ? desc.slice(0, 197) + "..." : desc;
    }
    this.template.width = this.plugin.settings.noteWidth;
    if (this.plugin.settings.themeMode !== 0 /* Same as theme */) {
      this.elements.filter((x) => x.element === "body").forEach((item) => {
        item.classes = item.classes.filter((cls) => cls !== "theme-dark" && cls !== "theme-light");
        item.classes.push("theme-" + ThemeMode[this.plugin.settings.themeMode].toLowerCase());
      });
    }
    this.template.elements = this.elements;
    this.template.mathJax = !!this.contentDom.body.innerHTML.match(/<mjx-container/);
    this.status.setStatus("Uploading note...");
    let shareLink = await this.plugin.api.createNote(this.template, this.expiration);
    (0, import_obsidian4.requestUrl)(shareLink).then().catch();
    if (shareLink && this.isEncrypted) {
      shareLink += "#" + decryptionKey;
    }
    let shareMessage = "The note has been shared";
    if (shareLink) {
      await this.plugin.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter[this.field(0 /* link */)] = shareLink;
        frontmatter[this.field(1 /* updated */)] = (0, import_obsidian4.moment)().format();
      });
      if (this.plugin.settings.clipboard || this.isForceClipboard) {
        try {
          await navigator.clipboard.writeText(shareLink);
          shareMessage = `${shareMessage} and the link is copied to your clipboard \u{1F4CB}`;
        } catch (e2) {
        }
        this.isForceClipboard = false;
      }
    }
    this.status.hide();
    new StatusMessage(shareMessage, 3 /* Success */);
  }
  /**
   * Upload media attachments
   */
  async processMedia() {
    const elements = ["img", "video"];
    this.status.setStatus("Processing attachments...");
    for (const el of this.contentDom.querySelectorAll(elements.join(","))) {
      const src = el.getAttribute("src");
      if (!src)
        continue;
      if (src.startsWith("http") && !src.match(/^https?:\/\/localhost/)) {
        continue;
      }
      let content;
      try {
        const res = await fetch(src);
        if (res && res.status === 200) {
          content = await res.arrayBuffer();
        }
      } catch (e2) {
        continue;
      }
      const parsed = new URL(src);
      const filetype = parsed.pathname.split(".").pop();
      if (filetype && content) {
        const hash = await sha1(content);
        await this.plugin.api.queueUpload({
          data: {
            filetype,
            hash,
            content,
            byteLength: content.byteLength,
            expiration: this.expiration
          },
          callback: (url) => el.setAttribute("src", url)
        });
      }
      el.removeAttribute("alt");
    }
    return this.plugin.api.processQueue(this.status);
  }
  /**
   * Upload theme CSS, unless this file has previously been shared,
   * or the user has requested a force re-upload
   */
  async processCss() {
    var _a, _b, _c;
    if (this.isForceUpload || !this.cssResult) {
      this.status.setStatus("Processing CSS...");
      const attachments = this.css.match(/url\s*\(.*?\)/g) || [];
      for (const attachment of attachments) {
        const assetMatch = attachment.match(/url\s*\(\s*"*(.*?)\s*(?<!\\)"\s*\)/);
        if (!assetMatch)
          continue;
        const assetUrl = (assetMatch == null ? void 0 : assetMatch[1]) || "";
        if (assetUrl.startsWith("data:")) {
          const parsed = (0, import_data_uri_to_buffer.dataUriToBuffer)(assetUrl);
          if (parsed == null ? void 0 : parsed.type) {
            if (parsed.type === "application/octet-stream") {
              const decoded = FileTypes_default.getFromSignature(parsed.buffer);
              if (!decoded)
                continue;
              parsed.type = decoded.mimetype;
            }
            const filetype = this.extensionFromMime(parsed.type);
            if (filetype) {
              const hash = await sha1(parsed.buffer);
              await this.plugin.api.queueUpload({
                data: {
                  filetype,
                  hash,
                  content: parsed.buffer,
                  byteLength: parsed.buffer.byteLength,
                  expiration: this.expiration
                },
                callback: (url) => {
                  this.css = this.css.replace(assetMatch[0], `url("${url}")`);
                }
              });
            }
          }
        } else if (assetUrl && !assetUrl.startsWith("http")) {
          const filename = assetUrl.match(/([^/\\]+)\.(\w+)$/);
          if (filename) {
            if (cssAttachmentWhitelist[filename[2]]) {
              const res = await fetch(assetUrl);
              const contents = await res.arrayBuffer();
              const hash = await sha1(contents);
              await this.plugin.api.queueUpload({
                data: {
                  filetype: filename[2],
                  hash,
                  content: contents,
                  byteLength: contents.byteLength,
                  expiration: this.expiration
                },
                callback: (url) => {
                  this.css = this.css.replace(assetMatch[0], `url("${url}")`);
                }
              });
            }
          }
        }
      }
      this.status.setStatus("Uploading CSS attachments...");
      await this.plugin.api.processQueue(this.status, "CSS attachment");
      this.status.setStatus("Uploading CSS...");
      const minified = minifyStylesheet(this.css).css;
      const cssHash = await sha1(minified);
      try {
        if (cssHash !== ((_a = this.cssResult) == null ? void 0 : _a.hash)) {
          await this.plugin.api.upload({
            filetype: "css",
            hash: cssHash,
            content: minified,
            byteLength: minified.length,
            expiration: this.expiration
          });
        }
        this.plugin.settings.theme = ((_c = (_b = this.plugin.app) == null ? void 0 : _b.customCss) == null ? void 0 : _c.theme) || "";
        await this.plugin.saveSettings();
      } catch (e2) {
      }
    }
  }
  async querySelectorAll(view) {
    const renderer = view.modes.preview.renderer;
    let html = "";
    await new Promise((resolve) => {
      let count = 0;
      let parsing = 0;
      const timer = setInterval(() => {
        try {
          const sections = renderer.sections;
          count++;
          if (renderer.parsing)
            parsing++;
          if (count > parsing) {
            let rendered = 0;
            if (sections.length > 12) {
              sections.slice(sections.length - 7, sections.length - 1).forEach((section) => {
                if (section.el.innerHTML)
                  rendered++;
              });
              if (rendered > 3)
                count = 100;
            } else {
              count = 100;
            }
          }
          if (count > 40) {
            html = this.reduceSections(renderer.sections);
            resolve();
          }
        } catch (e2) {
          clearInterval(timer);
          resolve();
        }
      }, 100);
    });
    return html;
  }
  getCalloutIcon(test) {
    const rule = this.cssRules.find((rule2) => rule2.selectorText && test(rule2.selectorText) && rule2.style.getPropertyValue("--callout-icon"));
    if (rule) {
      return rule.style.getPropertyValue("--callout-icon");
    }
    return "";
  }
  reduceSections(sections) {
    return sections.reduce((p, c2) => p + c2.el.outerHTML, "");
  }
  /**
   * Turn the font mime-type into an extension.
   * @param {string} mimeType
   * @return {string|undefined}
   */
  extensionFromMime(mimeType) {
    const mimes = cssAttachmentWhitelist;
    return Object.keys(mimes).find((x) => mimes[x].includes((mimeType || "").toLowerCase()));
  }
  /**
   * Get the value of a frontmatter property
   */
  getProperty(field) {
    var _a, _b;
    return (_b = (_a = this.meta) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[this.plugin.field(field)];
  }
  /**
   * Force all related assets to upload again
   */
  forceUpload() {
    this.isForceUpload = true;
  }
  /**
   * Copy the shared link to the clipboard, regardless of the user setting
   */
  forceClipboard() {
    this.isForceClipboard = true;
  }
  /**
   * Enable/disable encryption for the note
   */
  shareAsPlainText(isPlainText) {
    this.isEncrypted = !isPlainText;
  }
  /**
   * Calculate an expiry datetime from the provided expiry duration
   */
  getExpiration() {
    const whitelist = ["minute", "hour", "day", "month"];
    const expiration = this.getProperty(5 /* expires */) || this.plugin.settings.expiry;
    if (expiration) {
      const match = expiration.match(/^(\d+) ([a-z]+?)s?$/);
      if (match && whitelist.includes(match[2])) {
        return parseInt((0, import_obsidian4.moment)().add(+match[1], match[2] + "s").format("x"), 10);
      }
    }
  }
};

// src/UI.ts
var import_obsidian5 = require("obsidian");
var ConfirmDialog = class extends import_obsidian5.Modal {
  constructor(app, onConfirm) {
    super(app);
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    if (this.title) {
      contentEl.createEl("h2", { text: this.title });
    }
    if (this.body) {
      contentEl.createEl("p", { text: this.body });
    }
    new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("\u{1F5D1}\uFE0F Yes, delete").setCta().onClick(() => {
      this.close();
      this.onConfirm();
    })).addButton((btn) => btn.setButtonText("No, cancel").onClick(() => {
      this.close();
    }));
  }
};
var UI = class {
  constructor(app) {
    this.app = app;
  }
  confirmDialog(title = "", body = "", onConfirm) {
    const dialog = new ConfirmDialog(this.app, onConfirm);
    dialog.title = title;
    dialog.body = body;
    dialog.open();
    return dialog;
  }
};

// src/main.ts
var SharePlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    // Expose some tools in the plugin object
    this.hash = shortHash;
    this.sha256 = sha256;
  }
  async onload() {
    await this.loadSettings();
    if (!this.settings.uid) {
      this.settings.uid = await shortHash("" + Date.now() + Math.random());
      await this.saveSettings();
    }
    if (this.settings.server === "https://api.obsidianshare.com") {
      this.settings.server = "https://api.note.sx";
      await this.saveSettings();
    }
    this.settingsPage = new ShareSettingsTab(this.app, this);
    this.addSettingTab(this.settingsPage);
    this.api = new API(this);
    this.ui = new UI(this.app);
    this.registerObsidianProtocolHandler("share-note", async (data) => {
      if (data.action === "share-note" && data.key) {
        this.settings.apiKey = data.key;
        await this.saveSettings();
        if (this.settingsPage.apikeyEl) {
          this.settingsPage.apikeyEl.setValue(data.key);
        }
        if (this.settings.authRedirect === "share") {
          this.authRedirect(null).then();
          this.uploadNote().then();
        } else {
          new StatusMessage("Plugin successfully connected. You can now start sharing notes!", 3 /* Success */, 6e3);
        }
      }
    });
    this.addCommand({
      id: "share-note",
      name: "Share current note",
      callback: () => this.uploadNote()
    });
    this.addCommand({
      id: "force-upload",
      name: "Force re-upload of all data for this note",
      callback: () => this.uploadNote(true)
    });
    this.addCommand({
      id: "delete-note",
      name: "Delete this shared note",
      checkCallback: (checking) => {
        const sharedFile = this.hasSharedFile();
        if (checking) {
          return !!sharedFile;
        } else if (sharedFile) {
          this.deleteSharedNote(sharedFile.file);
        }
      }
    });
    this.addCommand({
      id: "copy-link",
      name: "Copy shared note link",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (checking) {
          return file instanceof import_obsidian6.TFile;
        } else if (file) {
          this.copyShareLink(file);
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian6.TFile && file.extension === "md") {
          menu.addItem((item) => {
            item.setIcon("share-2");
            item.setTitle("Copy shared link");
            item.onClick(async () => {
              await this.copyShareLink(file);
            });
          });
        }
      })
    );
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.addShareIcons();
    }));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Upload a note.
   * @param forceUpload - Optionally force an upload of all related assets
   * @param forceClipboard - Optionally copy the link to the clipboard, regardless of the user setting
   */
  async uploadNote(forceUpload = false, forceClipboard = false) {
    var _a, _b;
    const file = this.app.workspace.getActiveFile();
    if (file instanceof import_obsidian6.TFile) {
      const meta = this.app.metadataCache.getFileCache(file);
      const note = new Note(this);
      if (this.settings.shareUnencrypted) {
        note.shareAsPlainText(true);
      }
      if (((_a = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _a[note.field(3 /* unencrypted */)]) === true) {
        note.shareAsPlainText(true);
      }
      if (((_b = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _b[note.field(2 /* encrypted */)]) === true) {
        note.shareAsPlainText(false);
      }
      if (forceUpload) {
        note.forceUpload();
      }
      if (forceClipboard) {
        note.forceClipboard();
      }
      try {
        await note.share();
      } catch (e2) {
        if (e2.message !== "Known error") {
          console.log(e2);
          new StatusMessage("There was an error uploading the note, please try again.", 2 /* Error */);
        }
      }
      note.status.hide();
      this.addShareIcons();
    }
  }
  /**
   * Copy the share link to the clipboard. The note will be shared first if neccessary.
   * @param file
   */
  async copyShareLink(file) {
    var _a;
    const meta = this.app.metadataCache.getFileCache(file);
    const shareLink = (_a = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _a[this.settings.yamlField + "_" + YamlField[0 /* link */]];
    if (shareLink) {
      await navigator.clipboard.writeText(shareLink);
      new StatusMessage("\u{1F4CB} Shared link copied to clipboard");
    } else {
      await this.uploadNote(false, true);
    }
    return shareLink;
  }
  async deleteSharedNote(file) {
    const sharedFile = this.hasSharedFile(file);
    if (sharedFile) {
      this.ui.confirmDialog(
        "Delete shared note?",
        "Are you sure you want to delete this shared note and the shared link? This will not delete your local note.",
        async () => {
          new StatusMessage("Deleting note...");
          await this.api.deleteSharedNote(sharedFile.url);
          await this.app.fileManager.processFrontMatter(sharedFile.file, (frontmatter) => {
            delete frontmatter[this.field(0 /* link */)];
            delete frontmatter[this.field(1 /* updated */)];
          });
        }
      );
    }
  }
  addShareIcons() {
    let count = 0;
    const timer = setInterval(() => {
      var _a, _b;
      count++;
      if (count > 8) {
        clearInterval(timer);
        return;
      }
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile)
        return;
      const shareLink = (_b = (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[this.field(0 /* link */)];
      if (!shareLink)
        return;
      document.querySelectorAll(`div.metadata-property[data-property-key="${this.field(0 /* link */)}"]`).forEach((propertyEl) => {
        const valueEl = propertyEl.querySelector("div.metadata-property-value");
        const linkEl = valueEl == null ? void 0 : valueEl.querySelector("div.external-link");
        if ((linkEl == null ? void 0 : linkEl.innerText) !== shareLink)
          return;
        if (valueEl && !valueEl.querySelector("div.share-note-icons")) {
          const iconsEl = document.createElement("div");
          iconsEl.classList.add("share-note-icons");
          const shareIcon = iconsEl.createEl("span");
          shareIcon.title = "Re-share note";
          (0, import_obsidian6.setIcon)(shareIcon, "upload-cloud");
          shareIcon.onclick = () => this.uploadNote();
          const copyIcon = iconsEl.createEl("span");
          copyIcon.title = "Copy link to clipboard";
          (0, import_obsidian6.setIcon)(copyIcon, "copy");
          copyIcon.onclick = async () => {
            await navigator.clipboard.writeText(shareLink);
            new StatusMessage("\u{1F4CB} Shared link copied to clipboard");
          };
          const deleteIcon = iconsEl.createEl("span");
          deleteIcon.title = "Delete shared note";
          (0, import_obsidian6.setIcon)(deleteIcon, "trash-2");
          deleteIcon.onclick = () => this.deleteSharedNote(activeFile);
          valueEl.prepend(iconsEl);
        }
      });
    }, 50);
  }
  /**
   * Redirect a user back to their position in the flow after they finish the auth.
   * NULL to clear the redirection.
   */
  async authRedirect(value) {
    this.settings.authRedirect = value;
    await this.saveSettings();
    if (value)
      window.open(this.settings.server + "/v1/account/get-key?id=" + this.settings.uid);
  }
  hasSharedFile(file) {
    var _a;
    if (!file) {
      file = this.app.workspace.getActiveFile() || void 0;
    }
    if (file) {
      const meta = this.app.metadataCache.getFileCache(file);
      const shareLink = (_a = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _a[this.settings.yamlField + "_" + YamlField[0 /* link */]];
      if (shareLink && parseExistingShareUrl(shareLink)) {
        return {
          file,
          ...parseExistingShareUrl(shareLink)
        };
      }
    }
    return false;
  }
  field(key) {
    return [this.settings.yamlField, YamlField[key]].join("_");
  }
};

/* nosourcemap */